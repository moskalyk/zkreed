{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\n\nconst is_observable_1 = __importDefault(require(\"is-observable\"));\n\nconst common_1 = require(\"../common\");\n\nconst transferable_1 = require(\"../transferable\");\n\nconst messages_1 = require(\"../types/messages\");\n\nconst implementation_1 = __importDefault(require(\"./implementation\"));\n\nvar common_2 = require(\"../common\");\n\nObject.defineProperty(exports, \"registerSerializer\", {\n  enumerable: true,\n  get: function () {\n    return common_2.registerSerializer;\n  }\n});\n\nvar transferable_2 = require(\"../transferable\");\n\nObject.defineProperty(exports, \"Transfer\", {\n  enumerable: true,\n  get: function () {\n    return transferable_2.Transfer;\n  }\n});\n/** Returns `true` if this code is currently running in a worker. */\n\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\n\nconst isMasterJobCancelMessage = thing => thing && thing.type === messages_1.MasterMessageType.cancel;\n\nconst isMasterJobRunMessage = thing => thing && thing.type === messages_1.MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\n\n\nconst isObservable = thing => is_observable_1.default(thing) || isZenObservable(thing);\n\nfunction isZenObservable(thing) {\n  return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\n\nfunction deconstructTransfer(thing) {\n  return transferable_1.isTransferDescriptor(thing) ? {\n    payload: thing.send,\n    transferables: thing.transferables\n  } : {\n    payload: thing,\n    transferables: undefined\n  };\n}\n\nfunction postFunctionInitMessage() {\n  const initMessage = {\n    type: messages_1.WorkerMessageType.init,\n    exposed: {\n      type: \"function\"\n    }\n  };\n  implementation_1.default.postMessageToMaster(initMessage);\n}\n\nfunction postModuleInitMessage(methodNames) {\n  const initMessage = {\n    type: messages_1.WorkerMessageType.init,\n    exposed: {\n      type: \"module\",\n      methods: methodNames\n    }\n  };\n  implementation_1.default.postMessageToMaster(initMessage);\n}\n\nfunction postJobErrorMessage(uid, rawError) {\n  const {\n    payload: error,\n    transferables\n  } = deconstructTransfer(rawError);\n  const errorMessage = {\n    type: messages_1.WorkerMessageType.error,\n    uid,\n    error: common_1.serialize(error)\n  };\n  implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\n\nfunction postJobResultMessage(uid, completed, resultValue) {\n  const {\n    payload,\n    transferables\n  } = deconstructTransfer(resultValue);\n  const resultMessage = {\n    type: messages_1.WorkerMessageType.result,\n    uid,\n    complete: completed ? true : undefined,\n    payload\n  };\n  implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\n\nfunction postJobStartMessage(uid, resultType) {\n  const startMessage = {\n    type: messages_1.WorkerMessageType.running,\n    uid,\n    resultType\n  };\n  implementation_1.default.postMessageToMaster(startMessage);\n}\n\nfunction postUncaughtErrorMessage(error) {\n  try {\n    const errorMessage = {\n      type: messages_1.WorkerMessageType.uncaughtError,\n      error: common_1.serialize(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage);\n  } catch (subError) {\n    // tslint:disable-next-line no-console\n    console.error(\"Not reporting uncaught error back to master thread as it \" + \"occured while reporting an uncaught error already.\" + \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n  }\n}\n\nfunction runFunction(jobUID, fn, args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let syncResult;\n\n    try {\n      syncResult = fn(...args);\n    } catch (error) {\n      return postJobErrorMessage(jobUID, error);\n    }\n\n    const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n    postJobStartMessage(jobUID, resultType);\n\n    if (isObservable(syncResult)) {\n      const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, common_1.serialize(value)), error => {\n        postJobErrorMessage(jobUID, common_1.serialize(error));\n        activeSubscriptions.delete(jobUID);\n      }, () => {\n        postJobResultMessage(jobUID, true);\n        activeSubscriptions.delete(jobUID);\n      });\n      activeSubscriptions.set(jobUID, subscription);\n    } else {\n      try {\n        const result = yield syncResult;\n        postJobResultMessage(jobUID, true, common_1.serialize(result));\n      } catch (error) {\n        postJobErrorMessage(jobUID, common_1.serialize(error));\n      }\n    }\n  });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\n\n\nfunction expose(exposed) {\n  if (!implementation_1.default.isWorkerRuntime()) {\n    throw Error(\"expose() called in the master thread.\");\n  }\n\n  if (exposeCalled) {\n    throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n  }\n\n  exposeCalled = true;\n\n  if (typeof exposed === \"function\") {\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && !messageData.method) {\n        runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n      }\n    });\n    postFunctionInitMessage();\n  } else if (typeof exposed === \"object\" && exposed) {\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n      if (isMasterJobRunMessage(messageData) && messageData.method) {\n        runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n      }\n    });\n    const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n    postModuleInitMessage(methodNames);\n  } else {\n    throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n  }\n\n  implementation_1.default.subscribeToMasterMessages(messageData => {\n    if (isMasterJobCancelMessage(messageData)) {\n      const jobUID = messageData.uid;\n      const subscription = activeSubscriptions.get(jobUID);\n\n      if (subscription) {\n        subscription.unsubscribe();\n        activeSubscriptions.delete(jobUID);\n      }\n    }\n  });\n}\n\nexports.expose = expose;\n\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n  self.addEventListener(\"error\", event => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n  });\n  self.addEventListener(\"unhandledrejection\", event => {\n    const error = event.reason;\n\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}\n\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n  process.on(\"uncaughtException\", error => {\n    // Post with some delay, so the master had some time to subscribe to messages\n    setTimeout(() => postUncaughtErrorMessage(error), 250);\n  });\n  process.on(\"unhandledRejection\", error => {\n    if (error && typeof error.message === \"string\") {\n      // Post with some delay, so the master had some time to subscribe to messages\n      setTimeout(() => postUncaughtErrorMessage(error), 250);\n    }\n  });\n}","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","expose","isWorkerRuntime","Transfer","registerSerializer","is_observable_1","require","common_1","transferable_1","messages_1","implementation_1","common_2","enumerable","get","transferable_2","default","exposeCalled","activeSubscriptions","Map","isMasterJobCancelMessage","thing","type","MasterMessageType","cancel","isMasterJobRunMessage","run","isObservable","isZenObservable","subscribe","deconstructTransfer","isTransferDescriptor","payload","send","transferables","undefined","postFunctionInitMessage","initMessage","WorkerMessageType","init","exposed","postMessageToMaster","postModuleInitMessage","methodNames","methods","postJobErrorMessage","uid","rawError","error","errorMessage","serialize","postJobResultMessage","completed","resultValue","resultMessage","complete","postJobStartMessage","resultType","startMessage","running","postUncaughtErrorMessage","uncaughtError","subError","console","runFunction","jobUID","fn","args","syncResult","subscription","delete","set","Error","subscribeToMasterMessages","messageData","method","map","deserialize","keys","filter","key","unsubscribe","self","addEventListener","event","setTimeout","reason","message","process","on"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/threads/dist/worker/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.expose = exports.isWorkerRuntime = exports.Transfer = exports.registerSerializer = void 0;\nconst is_observable_1 = __importDefault(require(\"is-observable\"));\nconst common_1 = require(\"../common\");\nconst transferable_1 = require(\"../transferable\");\nconst messages_1 = require(\"../types/messages\");\nconst implementation_1 = __importDefault(require(\"./implementation\"));\nvar common_2 = require(\"../common\");\nObject.defineProperty(exports, \"registerSerializer\", { enumerable: true, get: function () { return common_2.registerSerializer; } });\nvar transferable_2 = require(\"../transferable\");\nObject.defineProperty(exports, \"Transfer\", { enumerable: true, get: function () { return transferable_2.Transfer; } });\n/** Returns `true` if this code is currently running in a worker. */\nexports.isWorkerRuntime = implementation_1.default.isWorkerRuntime;\nlet exposeCalled = false;\nconst activeSubscriptions = new Map();\nconst isMasterJobCancelMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.cancel;\nconst isMasterJobRunMessage = (thing) => thing && thing.type === messages_1.MasterMessageType.run;\n/**\n * There are issues with `is-observable` not recognizing zen-observable's instances.\n * We are using `observable-fns`, but it's based on zen-observable, too.\n */\nconst isObservable = (thing) => is_observable_1.default(thing) || isZenObservable(thing);\nfunction isZenObservable(thing) {\n    return thing && typeof thing === \"object\" && typeof thing.subscribe === \"function\";\n}\nfunction deconstructTransfer(thing) {\n    return transferable_1.isTransferDescriptor(thing)\n        ? { payload: thing.send, transferables: thing.transferables }\n        : { payload: thing, transferables: undefined };\n}\nfunction postFunctionInitMessage() {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"function\"\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postModuleInitMessage(methodNames) {\n    const initMessage = {\n        type: messages_1.WorkerMessageType.init,\n        exposed: {\n            type: \"module\",\n            methods: methodNames\n        }\n    };\n    implementation_1.default.postMessageToMaster(initMessage);\n}\nfunction postJobErrorMessage(uid, rawError) {\n    const { payload: error, transferables } = deconstructTransfer(rawError);\n    const errorMessage = {\n        type: messages_1.WorkerMessageType.error,\n        uid,\n        error: common_1.serialize(error)\n    };\n    implementation_1.default.postMessageToMaster(errorMessage, transferables);\n}\nfunction postJobResultMessage(uid, completed, resultValue) {\n    const { payload, transferables } = deconstructTransfer(resultValue);\n    const resultMessage = {\n        type: messages_1.WorkerMessageType.result,\n        uid,\n        complete: completed ? true : undefined,\n        payload\n    };\n    implementation_1.default.postMessageToMaster(resultMessage, transferables);\n}\nfunction postJobStartMessage(uid, resultType) {\n    const startMessage = {\n        type: messages_1.WorkerMessageType.running,\n        uid,\n        resultType\n    };\n    implementation_1.default.postMessageToMaster(startMessage);\n}\nfunction postUncaughtErrorMessage(error) {\n    try {\n        const errorMessage = {\n            type: messages_1.WorkerMessageType.uncaughtError,\n            error: common_1.serialize(error)\n        };\n        implementation_1.default.postMessageToMaster(errorMessage);\n    }\n    catch (subError) {\n        // tslint:disable-next-line no-console\n        console.error(\"Not reporting uncaught error back to master thread as it \" +\n            \"occured while reporting an uncaught error already.\" +\n            \"\\nLatest error:\", subError, \"\\nOriginal error:\", error);\n    }\n}\nfunction runFunction(jobUID, fn, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let syncResult;\n        try {\n            syncResult = fn(...args);\n        }\n        catch (error) {\n            return postJobErrorMessage(jobUID, error);\n        }\n        const resultType = isObservable(syncResult) ? \"observable\" : \"promise\";\n        postJobStartMessage(jobUID, resultType);\n        if (isObservable(syncResult)) {\n            const subscription = syncResult.subscribe(value => postJobResultMessage(jobUID, false, common_1.serialize(value)), error => {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n                activeSubscriptions.delete(jobUID);\n            }, () => {\n                postJobResultMessage(jobUID, true);\n                activeSubscriptions.delete(jobUID);\n            });\n            activeSubscriptions.set(jobUID, subscription);\n        }\n        else {\n            try {\n                const result = yield syncResult;\n                postJobResultMessage(jobUID, true, common_1.serialize(result));\n            }\n            catch (error) {\n                postJobErrorMessage(jobUID, common_1.serialize(error));\n            }\n        }\n    });\n}\n/**\n * Expose a function or a module (an object whose values are functions)\n * to the main thread. Must be called exactly once in every worker thread\n * to signal its API to the main thread.\n *\n * @param exposed Function or object whose values are functions\n */\nfunction expose(exposed) {\n    if (!implementation_1.default.isWorkerRuntime()) {\n        throw Error(\"expose() called in the master thread.\");\n    }\n    if (exposeCalled) {\n        throw Error(\"expose() called more than once. This is not possible. Pass an object to expose() if you want to expose multiple functions.\");\n    }\n    exposeCalled = true;\n    if (typeof exposed === \"function\") {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && !messageData.method) {\n                runFunction(messageData.uid, exposed, messageData.args.map(common_1.deserialize));\n            }\n        });\n        postFunctionInitMessage();\n    }\n    else if (typeof exposed === \"object\" && exposed) {\n        implementation_1.default.subscribeToMasterMessages(messageData => {\n            if (isMasterJobRunMessage(messageData) && messageData.method) {\n                runFunction(messageData.uid, exposed[messageData.method], messageData.args.map(common_1.deserialize));\n            }\n        });\n        const methodNames = Object.keys(exposed).filter(key => typeof exposed[key] === \"function\");\n        postModuleInitMessage(methodNames);\n    }\n    else {\n        throw Error(`Invalid argument passed to expose(). Expected a function or an object, got: ${exposed}`);\n    }\n    implementation_1.default.subscribeToMasterMessages(messageData => {\n        if (isMasterJobCancelMessage(messageData)) {\n            const jobUID = messageData.uid;\n            const subscription = activeSubscriptions.get(jobUID);\n            if (subscription) {\n                subscription.unsubscribe();\n                activeSubscriptions.delete(jobUID);\n            }\n        }\n    });\n}\nexports.expose = expose;\nif (typeof self !== \"undefined\" && typeof self.addEventListener === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    self.addEventListener(\"error\", event => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(event.error || event), 250);\n    });\n    self.addEventListener(\"unhandledrejection\", event => {\n        const error = event.reason;\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\nif (typeof process !== \"undefined\" && typeof process.on === \"function\" && implementation_1.default.isWorkerRuntime()) {\n    process.on(\"uncaughtException\", (error) => {\n        // Post with some delay, so the master had some time to subscribe to messages\n        setTimeout(() => postUncaughtErrorMessage(error), 250);\n    });\n    process.on(\"unhandledRejection\", (error) => {\n        if (error && typeof error.message === \"string\") {\n            // Post with some delay, so the master had some time to subscribe to messages\n            setTimeout(() => postUncaughtErrorMessage(error), 250);\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}