{"ast":null,"code":"/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\"); // === Abstract Operations ===\n\nfunction getMethod(obj, key) {\n  const value = obj[key];\n\n  if (value == null) {\n    return undefined;\n  }\n\n  if (typeof value !== \"function\") {\n    throw new TypeError(value + \" is not a function\");\n  }\n\n  return value;\n}\n\nfunction getSpecies(obj) {\n  let ctor = obj.constructor;\n\n  if (ctor !== undefined) {\n    ctor = ctor[SymbolSpecies];\n\n    if (ctor === null) {\n      ctor = undefined;\n    }\n  }\n\n  return ctor !== undefined ? ctor : Observable;\n}\n\nfunction isObservable(x) {\n  return x instanceof Observable; // SPEC: Brand check\n}\n\nfunction hostReportError(error) {\n  if (hostReportError.log) {\n    hostReportError.log(error);\n  } else {\n    setTimeout(() => {\n      throw error;\n    }, 0);\n  }\n}\n\nfunction enqueue(fn) {\n  Promise.resolve().then(() => {\n    try {\n      fn();\n    } catch (e) {\n      hostReportError(e);\n    }\n  });\n}\n\nfunction cleanupSubscription(subscription) {\n  const cleanup = subscription._cleanup;\n\n  if (cleanup === undefined) {\n    return;\n  }\n\n  subscription._cleanup = undefined;\n\n  if (!cleanup) {\n    return;\n  }\n\n  try {\n    if (typeof cleanup === \"function\") {\n      cleanup();\n    } else {\n      const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n\n      if (unsubscribe) {\n        unsubscribe.call(cleanup);\n      }\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n}\n\nfunction closeSubscription(subscription) {\n  subscription._observer = undefined;\n  subscription._queue = undefined;\n  subscription._state = \"closed\";\n}\n\nfunction flushSubscription(subscription) {\n  const queue = subscription._queue;\n\n  if (!queue) {\n    return;\n  }\n\n  subscription._queue = undefined;\n  subscription._state = \"ready\";\n\n  for (const item of queue) {\n    notifySubscription(subscription, item.type, item.value);\n\n    if (subscription._state === \"closed\") {\n      break;\n    }\n  }\n}\n\nfunction notifySubscription(subscription, type, value) {\n  subscription._state = \"running\";\n  const observer = subscription._observer;\n\n  try {\n    const m = observer ? getMethod(observer, type) : undefined;\n\n    switch (type) {\n      case \"next\":\n        if (m) m.call(observer, value);\n        break;\n\n      case \"error\":\n        closeSubscription(subscription);\n        if (m) m.call(observer, value);else throw value;\n        break;\n\n      case \"complete\":\n        closeSubscription(subscription);\n        if (m) m.call(observer);\n        break;\n    }\n  } catch (e) {\n    hostReportError(e);\n  }\n\n  if (subscription._state === \"closed\") {\n    cleanupSubscription(subscription);\n  } else if (subscription._state === \"running\") {\n    subscription._state = \"ready\";\n  }\n}\n\nfunction onNotify(subscription, type, value) {\n  if (subscription._state === \"closed\") {\n    return;\n  }\n\n  if (subscription._state === \"buffering\") {\n    subscription._queue = subscription._queue || [];\n\n    subscription._queue.push({\n      type,\n      value\n    });\n\n    return;\n  }\n\n  if (subscription._state !== \"ready\") {\n    subscription._state = \"buffering\";\n    subscription._queue = [{\n      type,\n      value\n    }];\n    enqueue(() => flushSubscription(subscription));\n    return;\n  }\n\n  notifySubscription(subscription, type, value);\n}\n\nexport class Subscription {\n  constructor(observer, subscriber) {\n    // ASSERT: observer is an object\n    // ASSERT: subscriber is callable\n    this._cleanup = undefined;\n    this._observer = observer;\n    this._queue = undefined;\n    this._state = \"initializing\";\n    const subscriptionObserver = new SubscriptionObserver(this);\n\n    try {\n      this._cleanup = subscriber.call(undefined, subscriptionObserver);\n    } catch (e) {\n      subscriptionObserver.error(e);\n    }\n\n    if (this._state === \"initializing\") {\n      this._state = \"ready\";\n    }\n  }\n\n  get closed() {\n    return this._state === \"closed\";\n  }\n\n  unsubscribe() {\n    if (this._state !== \"closed\") {\n      closeSubscription(this);\n      cleanupSubscription(this);\n    }\n  }\n\n}\nexport class SubscriptionObserver {\n  constructor(subscription) {\n    this._subscription = subscription;\n  }\n\n  get closed() {\n    return this._subscription._state === \"closed\";\n  }\n\n  next(value) {\n    onNotify(this._subscription, \"next\", value);\n  }\n\n  error(value) {\n    onNotify(this._subscription, \"error\", value);\n  }\n\n  complete() {\n    onNotify(this._subscription, \"complete\");\n  }\n\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\n\nexport class Observable {\n  constructor(subscriber) {\n    if (!(this instanceof Observable)) {\n      throw new TypeError(\"Observable cannot be called as a function\");\n    }\n\n    if (typeof subscriber !== \"function\") {\n      throw new TypeError(\"Observable initializer must be a function\");\n    }\n\n    this._subscriber = subscriber;\n  }\n\n  subscribe(nextOrObserver, onError, onComplete) {\n    if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n      nextOrObserver = {\n        next: nextOrObserver,\n        error: onError,\n        complete: onComplete\n      };\n    }\n\n    return new Subscription(nextOrObserver, this._subscriber);\n  }\n\n  pipe(first) {\n    // tslint:disable-next-line no-this-assignment\n    let intermediate = this;\n\n    for (var _len = arguments.length, mappers = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      mappers[_key - 1] = arguments[_key];\n    }\n\n    for (const mapper of [first, ...mappers]) {\n      intermediate = mapper(intermediate);\n    }\n\n    return intermediate;\n  }\n\n  tap(nextOrObserver, onError, onComplete) {\n    const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null ? {\n      next: nextOrObserver,\n      error: onError,\n      complete: onComplete\n    } : nextOrObserver;\n    return new Observable(observer => {\n      return this.subscribe({\n        next(value) {\n          tapObserver.next && tapObserver.next(value);\n          observer.next(value);\n        },\n\n        error(error) {\n          tapObserver.error && tapObserver.error(error);\n          observer.error(error);\n        },\n\n        complete() {\n          tapObserver.complete && tapObserver.complete();\n          observer.complete();\n        },\n\n        start(subscription) {\n          tapObserver.start && tapObserver.start(subscription);\n        }\n\n      });\n    });\n  }\n\n  forEach(fn) {\n    return new Promise((resolve, reject) => {\n      if (typeof fn !== \"function\") {\n        reject(new TypeError(fn + \" is not a function\"));\n        return;\n      }\n\n      function done() {\n        subscription.unsubscribe();\n        resolve(undefined);\n      }\n\n      const subscription = this.subscribe({\n        next(value) {\n          try {\n            fn(value, done);\n          } catch (e) {\n            reject(e);\n            subscription.unsubscribe();\n          }\n        },\n\n        error(error) {\n          reject(error);\n        },\n\n        complete() {\n          resolve(undefined);\n        }\n\n      });\n    });\n  }\n\n  map(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        let propagatedValue = value;\n\n        try {\n          propagatedValue = fn(value);\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(propagatedValue);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  filter(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => this.subscribe({\n      next(value) {\n        try {\n          if (!fn(value)) return;\n        } catch (e) {\n          return observer.error(e);\n        }\n\n        observer.next(value);\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        observer.complete();\n      }\n\n    }));\n  }\n\n  reduce(fn, seed) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    const hasSeed = arguments.length > 1;\n    let hasValue = false;\n    let acc = seed;\n    return new C(observer => this.subscribe({\n      next(value) {\n        const first = !hasValue;\n        hasValue = true;\n\n        if (!first || hasSeed) {\n          try {\n            acc = fn(acc, value);\n          } catch (e) {\n            return observer.error(e);\n          }\n        } else {\n          acc = value;\n        }\n      },\n\n      error(e) {\n        observer.error(e);\n      },\n\n      complete() {\n        if (!hasValue && !hasSeed) {\n          return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n        }\n\n        observer.next(acc);\n        observer.complete();\n      }\n\n    }));\n  }\n\n  concat() {\n    for (var _len2 = arguments.length, sources = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      sources[_key2] = arguments[_key2];\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => {\n      let subscription;\n      let index = 0;\n\n      function startNext(next) {\n        subscription = next.subscribe({\n          next(v) {\n            observer.next(v);\n          },\n\n          error(e) {\n            observer.error(e);\n          },\n\n          complete() {\n            if (index === sources.length) {\n              subscription = undefined;\n              observer.complete();\n            } else {\n              startNext(C.from(sources[index++]));\n            }\n          }\n\n        });\n      }\n\n      startNext(this);\n      return () => {\n        if (subscription) {\n          subscription.unsubscribe();\n          subscription = undefined;\n        }\n      };\n    });\n  }\n\n  flatMap(fn) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(fn + \" is not a function\");\n    }\n\n    const C = getSpecies(this);\n    return new C(observer => {\n      const subscriptions = [];\n      const outer = this.subscribe({\n        next(value) {\n          let normalizedValue;\n\n          if (fn) {\n            try {\n              normalizedValue = fn(value);\n            } catch (e) {\n              return observer.error(e);\n            }\n          } else {\n            normalizedValue = value;\n          }\n\n          const inner = C.from(normalizedValue).subscribe({\n            next(innerValue) {\n              observer.next(innerValue);\n            },\n\n            error(e) {\n              observer.error(e);\n            },\n\n            complete() {\n              const i = subscriptions.indexOf(inner);\n              if (i >= 0) subscriptions.splice(i, 1);\n              completeIfDone();\n            }\n\n          });\n          subscriptions.push(inner);\n        },\n\n        error(e) {\n          observer.error(e);\n        },\n\n        complete() {\n          completeIfDone();\n        }\n\n      });\n\n      function completeIfDone() {\n        if (outer.closed && subscriptions.length === 0) {\n          observer.complete();\n        }\n      }\n\n      return () => {\n        subscriptions.forEach(s => s.unsubscribe());\n        outer.unsubscribe();\n      };\n    });\n  }\n\n  [(Symbol.observable, SymbolObservable)]() {\n    return this;\n  }\n\n  static from(x) {\n    const C = typeof this === \"function\" ? this : Observable;\n\n    if (x == null) {\n      throw new TypeError(x + \" is not an object\");\n    }\n\n    const observableMethod = getMethod(x, SymbolObservable);\n\n    if (observableMethod) {\n      const observable = observableMethod.call(x);\n\n      if (Object(observable) !== observable) {\n        throw new TypeError(observable + \" is not an object\");\n      }\n\n      if (isObservable(observable) && observable.constructor === C) {\n        return observable;\n      }\n\n      return new C(observer => observable.subscribe(observer));\n    }\n\n    if (hasSymbol(\"iterator\")) {\n      const iteratorMethod = getMethod(x, SymbolIterator);\n\n      if (iteratorMethod) {\n        return new C(observer => {\n          enqueue(() => {\n            if (observer.closed) return;\n\n            for (const item of iteratorMethod.call(x)) {\n              observer.next(item);\n              if (observer.closed) return;\n            }\n\n            observer.complete();\n          });\n        });\n      }\n    }\n\n    if (Array.isArray(x)) {\n      return new C(observer => {\n        enqueue(() => {\n          if (observer.closed) return;\n\n          for (const item of x) {\n            observer.next(item);\n            if (observer.closed) return;\n          }\n\n          observer.complete();\n        });\n      });\n    }\n\n    throw new TypeError(x + \" is not observable\");\n  }\n\n  static of() {\n    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      items[_key3] = arguments[_key3];\n    }\n\n    const C = typeof this === \"function\" ? this : Observable;\n    return new C(observer => {\n      enqueue(() => {\n        if (observer.closed) return;\n\n        for (const item of items) {\n          observer.next(item);\n          if (observer.closed) return;\n        }\n\n        observer.complete();\n      });\n    });\n  }\n\n  static get [SymbolSpecies]() {\n    return this;\n  }\n\n}\n\nif (hasSymbols()) {\n  Object.defineProperty(Observable, Symbol(\"extensions\"), {\n    value: {\n      symbol: SymbolObservable,\n      hostReportError\n    },\n    configurable: true\n  });\n}\n\nexport default Observable;","map":{"version":3,"names":["getSymbol","hasSymbol","hasSymbols","SymbolIterator","SymbolObservable","SymbolSpecies","getMethod","obj","key","value","undefined","TypeError","getSpecies","ctor","constructor","Observable","isObservable","x","hostReportError","error","log","setTimeout","enqueue","fn","Promise","resolve","then","e","cleanupSubscription","subscription","cleanup","_cleanup","unsubscribe","call","closeSubscription","_observer","_queue","_state","flushSubscription","queue","item","notifySubscription","type","observer","m","onNotify","push","Subscription","subscriber","subscriptionObserver","SubscriptionObserver","closed","_subscription","next","complete","_subscriber","subscribe","nextOrObserver","onError","onComplete","pipe","first","intermediate","mappers","mapper","tap","tapObserver","start","forEach","reject","done","map","C","propagatedValue","filter","reduce","seed","hasSeed","arguments","length","hasValue","acc","concat","sources","index","startNext","v","from","flatMap","subscriptions","outer","normalizedValue","inner","innerValue","i","indexOf","splice","completeIfDone","s","Symbol","observable","observableMethod","Object","iteratorMethod","Array","isArray","of","items","defineProperty","symbol","configurable"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/observable-fns/dist.esm/observable.js"],"sourcesContent":["/**\n * Based on <https://raw.githubusercontent.com/zenparsing/zen-observable/master/src/Observable.js>\n * At commit: f63849a8c60af5d514efc8e9d6138d8273c49ad6\n */\nimport \"./symbols\";\nimport { getSymbol, hasSymbol, hasSymbols } from \"./_symbols\";\nconst SymbolIterator = getSymbol(\"iterator\");\nconst SymbolObservable = getSymbol(\"observable\");\nconst SymbolSpecies = getSymbol(\"species\");\n// === Abstract Operations ===\nfunction getMethod(obj, key) {\n    const value = obj[key];\n    if (value == null) {\n        return undefined;\n    }\n    if (typeof value !== \"function\") {\n        throw new TypeError(value + \" is not a function\");\n    }\n    return value;\n}\nfunction getSpecies(obj) {\n    let ctor = obj.constructor;\n    if (ctor !== undefined) {\n        ctor = ctor[SymbolSpecies];\n        if (ctor === null) {\n            ctor = undefined;\n        }\n    }\n    return ctor !== undefined ? ctor : Observable;\n}\nfunction isObservable(x) {\n    return x instanceof Observable; // SPEC: Brand check\n}\nfunction hostReportError(error) {\n    if (hostReportError.log) {\n        hostReportError.log(error);\n    }\n    else {\n        setTimeout(() => { throw error; }, 0);\n    }\n}\nfunction enqueue(fn) {\n    Promise.resolve().then(() => {\n        try {\n            fn();\n        }\n        catch (e) {\n            hostReportError(e);\n        }\n    });\n}\nfunction cleanupSubscription(subscription) {\n    const cleanup = subscription._cleanup;\n    if (cleanup === undefined) {\n        return;\n    }\n    subscription._cleanup = undefined;\n    if (!cleanup) {\n        return;\n    }\n    try {\n        if (typeof cleanup === \"function\") {\n            cleanup();\n        }\n        else {\n            const unsubscribe = getMethod(cleanup, \"unsubscribe\");\n            if (unsubscribe) {\n                unsubscribe.call(cleanup);\n            }\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n}\nfunction closeSubscription(subscription) {\n    subscription._observer = undefined;\n    subscription._queue = undefined;\n    subscription._state = \"closed\";\n}\nfunction flushSubscription(subscription) {\n    const queue = subscription._queue;\n    if (!queue) {\n        return;\n    }\n    subscription._queue = undefined;\n    subscription._state = \"ready\";\n    for (const item of queue) {\n        notifySubscription(subscription, item.type, item.value);\n        if (subscription._state === \"closed\") {\n            break;\n        }\n    }\n}\nfunction notifySubscription(subscription, type, value) {\n    subscription._state = \"running\";\n    const observer = subscription._observer;\n    try {\n        const m = observer ? getMethod(observer, type) : undefined;\n        switch (type) {\n            case \"next\":\n                if (m)\n                    m.call(observer, value);\n                break;\n            case \"error\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer, value);\n                else\n                    throw value;\n                break;\n            case \"complete\":\n                closeSubscription(subscription);\n                if (m)\n                    m.call(observer);\n                break;\n        }\n    }\n    catch (e) {\n        hostReportError(e);\n    }\n    if (subscription._state === \"closed\") {\n        cleanupSubscription(subscription);\n    }\n    else if (subscription._state === \"running\") {\n        subscription._state = \"ready\";\n    }\n}\nfunction onNotify(subscription, type, value) {\n    if (subscription._state === \"closed\") {\n        return;\n    }\n    if (subscription._state === \"buffering\") {\n        subscription._queue = subscription._queue || [];\n        subscription._queue.push({ type, value });\n        return;\n    }\n    if (subscription._state !== \"ready\") {\n        subscription._state = \"buffering\";\n        subscription._queue = [{ type, value }];\n        enqueue(() => flushSubscription(subscription));\n        return;\n    }\n    notifySubscription(subscription, type, value);\n}\nexport class Subscription {\n    constructor(observer, subscriber) {\n        // ASSERT: observer is an object\n        // ASSERT: subscriber is callable\n        this._cleanup = undefined;\n        this._observer = observer;\n        this._queue = undefined;\n        this._state = \"initializing\";\n        const subscriptionObserver = new SubscriptionObserver(this);\n        try {\n            this._cleanup = subscriber.call(undefined, subscriptionObserver);\n        }\n        catch (e) {\n            subscriptionObserver.error(e);\n        }\n        if (this._state === \"initializing\") {\n            this._state = \"ready\";\n        }\n    }\n    get closed() {\n        return this._state === \"closed\";\n    }\n    unsubscribe() {\n        if (this._state !== \"closed\") {\n            closeSubscription(this);\n            cleanupSubscription(this);\n        }\n    }\n}\nexport class SubscriptionObserver {\n    constructor(subscription) { this._subscription = subscription; }\n    get closed() { return this._subscription._state === \"closed\"; }\n    next(value) { onNotify(this._subscription, \"next\", value); }\n    error(value) { onNotify(this._subscription, \"error\", value); }\n    complete() { onNotify(this._subscription, \"complete\"); }\n}\n/**\n * The basic Observable class. This primitive is used to wrap asynchronous\n * data streams in a common standardized data type that is interoperable\n * between libraries and can be composed to represent more complex processes.\n */\nexport class Observable {\n    constructor(subscriber) {\n        if (!(this instanceof Observable)) {\n            throw new TypeError(\"Observable cannot be called as a function\");\n        }\n        if (typeof subscriber !== \"function\") {\n            throw new TypeError(\"Observable initializer must be a function\");\n        }\n        this._subscriber = subscriber;\n    }\n    subscribe(nextOrObserver, onError, onComplete) {\n        if (typeof nextOrObserver !== \"object\" || nextOrObserver === null) {\n            nextOrObserver = {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            };\n        }\n        return new Subscription(nextOrObserver, this._subscriber);\n    }\n    pipe(first, ...mappers) {\n        // tslint:disable-next-line no-this-assignment\n        let intermediate = this;\n        for (const mapper of [first, ...mappers]) {\n            intermediate = mapper(intermediate);\n        }\n        return intermediate;\n    }\n    tap(nextOrObserver, onError, onComplete) {\n        const tapObserver = typeof nextOrObserver !== \"object\" || nextOrObserver === null\n            ? {\n                next: nextOrObserver,\n                error: onError,\n                complete: onComplete\n            }\n            : nextOrObserver;\n        return new Observable(observer => {\n            return this.subscribe({\n                next(value) {\n                    tapObserver.next && tapObserver.next(value);\n                    observer.next(value);\n                },\n                error(error) {\n                    tapObserver.error && tapObserver.error(error);\n                    observer.error(error);\n                },\n                complete() {\n                    tapObserver.complete && tapObserver.complete();\n                    observer.complete();\n                },\n                start(subscription) {\n                    tapObserver.start && tapObserver.start(subscription);\n                }\n            });\n        });\n    }\n    forEach(fn) {\n        return new Promise((resolve, reject) => {\n            if (typeof fn !== \"function\") {\n                reject(new TypeError(fn + \" is not a function\"));\n                return;\n            }\n            function done() {\n                subscription.unsubscribe();\n                resolve(undefined);\n            }\n            const subscription = this.subscribe({\n                next(value) {\n                    try {\n                        fn(value, done);\n                    }\n                    catch (e) {\n                        reject(e);\n                        subscription.unsubscribe();\n                    }\n                },\n                error(error) {\n                    reject(error);\n                },\n                complete() {\n                    resolve(undefined);\n                }\n            });\n        });\n    }\n    map(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                let propagatedValue = value;\n                try {\n                    propagatedValue = fn(value);\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(propagatedValue);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    filter(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => this.subscribe({\n            next(value) {\n                try {\n                    if (!fn(value))\n                        return;\n                }\n                catch (e) {\n                    return observer.error(e);\n                }\n                observer.next(value);\n            },\n            error(e) { observer.error(e); },\n            complete() { observer.complete(); },\n        }));\n    }\n    reduce(fn, seed) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        const hasSeed = arguments.length > 1;\n        let hasValue = false;\n        let acc = seed;\n        return new C(observer => this.subscribe({\n            next(value) {\n                const first = !hasValue;\n                hasValue = true;\n                if (!first || hasSeed) {\n                    try {\n                        acc = fn(acc, value);\n                    }\n                    catch (e) {\n                        return observer.error(e);\n                    }\n                }\n                else {\n                    acc = value;\n                }\n            },\n            error(e) { observer.error(e); },\n            complete() {\n                if (!hasValue && !hasSeed) {\n                    return observer.error(new TypeError(\"Cannot reduce an empty sequence\"));\n                }\n                observer.next(acc);\n                observer.complete();\n            },\n        }));\n    }\n    concat(...sources) {\n        const C = getSpecies(this);\n        return new C(observer => {\n            let subscription;\n            let index = 0;\n            function startNext(next) {\n                subscription = next.subscribe({\n                    next(v) { observer.next(v); },\n                    error(e) { observer.error(e); },\n                    complete() {\n                        if (index === sources.length) {\n                            subscription = undefined;\n                            observer.complete();\n                        }\n                        else {\n                            startNext(C.from(sources[index++]));\n                        }\n                    },\n                });\n            }\n            startNext(this);\n            return () => {\n                if (subscription) {\n                    subscription.unsubscribe();\n                    subscription = undefined;\n                }\n            };\n        });\n    }\n    flatMap(fn) {\n        if (typeof fn !== \"function\") {\n            throw new TypeError(fn + \" is not a function\");\n        }\n        const C = getSpecies(this);\n        return new C(observer => {\n            const subscriptions = [];\n            const outer = this.subscribe({\n                next(value) {\n                    let normalizedValue;\n                    if (fn) {\n                        try {\n                            normalizedValue = fn(value);\n                        }\n                        catch (e) {\n                            return observer.error(e);\n                        }\n                    }\n                    else {\n                        normalizedValue = value;\n                    }\n                    const inner = C.from(normalizedValue).subscribe({\n                        next(innerValue) { observer.next(innerValue); },\n                        error(e) { observer.error(e); },\n                        complete() {\n                            const i = subscriptions.indexOf(inner);\n                            if (i >= 0)\n                                subscriptions.splice(i, 1);\n                            completeIfDone();\n                        },\n                    });\n                    subscriptions.push(inner);\n                },\n                error(e) { observer.error(e); },\n                complete() { completeIfDone(); },\n            });\n            function completeIfDone() {\n                if (outer.closed && subscriptions.length === 0) {\n                    observer.complete();\n                }\n            }\n            return () => {\n                subscriptions.forEach(s => s.unsubscribe());\n                outer.unsubscribe();\n            };\n        });\n    }\n    [(Symbol.observable, SymbolObservable)]() { return this; }\n    static from(x) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        if (x == null) {\n            throw new TypeError(x + \" is not an object\");\n        }\n        const observableMethod = getMethod(x, SymbolObservable);\n        if (observableMethod) {\n            const observable = observableMethod.call(x);\n            if (Object(observable) !== observable) {\n                throw new TypeError(observable + \" is not an object\");\n            }\n            if (isObservable(observable) && observable.constructor === C) {\n                return observable;\n            }\n            return new C(observer => observable.subscribe(observer));\n        }\n        if (hasSymbol(\"iterator\")) {\n            const iteratorMethod = getMethod(x, SymbolIterator);\n            if (iteratorMethod) {\n                return new C(observer => {\n                    enqueue(() => {\n                        if (observer.closed)\n                            return;\n                        for (const item of iteratorMethod.call(x)) {\n                            observer.next(item);\n                            if (observer.closed)\n                                return;\n                        }\n                        observer.complete();\n                    });\n                });\n            }\n        }\n        if (Array.isArray(x)) {\n            return new C(observer => {\n                enqueue(() => {\n                    if (observer.closed)\n                        return;\n                    for (const item of x) {\n                        observer.next(item);\n                        if (observer.closed)\n                            return;\n                    }\n                    observer.complete();\n                });\n            });\n        }\n        throw new TypeError(x + \" is not observable\");\n    }\n    static of(...items) {\n        const C = (typeof this === \"function\" ? this : Observable);\n        return new C(observer => {\n            enqueue(() => {\n                if (observer.closed)\n                    return;\n                for (const item of items) {\n                    observer.next(item);\n                    if (observer.closed)\n                        return;\n                }\n                observer.complete();\n            });\n        });\n    }\n    static get [SymbolSpecies]() { return this; }\n}\nif (hasSymbols()) {\n    Object.defineProperty(Observable, Symbol(\"extensions\"), {\n        value: {\n            symbol: SymbolObservable,\n            hostReportError,\n        },\n        configurable: true,\n    });\n}\nexport default Observable;\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}