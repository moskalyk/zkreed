{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n});\n\nconst errCode = require('err-code');\n\nconst errors = require('./errors');\n\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst merge = require('it-merge');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst first = require('it-first');\n\nconst drain = require('it-drain');\n\nconst filter = require('it-filter');\n\nconst {\n  setDelayedInterval,\n  clearDelayedInterval // @ts-ignore module with no types\n\n} = require('set-delayed-interval');\n\nconst {\n  DHTPeerRouting\n} = require('./dht/dht-peer-routing'); // @ts-expect-error setMaxListeners is missing from the types\n\n\nconst {\n  setMaxListeners\n} = require('events');\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n * @property {number} [timeout = 10e3] - How long to let each refresh run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor(libp2p) {\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    /** @type {PeerRoutingModule[]} */\n\n    this._routers = libp2p._modules.peerRouting || []; // If we have the dht, add it to the available peer routers\n\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(new DHTPeerRouting(libp2p._dht));\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this);\n  }\n  /**\n   * Start peer routing service.\n   */\n\n\n  start() {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return;\n    }\n\n    this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);\n  }\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n\n\n  async _findClosestPeersTask() {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id, {\n        timeout: this._refreshManagerOptions.timeout || 10e3\n      }));\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error(err);\n    }\n  }\n  /**\n   * Stop peer routing service.\n   */\n\n\n  stop() {\n    clearDelayedInterval(this._timeoutId);\n  }\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async findPeer(id, options) {\n    // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), errors.codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), errors.codes.ERR_FIND_SELF);\n    }\n\n    const output = await pipe(merge(...this._routers.map(router => async function* () {\n      try {\n        yield await router.findPeer(id, options);\n      } catch (err) {\n        log.error(err);\n      }\n    }())), source => filter(source, Boolean), source => storeAddresses(source, this._peerStore), source => first(source));\n\n    if (output) {\n      return output;\n    }\n\n    throw errCode(new Error(errors.messages.NOT_FOUND), errors.codes.ERR_NOT_FOUND);\n  }\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take\n   * @param {AbortSignal} [options.signal] - An AbortSignal to abort the request\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n\n\n  async *getClosestPeers(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      timeout: 30e3\n    };\n\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), errors.codes.ERR_NO_ROUTERS_AVAILABLE);\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout); // this controller will potentially be used while dialing lots of\n      // peers so prevent MaxListenersExceededWarning appearing in the console\n\n      try {\n        // fails on node < 15.4\n        setMaxListeners && setMaxListeners(Infinity, controller.signal);\n      } catch {}\n\n      options.signal = controller.signal;\n    }\n\n    yield* pipe(merge(...this._routers.map(router => router.getClosestPeers(key, options))), source => storeAddresses(source, this._peerStore), source => uniquePeers(source), source => requirePeers(source));\n  }\n\n}\n\nmodule.exports = PeerRouting;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","errors","storeAddresses","uniquePeers","requirePeers","TimeoutController","merge","pipe","first","drain","filter","setDelayedInterval","clearDelayedInterval","DHTPeerRouting","setMaxListeners","PeerRouting","constructor","libp2p","_peerId","peerId","_peerStore","peerStore","_routers","_modules","peerRouting","_dht","_config","dht","enabled","push","_refreshManagerOptions","_options","refreshManager","_findClosestPeersTask","bind","start","length","_timeoutId","interval","bootDelay","getClosestPeers","id","timeout","err","stop","findPeer","options","Error","codes","ERR_NO_ROUTERS_AVAILABLE","toB58String","ERR_FIND_SELF","output","map","router","source","Boolean","messages","NOT_FOUND","ERR_NOT_FOUND","key","controller","Infinity","signal","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/peer-routing.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:peer-routing'), {\n  error: debug('libp2p:peer-routing:err')\n})\nconst errCode = require('err-code')\nconst errors = require('./errors')\nconst {\n  storeAddresses,\n  uniquePeers,\n  requirePeers\n} = require('./content-routing/utils')\nconst { TimeoutController } = require('timeout-abort-controller')\n\nconst merge = require('it-merge')\nconst { pipe } = require('it-pipe')\nconst first = require('it-first')\nconst drain = require('it-drain')\nconst filter = require('it-filter')\nconst {\n  setDelayedInterval,\n  clearDelayedInterval\n// @ts-ignore module with no types\n} = require('set-delayed-interval')\nconst { DHTPeerRouting } = require('./dht/dht-peer-routing')\n// @ts-expect-error setMaxListeners is missing from the types\nconst { setMaxListeners } = require('events')\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n */\n\n/**\n * @typedef {Object} RefreshManagerOptions\n * @property {boolean} [enabled = true] - Whether to enable the Refresh manager\n * @property {number} [bootDelay = 6e5] - Boot delay to start the Refresh Manager (in ms)\n * @property {number} [interval = 10e3] - Interval between each Refresh Manager run (in ms)\n * @property {number} [timeout = 10e3] - How long to let each refresh run (in ms)\n *\n * @typedef {Object} PeerRoutingOptions\n * @property {RefreshManagerOptions} [refreshManager]\n */\n\nclass PeerRouting {\n  /**\n   * @class\n   * @param {import('./')} libp2p\n   */\n  constructor (libp2p) {\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    /** @type {PeerRoutingModule[]} */\n    this._routers = libp2p._modules.peerRouting || []\n\n    // If we have the dht, add it to the available peer routers\n    if (libp2p._dht && libp2p._config.dht.enabled) {\n      this._routers.push(new DHTPeerRouting(libp2p._dht))\n    }\n\n    this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager\n\n    this._findClosestPeersTask = this._findClosestPeersTask.bind(this)\n  }\n\n  /**\n   * Start peer routing service.\n   */\n  start () {\n    if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {\n      return\n    }\n\n    this._timeoutId = setDelayedInterval(\n      this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay\n    )\n  }\n\n  /**\n   * Recurrent task to find closest peers and add their addresses to the Address Book.\n   */\n  async _findClosestPeersTask () {\n    try {\n      // nb getClosestPeers adds the addresses to the address book\n      await drain(this.getClosestPeers(this._peerId.id, { timeout: this._refreshManagerOptions.timeout || 10e3 }))\n    } catch (/** @type {any} */ err) {\n      log.error(err)\n    }\n  }\n\n  /**\n   * Stop peer routing service.\n   */\n  stop () {\n    clearDelayedInterval(this._timeoutId)\n  }\n\n  /**\n   * Iterates over all peer routers in parallel to find the given peer.\n   *\n   * @param {PeerId} id - The id of the peer to find\n   * @param {object} [options]\n   * @param {number} [options.timeout] - How long the query should run\n   * @returns {Promise<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async findPeer (id, options) { // eslint-disable-line require-await\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), errors.codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (id.toB58String() === this._peerId.toB58String()) {\n      throw errCode(new Error('Should not try to find self'), errors.codes.ERR_FIND_SELF)\n    }\n\n    const output = await pipe(\n      merge(\n        ...this._routers.map(router => (async function * () {\n          try {\n            yield await router.findPeer(id, options)\n          } catch (err) {\n            log.error(err)\n          }\n        })())\n      ),\n      (source) => filter(source, Boolean),\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => first(source)\n    )\n\n    if (output) {\n      return output\n    }\n\n    throw errCode(new Error(errors.messages.NOT_FOUND), errors.codes.ERR_NOT_FOUND)\n  }\n\n  /**\n   * Attempt to find the closest peers on the network to the given key.\n   *\n   * @param {Uint8Array} key - A CID like key\n   * @param {Object} [options]\n   * @param {number} [options.timeout=30e3] - How long the query can take\n   * @param {AbortSignal} [options.signal] - An AbortSignal to abort the request\n   * @returns {AsyncIterable<{ id: PeerId, multiaddrs: Multiaddr[] }>}\n   */\n  async * getClosestPeers (key, options = { timeout: 30e3 }) {\n    if (!this._routers.length) {\n      throw errCode(new Error('No peer routers available'), errors.codes.ERR_NO_ROUTERS_AVAILABLE)\n    }\n\n    if (options.timeout) {\n      const controller = new TimeoutController(options.timeout)\n      // this controller will potentially be used while dialing lots of\n      // peers so prevent MaxListenersExceededWarning appearing in the console\n      try {\n        // fails on node < 15.4\n        setMaxListeners && setMaxListeners(Infinity, controller.signal)\n      } catch {}\n\n      options.signal = controller.signal\n    }\n\n    yield * pipe(\n      merge(\n        ...this._routers.map(router => router.getClosestPeers(key, options))\n      ),\n      (source) => storeAddresses(source, this._peerStore),\n      (source) => uniquePeers(source),\n      (source) => requirePeers(source)\n    )\n  }\n}\n\nmodule.exports = PeerRouting\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}