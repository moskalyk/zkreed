{"ast":null,"code":"import Observable from \"./observable\"; // TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\n\nclass MulticastSubject extends Observable {\n  constructor() {\n    super(observer => {\n      this._observers.add(observer);\n\n      return () => this._observers.delete(observer);\n    });\n    this._observers = new Set();\n  }\n\n  next(value) {\n    for (const observer of this._observers) {\n      observer.next(value);\n    }\n  }\n\n  error(error) {\n    for (const observer of this._observers) {\n      observer.error(error);\n    }\n  }\n\n  complete() {\n    for (const observer of this._observers) {\n      observer.complete();\n    }\n  }\n\n}\n\nexport default MulticastSubject;","map":{"version":3,"names":["Observable","MulticastSubject","constructor","observer","_observers","add","delete","Set","next","value","error","complete"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/observable-fns/dist.esm/subject.js"],"sourcesContent":["import Observable from \"./observable\";\n// TODO: This observer iteration approach looks inelegant and expensive\n// Idea: Come up with super class for Subscription that contains the\n//       notify*, ... methods and use it here\n/**\n * A subject is a \"hot\" observable (see `multicast`) that has its observer\n * methods (`.next(value)`, `.error(error)`, `.complete()`) exposed.\n *\n * Be careful, though! With great power comes great responsibility. Only use\n * the `Subject` when you really need to trigger updates \"from the outside\" and\n * try to keep the code that can access it to a minimum. Return\n * `Observable.from(mySubject)` to not allow other code to mutate.\n */\nclass MulticastSubject extends Observable {\n    constructor() {\n        super(observer => {\n            this._observers.add(observer);\n            return () => this._observers.delete(observer);\n        });\n        this._observers = new Set();\n    }\n    next(value) {\n        for (const observer of this._observers) {\n            observer.next(value);\n        }\n    }\n    error(error) {\n        for (const observer of this._observers) {\n            observer.error(error);\n        }\n    }\n    complete() {\n        for (const observer of this._observers) {\n            observer.complete();\n        }\n    }\n}\nexport default MulticastSubject;\n"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,cAAvB,C,CACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,gBAAN,SAA+BD,UAA/B,CAA0C;EACtCE,WAAW,GAAG;IACV,MAAMC,QAAQ,IAAI;MACd,KAAKC,UAAL,CAAgBC,GAAhB,CAAoBF,QAApB;;MACA,OAAO,MAAM,KAAKC,UAAL,CAAgBE,MAAhB,CAAuBH,QAAvB,CAAb;IACH,CAHD;IAIA,KAAKC,UAAL,GAAkB,IAAIG,GAAJ,EAAlB;EACH;;EACDC,IAAI,CAACC,KAAD,EAAQ;IACR,KAAK,MAAMN,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;MACpCD,QAAQ,CAACK,IAAT,CAAcC,KAAd;IACH;EACJ;;EACDC,KAAK,CAACA,KAAD,EAAQ;IACT,KAAK,MAAMP,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;MACpCD,QAAQ,CAACO,KAAT,CAAeA,KAAf;IACH;EACJ;;EACDC,QAAQ,GAAG;IACP,KAAK,MAAMR,QAAX,IAAuB,KAAKC,UAA5B,EAAwC;MACpCD,QAAQ,CAACQ,QAAT;IACH;EACJ;;AAtBqC;;AAwB1C,eAAeV,gBAAf"},"metadata":{},"sourceType":"module"}