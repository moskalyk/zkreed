{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n});\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst LatencyMonitor = require('./latency-monitor'); // @ts-ignore retimer does not have types\n\n\nconst retimer = require('retimer');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst trackedMap = require('../metrics/tracked-map');\n\nconst PeerId = require('peer-id');\n\nconst {\n  codes: {\n    ERR_INVALID_PARAMETERS\n  }\n} = require('../errors');\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\nconst METRICS_COMPONENT = 'connection-manager';\nconst METRICS_PEER_CONNECTIONS = 'peer-connections';\nconst METRICS_PEER_VALUES = 'peer-values';\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\n\nclass ConnectionManager extends EventEmitter {\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  constructor(libp2p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    log('options: %j', this._options);\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n\n    this._peerValues = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PEER_VALUES,\n      metrics: this._libp2p.metrics\n    });\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n\n    this.connections = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PEER_CONNECTIONS,\n      metrics: this._libp2p.metrics\n    });\n    this._started = false;\n    this._timer = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    }); // This emitter gets listened to a lot\n\n    this.setMaxListeners(Infinity);\n  }\n  /**\n   * Get current number of open connections.\n   */\n\n\n  get size() {\n    return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  start() {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n    } // latency monitor\n\n\n    this._latencyMonitor.start();\n\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n    this._started = true;\n    log('started');\n  }\n  /**\n   * Stops the Connection Manager\n   *\n   * @async\n   */\n\n\n  async stop() {\n    this._timer && this._timer.clear();\n\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n\n    this._latencyMonitor.stop();\n\n    this._started = false;\n    await this._close();\n    log('stopped');\n  }\n  /**\n   * Cleans up the connections\n   *\n   * @async\n   */\n\n\n  async _close() {\n    // Close all connections we're tracking\n    const tasks = [];\n\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close());\n      }\n    }\n\n    await Promise.all(tasks);\n    this.connections.clear();\n  }\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   *\n   * @param {PeerId} peerId\n   * @param {number} value - A number between 0 and 1\n   * @returns {void}\n   */\n\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    this._peerValues.set(peerId.toB58String(), value);\n  }\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n\n\n  async _checkMetrics() {\n    if (this._libp2p.metrics) {\n      try {\n        const movingAverages = this._libp2p.metrics.global.movingAverages; // @ts-ignore moving averages object types\n\n        const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n        await this._checkMaxLimit('maxReceivedData', received); // @ts-ignore moving averages object types\n\n        const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n        await this._checkMaxLimit('maxSentData', sent);\n        const total = received + sent;\n        await this._checkMaxLimit('maxData', total);\n        log('metrics update', total);\n      } finally {\n        this._timer = retimer(this._checkMetrics, this._options.pollInterval);\n      }\n    }\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   *\n   * @param {Connection} connection\n   */\n\n\n  async onConnect(connection) {\n    if (!this._started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close();\n      return;\n    }\n\n    const peerId = connection.remotePeer;\n    const peerIdStr = peerId.toB58String();\n    const storedConn = this.connections.get(peerIdStr);\n    this.emit('peer:connect', connection);\n\n    if (storedConn) {\n      storedConn.push(connection);\n    } else {\n      this.connections.set(peerIdStr, [connection]);\n    }\n\n    await this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue);\n    }\n\n    await this._checkMaxLimit('maxConnections', this.size);\n  }\n  /**\n   * Removes the connection from tracking\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n\n\n  onDisconnect(connection) {\n    if (!this._started) {\n      // This can happen when we are in the process of shutting down the node\n      return;\n    }\n\n    const peerId = connection.remotePeer.toB58String();\n    let storedConn = this.connections.get(peerId);\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(peerId, storedConn);\n    } else if (storedConn) {\n      this.connections.delete(peerId);\n\n      this._peerValues.delete(connection.remotePeer.toB58String());\n\n      this.emit('peer:disconnect', connection);\n      this._libp2p.metrics && this._libp2p.metrics.onPeerDisconnected(connection.remotePeer);\n    }\n  }\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection|null}\n   */\n\n\n  get(peerId) {\n    const connections = this.getAll(peerId);\n\n    if (connections.length) {\n      return connections[0];\n    }\n\n    return null;\n  }\n  /**\n   * Get all open connections with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection[]}\n   */\n\n\n  getAll(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerId.toB58String();\n    const connections = this.connections.get(id); // Return all open connections\n\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open');\n    }\n\n    return [];\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   *\n   * @private\n   * @param {*} summary - The LatencyMonitor summary\n   */\n\n\n  _onLatencyMeasure(summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   *\n   * @private\n   * @param {string} name - The name of the field to check limits for\n   * @param {number} value - The current value of the field\n   */\n\n\n  async _checkMaxLimit(name, value) {\n    const limit = this._options[name];\n    log('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value);\n      await this._maybeDisconnectOne();\n    }\n  }\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   *\n   * @private\n   */\n\n\n  async _maybeDisconnectOne() {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])));\n      log('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        log('%s: lowest value peer is %s', this._peerId, peerId);\n        log('%s: closing a connection to %j', this._peerId, peerId);\n\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close().catch(err => {\n              log.error(err);\n            }); // TODO: should not need to invoke this manually\n\n            this.onDisconnect(connections[0]);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errcode","mergeOptions","LatencyMonitor","retimer","EventEmitter","trackedMap","PeerId","codes","ERR_INVALID_PARAMETERS","defaultOptions","maxConnections","Infinity","minConnections","maxData","maxSentData","maxReceivedData","maxEventLoopDelay","pollInterval","autoDialInterval","movingAverageInterval","defaultPeerValue","METRICS_COMPONENT","METRICS_PEER_CONNECTIONS","METRICS_PEER_VALUES","ConnectionManager","constructor","libp2p","options","_libp2p","_peerId","peerId","toB58String","_options","call","ignoreUndefined","Error","_peerValues","component","metric","metrics","connections","_started","_timer","_checkMetrics","bind","_latencyMonitor","latencyCheckIntervalMs","dataEmitIntervalMs","setMaxListeners","size","Array","from","values","reduce","accumulator","value","length","start","_onLatencyMeasure","on","stop","clear","removeListener","_close","tasks","connectionList","connection","push","close","Promise","all","setPeerValue","set","movingAverages","global","received","dataReceived","movingAverage","_checkMaxLimit","sent","dataSent","total","onConnect","remotePeer","peerIdStr","storedConn","get","emit","peerStore","keyBook","pubKey","has","onDisconnect","filter","conn","id","delete","onPeerDisconnected","getAll","isPeerId","stat","status","summary","avgMs","catch","err","name","limit","_maybeDisconnectOne","peerValues","Map","entries","sort","a","b","disconnectPeer","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/connection-manager/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:connection-manager'), {\n  error: debug('libp2p:connection-manager:err')\n})\n\nconst errcode = require('err-code')\nconst mergeOptions = require('merge-options')\nconst LatencyMonitor = require('./latency-monitor')\n// @ts-ignore retimer does not have types\nconst retimer = require('retimer')\n\nconst { EventEmitter } = require('events')\nconst trackedMap = require('../metrics/tracked-map')\nconst PeerId = require('peer-id')\n\nconst {\n  codes: { ERR_INVALID_PARAMETERS }\n} = require('../errors')\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  autoDialInterval: 10000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n}\n\nconst METRICS_COMPONENT = 'connection-manager'\nconst METRICS_PEER_CONNECTIONS = 'peer-connections'\nconst METRICS_PEER_VALUES = 'peer-values'\n\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n */\n\n/**\n * @typedef {Object} ConnectionManagerOptions\n * @property {number} [maxConnections = Infinity] - The maximum number of connections allowed.\n * @property {number} [minConnections = 0] - The minimum number of connections to avoid pruning.\n * @property {number} [maxData = Infinity] - The max data (in and out), per average interval to allow.\n * @property {number} [maxSentData = Infinity] - The max outgoing data, per average interval to allow.\n * @property {number} [maxReceivedData = Infinity] - The max incoming data, per average interval to allow.\n * @property {number} [maxEventLoopDelay = Infinity] - The upper limit the event loop can take to run.\n * @property {number} [pollInterval = 2000] - How often, in milliseconds, metrics and latency should be checked.\n * @property {number} [movingAverageInterval = 60000] - How often, in milliseconds, to compute averages.\n * @property {number} [defaultPeerValue = 1] - The value of the peer.\n * @property {boolean} [autoDial = true] - Should preemptively guarantee connections are above the low watermark.\n * @property {number} [autoDialInterval = 10000] - How often, in milliseconds, it should preemptively guarantee connections are above the low watermark.\n */\n\n/**\n *\n * @fires ConnectionManager#peer:connect Emitted when a new peer is connected.\n * @fires ConnectionManager#peer:disconnect Emitted when a peer is disconnected.\n */\nclass ConnectionManager extends EventEmitter {\n  /**\n   * Responsible for managing known connections.\n   *\n   * @class\n   * @param {Libp2p} libp2p\n   * @param {ConnectionManagerOptions} options\n   */\n  constructor (libp2p, options = {}) {\n    super()\n\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId.toB58String()\n\n    this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options)\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS)\n    }\n\n    log('options: %j', this._options)\n\n    /**\n     * Map of peer identifiers to their peer value for pruning connections.\n     *\n     * @type {Map<string, number>}\n     */\n    this._peerValues = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PEER_VALUES,\n      metrics: this._libp2p.metrics\n    })\n\n    /**\n     * Map of connections per peer\n     *\n     * @type {Map<string, Connection[]>}\n     */\n    this.connections = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PEER_CONNECTIONS,\n      metrics: this._libp2p.metrics\n    })\n\n    this._started = false\n    this._timer = null\n    this._checkMetrics = this._checkMetrics.bind(this)\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    })\n\n    // This emitter gets listened to a lot\n    this.setMaxListeners(Infinity)\n  }\n\n  /**\n   * Get current number of open connections.\n   */\n  get size () {\n    return Array.from(this.connections.values())\n      .reduce((accumulator, value) => accumulator + value.length, 0)\n  }\n\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n  start () {\n    if (this._libp2p.metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval)\n    }\n\n    // latency monitor\n    this._latencyMonitor.start()\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this)\n    this._latencyMonitor.on('data', this._onLatencyMeasure)\n\n    this._started = true\n    log('started')\n  }\n\n  /**\n   * Stops the Connection Manager\n   *\n   * @async\n   */\n  async stop () {\n    this._timer && this._timer.clear()\n\n    this._latencyMonitor.removeListener('data', this._onLatencyMeasure)\n    this._latencyMonitor.stop()\n\n    this._started = false\n    await this._close()\n    log('stopped')\n  }\n\n  /**\n   * Cleans up the connections\n   *\n   * @async\n   */\n  async _close () {\n    // Close all connections we're tracking\n    const tasks = []\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close())\n      }\n    }\n\n    await Promise.all(tasks)\n    this.connections.clear()\n  }\n\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   *\n   * @param {PeerId} peerId\n   * @param {number} value - A number between 0 and 1\n   * @returns {void}\n   */\n  setPeerValue (peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1')\n    }\n    this._peerValues.set(peerId.toB58String(), value)\n  }\n\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   *\n   * @private\n   */\n  async _checkMetrics () {\n    if (this._libp2p.metrics) {\n      try {\n        const movingAverages = this._libp2p.metrics.global.movingAverages\n        // @ts-ignore moving averages object types\n        const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage()\n        await this._checkMaxLimit('maxReceivedData', received)\n        // @ts-ignore moving averages object types\n        const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage()\n        await this._checkMaxLimit('maxSentData', sent)\n        const total = received + sent\n        await this._checkMaxLimit('maxData', total)\n        log('metrics update', total)\n      } finally {\n        this._timer = retimer(this._checkMetrics, this._options.pollInterval)\n      }\n    }\n  }\n\n  /**\n   * Tracks the incoming connection and check the connection limit\n   *\n   * @param {Connection} connection\n   */\n  async onConnect (connection) {\n    if (!this._started) {\n      // This can happen when we are in the process of shutting down the node\n      await connection.close()\n      return\n    }\n\n    const peerId = connection.remotePeer\n    const peerIdStr = peerId.toB58String()\n    const storedConn = this.connections.get(peerIdStr)\n\n    this.emit('peer:connect', connection)\n\n    if (storedConn) {\n      storedConn.push(connection)\n    } else {\n      this.connections.set(peerIdStr, [connection])\n    }\n\n    await this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey)\n\n    if (!this._peerValues.has(peerIdStr)) {\n      this._peerValues.set(peerIdStr, this._options.defaultPeerValue)\n    }\n\n    await this._checkMaxLimit('maxConnections', this.size)\n  }\n\n  /**\n   * Removes the connection from tracking\n   *\n   * @param {Connection} connection\n   * @returns {void}\n   */\n  onDisconnect (connection) {\n    if (!this._started) {\n      // This can happen when we are in the process of shutting down the node\n      return\n    }\n\n    const peerId = connection.remotePeer.toB58String()\n    let storedConn = this.connections.get(peerId)\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter((conn) => conn.id !== connection.id)\n      this.connections.set(peerId, storedConn)\n    } else if (storedConn) {\n      this.connections.delete(peerId)\n      this._peerValues.delete(connection.remotePeer.toB58String())\n      this.emit('peer:disconnect', connection)\n\n      this._libp2p.metrics && this._libp2p.metrics.onPeerDisconnected(connection.remotePeer)\n    }\n  }\n\n  /**\n   * Get a connection with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection|null}\n   */\n  get (peerId) {\n    const connections = this.getAll(peerId)\n    if (connections.length) {\n      return connections[0]\n    }\n    return null\n  }\n\n  /**\n   * Get all open connections with a peer.\n   *\n   * @param {PeerId} peerId\n   * @returns {Connection[]}\n   */\n  getAll (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('peerId must be an instance of peer-id'), ERR_INVALID_PARAMETERS)\n    }\n\n    const id = peerId.toB58String()\n    const connections = this.connections.get(id)\n\n    // Return all open connections\n    if (connections) {\n      return connections.filter(connection => connection.stat.status === 'open')\n    }\n    return []\n  }\n\n  /**\n   * If the event loop is slow, maybe close a connection\n   *\n   * @private\n   * @param {*} summary - The LatencyMonitor summary\n   */\n  _onLatencyMeasure (summary) {\n    this._checkMaxLimit('maxEventLoopDelay', summary.avgMs)\n      .catch(err => {\n        log.error(err)\n      })\n  }\n\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   *\n   * @private\n   * @param {string} name - The name of the field to check limits for\n   * @param {number} value - The current value of the field\n   */\n  async _checkMaxLimit (name, value) {\n    const limit = this._options[name]\n    log('checking limit of %s. current value: %d of %d', name, value, limit)\n    if (value > limit) {\n      log('%s: limit exceeded: %s, %d', this._peerId, name, value)\n      await this._maybeDisconnectOne()\n    }\n  }\n\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   *\n   * @private\n   */\n  async _maybeDisconnectOne () {\n    if (this._options.minConnections < this.connections.size) {\n      const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])))\n      log('%s: sorted peer values: %j', this._peerId, peerValues)\n      const disconnectPeer = peerValues[0]\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0]\n        log('%s: lowest value peer is %s', this._peerId, peerId)\n        log('%s: closing a connection to %j', this._peerId, peerId)\n        for (const connections of this.connections.values()) {\n          if (connections[0].remotePeer.toB58String() === peerId) {\n            connections[0].close().catch(err => {\n              log.error(err)\n            })\n            // TODO: should not need to invoke this manually\n            this.onDisconnect(connections[0])\n            break\n          }\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,2BAAD,CAAnB,EAAkD;EAC5DK,KAAK,EAAEL,KAAK,CAAC,+BAAD;AADgD,CAAlD,CAAZ;;AAIA,MAAMM,OAAO,GAAGL,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMM,YAAY,GAAGN,OAAO,CAAC,eAAD,CAA5B;;AACA,MAAMO,cAAc,GAAGP,OAAO,CAAC,mBAAD,CAA9B,C,CACA;;;AACA,MAAMQ,OAAO,GAAGR,OAAO,CAAC,SAAD,CAAvB;;AAEA,MAAM;EAAES;AAAF,IAAmBT,OAAO,CAAC,QAAD,CAAhC;;AACA,MAAMU,UAAU,GAAGV,OAAO,CAAC,wBAAD,CAA1B;;AACA,MAAMW,MAAM,GAAGX,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAM;EACJY,KAAK,EAAE;IAAEC;EAAF;AADH,IAEFb,OAAO,CAAC,WAAD,CAFX;;AAIA,MAAMc,cAAc,GAAG;EACrBC,cAAc,EAAEC,QADK;EAErBC,cAAc,EAAE,CAFK;EAGrBC,OAAO,EAAEF,QAHY;EAIrBG,WAAW,EAAEH,QAJQ;EAKrBI,eAAe,EAAEJ,QALI;EAMrBK,iBAAiB,EAAEL,QANE;EAOrBM,YAAY,EAAE,IAPO;EAQrBC,gBAAgB,EAAE,KARG;EASrBC,qBAAqB,EAAE,KATF;EAUrBC,gBAAgB,EAAE;AAVG,CAAvB;AAaA,MAAMC,iBAAiB,GAAG,oBAA1B;AACA,MAAMC,wBAAwB,GAAG,kBAAjC;AACA,MAAMC,mBAAmB,GAAG,aAA5B;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAN,SAAgCpB,YAAhC,CAA6C;EAC3C;AACF;AACA;AACA;AACA;AACA;AACA;EACEqB,WAAW,CAAEC,MAAF,EAAwB;IAAA,IAAdC,OAAc,uEAAJ,EAAI;IACjC;IAEA,KAAKC,OAAL,GAAeF,MAAf;IACA,KAAKG,OAAL,GAAeH,MAAM,CAACI,MAAP,CAAcC,WAAd,EAAf;IAEA,KAAKC,QAAL,GAAgB/B,YAAY,CAACgC,IAAb,CAAkB;MAAEC,eAAe,EAAE;IAAnB,CAAlB,EAA6CzB,cAA7C,EAA6DkB,OAA7D,CAAhB;;IACA,IAAI,KAAKK,QAAL,CAActB,cAAd,GAA+B,KAAKsB,QAAL,CAAcpB,cAAjD,EAAiE;MAC/D,MAAMZ,OAAO,CAAC,IAAImC,KAAJ,CAAU,uEAAV,CAAD,EAAqF3B,sBAArF,CAAb;IACD;;IAEDZ,GAAG,CAAC,aAAD,EAAgB,KAAKoC,QAArB,CAAH;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKI,WAAL,GAAmB/B,UAAU,CAAC;MAC5BgC,SAAS,EAAEhB,iBADiB;MAE5BiB,MAAM,EAAEf,mBAFoB;MAG5BgB,OAAO,EAAE,KAAKX,OAAL,CAAaW;IAHM,CAAD,CAA7B;IAMA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,WAAL,GAAmBnC,UAAU,CAAC;MAC5BgC,SAAS,EAAEhB,iBADiB;MAE5BiB,MAAM,EAAEhB,wBAFoB;MAG5BiB,OAAO,EAAE,KAAKX,OAAL,CAAaW;IAHM,CAAD,CAA7B;IAMA,KAAKE,QAAL,GAAgB,KAAhB;IACA,KAAKC,MAAL,GAAc,IAAd;IACA,KAAKC,aAAL,GAAqB,KAAKA,aAAL,CAAmBC,IAAnB,CAAwB,IAAxB,CAArB;IAEA,KAAKC,eAAL,GAAuB,IAAI3C,cAAJ,CAAmB;MACxC4C,sBAAsB,EAAE,KAAKd,QAAL,CAAcf,YADE;MAExC8B,kBAAkB,EAAE,KAAKf,QAAL,CAAcf;IAFM,CAAnB,CAAvB,CAvCiC,CA4CjC;;IACA,KAAK+B,eAAL,CAAqBrC,QAArB;EACD;EAED;AACF;AACA;;;EACU,IAAJsC,IAAI,GAAI;IACV,OAAOC,KAAK,CAACC,IAAN,CAAW,KAAKX,WAAL,CAAiBY,MAAjB,EAAX,EACJC,MADI,CACG,CAACC,WAAD,EAAcC,KAAd,KAAwBD,WAAW,GAAGC,KAAK,CAACC,MAD/C,EACuD,CADvD,CAAP;EAED;EAED;AACF;AACA;AACA;;;EACEC,KAAK,GAAI;IACP,IAAI,KAAK7B,OAAL,CAAaW,OAAjB,EAA0B;MACxB,KAAKG,MAAL,GAAc,KAAKA,MAAL,IAAevC,OAAO,CAAC,KAAKwC,aAAN,EAAqB,KAAKX,QAAL,CAAcf,YAAnC,CAApC;IACD,CAHM,CAKP;;;IACA,KAAK4B,eAAL,CAAqBY,KAArB;;IACA,KAAKC,iBAAL,GAAyB,KAAKA,iBAAL,CAAuBd,IAAvB,CAA4B,IAA5B,CAAzB;;IACA,KAAKC,eAAL,CAAqBc,EAArB,CAAwB,MAAxB,EAAgC,KAAKD,iBAArC;;IAEA,KAAKjB,QAAL,GAAgB,IAAhB;IACA7C,GAAG,CAAC,SAAD,CAAH;EACD;EAED;AACF;AACA;AACA;AACA;;;EACY,MAAJgE,IAAI,GAAI;IACZ,KAAKlB,MAAL,IAAe,KAAKA,MAAL,CAAYmB,KAAZ,EAAf;;IAEA,KAAKhB,eAAL,CAAqBiB,cAArB,CAAoC,MAApC,EAA4C,KAAKJ,iBAAjD;;IACA,KAAKb,eAAL,CAAqBe,IAArB;;IAEA,KAAKnB,QAAL,GAAgB,KAAhB;IACA,MAAM,KAAKsB,MAAL,EAAN;IACAnE,GAAG,CAAC,SAAD,CAAH;EACD;EAED;AACF;AACA;AACA;AACA;;;EACc,MAANmE,MAAM,GAAI;IACd;IACA,MAAMC,KAAK,GAAG,EAAd;;IACA,KAAK,MAAMC,cAAX,IAA6B,KAAKzB,WAAL,CAAiBY,MAAjB,EAA7B,EAAwD;MACtD,KAAK,MAAMc,UAAX,IAAyBD,cAAzB,EAAyC;QACvCD,KAAK,CAACG,IAAN,CAAWD,UAAU,CAACE,KAAX,EAAX;MACD;IACF;;IAED,MAAMC,OAAO,CAACC,GAAR,CAAYN,KAAZ,CAAN;IACA,KAAKxB,WAAL,CAAiBqB,KAAjB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEU,YAAY,CAAEzC,MAAF,EAAUyB,KAAV,EAAiB;IAC3B,IAAIA,KAAK,GAAG,CAAR,IAAaA,KAAK,GAAG,CAAzB,EAA4B;MAC1B,MAAM,IAAIpB,KAAJ,CAAU,0CAAV,CAAN;IACD;;IACD,KAAKC,WAAL,CAAiBoC,GAAjB,CAAqB1C,MAAM,CAACC,WAAP,EAArB,EAA2CwB,KAA3C;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACqB,MAAbZ,aAAa,GAAI;IACrB,IAAI,KAAKf,OAAL,CAAaW,OAAjB,EAA0B;MACxB,IAAI;QACF,MAAMkC,cAAc,GAAG,KAAK7C,OAAL,CAAaW,OAAb,CAAqBmC,MAArB,CAA4BD,cAAnD,CADE,CAEF;;QACA,MAAME,QAAQ,GAAGF,cAAc,CAACG,YAAf,CAA4B,KAAK5C,QAAL,CAAcb,qBAA1C,EAAiE0D,aAAjE,EAAjB;;QACA,MAAM,KAAKC,cAAL,CAAoB,iBAApB,EAAuCH,QAAvC,CAAN,CAJE,CAKF;;QACA,MAAMI,IAAI,GAAGN,cAAc,CAACO,QAAf,CAAwB,KAAKhD,QAAL,CAAcb,qBAAtC,EAA6D0D,aAA7D,EAAb;;QACA,MAAM,KAAKC,cAAL,CAAoB,aAApB,EAAmCC,IAAnC,CAAN;QACA,MAAME,KAAK,GAAGN,QAAQ,GAAGI,IAAzB;QACA,MAAM,KAAKD,cAAL,CAAoB,SAApB,EAA+BG,KAA/B,CAAN;QACArF,GAAG,CAAC,gBAAD,EAAmBqF,KAAnB,CAAH;MACD,CAXD,SAWU;QACR,KAAKvC,MAAL,GAAcvC,OAAO,CAAC,KAAKwC,aAAN,EAAqB,KAAKX,QAAL,CAAcf,YAAnC,CAArB;MACD;IACF;EACF;EAED;AACF;AACA;AACA;AACA;;;EACiB,MAATiE,SAAS,CAAEhB,UAAF,EAAc;IAC3B,IAAI,CAAC,KAAKzB,QAAV,EAAoB;MAClB;MACA,MAAMyB,UAAU,CAACE,KAAX,EAAN;MACA;IACD;;IAED,MAAMtC,MAAM,GAAGoC,UAAU,CAACiB,UAA1B;IACA,MAAMC,SAAS,GAAGtD,MAAM,CAACC,WAAP,EAAlB;IACA,MAAMsD,UAAU,GAAG,KAAK7C,WAAL,CAAiB8C,GAAjB,CAAqBF,SAArB,CAAnB;IAEA,KAAKG,IAAL,CAAU,cAAV,EAA0BrB,UAA1B;;IAEA,IAAImB,UAAJ,EAAgB;MACdA,UAAU,CAAClB,IAAX,CAAgBD,UAAhB;IACD,CAFD,MAEO;MACL,KAAK1B,WAAL,CAAiBgC,GAAjB,CAAqBY,SAArB,EAAgC,CAAClB,UAAD,CAAhC;IACD;;IAED,MAAM,KAAKtC,OAAL,CAAa4D,SAAb,CAAuBC,OAAvB,CAA+BjB,GAA/B,CAAmC1C,MAAnC,EAA2CA,MAAM,CAAC4D,MAAlD,CAAN;;IAEA,IAAI,CAAC,KAAKtD,WAAL,CAAiBuD,GAAjB,CAAqBP,SAArB,CAAL,EAAsC;MACpC,KAAKhD,WAAL,CAAiBoC,GAAjB,CAAqBY,SAArB,EAAgC,KAAKpD,QAAL,CAAcZ,gBAA9C;IACD;;IAED,MAAM,KAAK0D,cAAL,CAAoB,gBAApB,EAAsC,KAAK7B,IAA3C,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACE2C,YAAY,CAAE1B,UAAF,EAAc;IACxB,IAAI,CAAC,KAAKzB,QAAV,EAAoB;MAClB;MACA;IACD;;IAED,MAAMX,MAAM,GAAGoC,UAAU,CAACiB,UAAX,CAAsBpD,WAAtB,EAAf;IACA,IAAIsD,UAAU,GAAG,KAAK7C,WAAL,CAAiB8C,GAAjB,CAAqBxD,MAArB,CAAjB;;IAEA,IAAIuD,UAAU,IAAIA,UAAU,CAAC7B,MAAX,GAAoB,CAAtC,EAAyC;MACvC6B,UAAU,GAAGA,UAAU,CAACQ,MAAX,CAAmBC,IAAD,IAAUA,IAAI,CAACC,EAAL,KAAY7B,UAAU,CAAC6B,EAAnD,CAAb;MACA,KAAKvD,WAAL,CAAiBgC,GAAjB,CAAqB1C,MAArB,EAA6BuD,UAA7B;IACD,CAHD,MAGO,IAAIA,UAAJ,EAAgB;MACrB,KAAK7C,WAAL,CAAiBwD,MAAjB,CAAwBlE,MAAxB;;MACA,KAAKM,WAAL,CAAiB4D,MAAjB,CAAwB9B,UAAU,CAACiB,UAAX,CAAsBpD,WAAtB,EAAxB;;MACA,KAAKwD,IAAL,CAAU,iBAAV,EAA6BrB,UAA7B;MAEA,KAAKtC,OAAL,CAAaW,OAAb,IAAwB,KAAKX,OAAL,CAAaW,OAAb,CAAqB0D,kBAArB,CAAwC/B,UAAU,CAACiB,UAAnD,CAAxB;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEG,GAAG,CAAExD,MAAF,EAAU;IACX,MAAMU,WAAW,GAAG,KAAK0D,MAAL,CAAYpE,MAAZ,CAApB;;IACA,IAAIU,WAAW,CAACgB,MAAhB,EAAwB;MACtB,OAAOhB,WAAW,CAAC,CAAD,CAAlB;IACD;;IACD,OAAO,IAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACE0D,MAAM,CAAEpE,MAAF,EAAU;IACd,IAAI,CAACxB,MAAM,CAAC6F,QAAP,CAAgBrE,MAAhB,CAAL,EAA8B;MAC5B,MAAM9B,OAAO,CAAC,IAAImC,KAAJ,CAAU,uCAAV,CAAD,EAAqD3B,sBAArD,CAAb;IACD;;IAED,MAAMuF,EAAE,GAAGjE,MAAM,CAACC,WAAP,EAAX;IACA,MAAMS,WAAW,GAAG,KAAKA,WAAL,CAAiB8C,GAAjB,CAAqBS,EAArB,CAApB,CANc,CAQd;;IACA,IAAIvD,WAAJ,EAAiB;MACf,OAAOA,WAAW,CAACqD,MAAZ,CAAmB3B,UAAU,IAAIA,UAAU,CAACkC,IAAX,CAAgBC,MAAhB,KAA2B,MAA5D,CAAP;IACD;;IACD,OAAO,EAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACE3C,iBAAiB,CAAE4C,OAAF,EAAW;IAC1B,KAAKxB,cAAL,CAAoB,mBAApB,EAAyCwB,OAAO,CAACC,KAAjD,EACGC,KADH,CACSC,GAAG,IAAI;MACZ7G,GAAG,CAACG,KAAJ,CAAU0G,GAAV;IACD,CAHH;EAID;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACsB,MAAd3B,cAAc,CAAE4B,IAAF,EAAQnD,KAAR,EAAe;IACjC,MAAMoD,KAAK,GAAG,KAAK3E,QAAL,CAAc0E,IAAd,CAAd;IACA9G,GAAG,CAAC,+CAAD,EAAkD8G,IAAlD,EAAwDnD,KAAxD,EAA+DoD,KAA/D,CAAH;;IACA,IAAIpD,KAAK,GAAGoD,KAAZ,EAAmB;MACjB/G,GAAG,CAAC,4BAAD,EAA+B,KAAKiC,OAApC,EAA6C6E,IAA7C,EAAmDnD,KAAnD,CAAH;MACA,MAAM,KAAKqD,mBAAL,EAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EAC2B,MAAnBA,mBAAmB,GAAI;IAC3B,IAAI,KAAK5E,QAAL,CAAcpB,cAAd,GAA+B,KAAK4B,WAAL,CAAiBS,IAApD,EAA0D;MACxD,MAAM4D,UAAU,GAAG3D,KAAK,CAACC,IAAN,CAAW,IAAI2D,GAAJ,CAAQ,CAAC,GAAG,KAAK1E,WAAL,CAAiB2E,OAAjB,EAAJ,EAAgCC,IAAhC,CAAqC,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAvD,CAAR,CAAX,CAAnB;MACAtH,GAAG,CAAC,4BAAD,EAA+B,KAAKiC,OAApC,EAA6CgF,UAA7C,CAAH;MACA,MAAMM,cAAc,GAAGN,UAAU,CAAC,CAAD,CAAjC;;MACA,IAAIM,cAAJ,EAAoB;QAClB,MAAMrF,MAAM,GAAGqF,cAAc,CAAC,CAAD,CAA7B;QACAvH,GAAG,CAAC,6BAAD,EAAgC,KAAKiC,OAArC,EAA8CC,MAA9C,CAAH;QACAlC,GAAG,CAAC,gCAAD,EAAmC,KAAKiC,OAAxC,EAAiDC,MAAjD,CAAH;;QACA,KAAK,MAAMU,WAAX,IAA0B,KAAKA,WAAL,CAAiBY,MAAjB,EAA1B,EAAqD;UACnD,IAAIZ,WAAW,CAAC,CAAD,CAAX,CAAe2C,UAAf,CAA0BpD,WAA1B,OAA4CD,MAAhD,EAAwD;YACtDU,WAAW,CAAC,CAAD,CAAX,CAAe4B,KAAf,GAAuBoC,KAAvB,CAA6BC,GAAG,IAAI;cAClC7G,GAAG,CAACG,KAAJ,CAAU0G,GAAV;YACD,CAFD,EADsD,CAItD;;YACA,KAAKb,YAAL,CAAkBpD,WAAW,CAAC,CAAD,CAA7B;YACA;UACD;QACF;MACF;IACF;EACF;;AAnT0C;;AAsT7C4E,MAAM,CAACC,OAAP,GAAiB7F,iBAAjB"},"metadata":{},"sourceType":"script"}