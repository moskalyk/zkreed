{"ast":null,"code":"\"use strict\";\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerService = void 0;\n\nvar FluencePeer_1 = require(\"../../FluencePeer\");\n\nvar index_1 = require(\"../../../index\");\n\nvar services_1 = require(\"./services\");\n/**\n * Convenience function to support Aqua `service` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param args - raw arguments passed by user to the generated function\n * @param def - service definition generated by the Aqua compiler\n */\n\n\nfunction registerService(args, def) {\n  var e_1, _a;\n\n  var _b = extractArgs(args, def.defaultServiceId),\n      peer = _b.peer,\n      service = _b.service,\n      serviceId = _b.serviceId;\n\n  if (!peer.getStatus().isInitialized) {\n    throw new Error('Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?');\n  } // Checking for missing keys\n\n\n  var requiredKeys = def.functions.tag === 'nil' ? [] : Object.keys(def.functions.fields);\n  var incorrectServiceDefinitions = requiredKeys.filter(function (f) {\n    return !(f in service);\n  });\n\n  if (!!incorrectServiceDefinitions.length) {\n    throw new Error(\"Error registering service \".concat(serviceId, \": missing functions: \") + incorrectServiceDefinitions.map(function (d) {\n      return \"'\" + d + \"'\";\n    }).join(', '));\n  }\n\n  var singleFunctions = def.functions.tag === 'nil' ? [] : Object.entries(def.functions.fields);\n\n  try {\n    for (var singleFunctions_1 = __values(singleFunctions), singleFunctions_1_1 = singleFunctions_1.next(); !singleFunctions_1_1.done; singleFunctions_1_1 = singleFunctions_1.next()) {\n      var singleFunction = singleFunctions_1_1.value;\n\n      var _c = __read(singleFunction, 2),\n          name_1 = _c[0],\n          type = _c[1]; // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void\n      // Account for the fact that user service might be defined as a class - .bind(...)\n\n\n      var userDefinedHandler = service[name_1].bind(service);\n      var serviceDescription = (0, services_1.userHandlerService)(serviceId, singleFunction, userDefinedHandler);\n      (0, services_1.registerGlobalService)(peer, serviceDescription);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (singleFunctions_1_1 && !singleFunctions_1_1.done && (_a = singleFunctions_1.return)) _a.call(singleFunctions_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n\nexports.registerService = registerService;\n/**\n * Arguments could be passed in one these configurations:\n * [serviceObject]\n * [peer, serviceObject]\n * [defaultId, serviceObject]\n * [peer, defaultId, serviceObject]\n *\n * Where serviceObject is the raw object with function definitions passed by user\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, serviceId, service }\n */\n\nvar extractArgs = function (args, defaultServiceId) {\n  var peer;\n  var serviceId;\n  var service;\n\n  if (FluencePeer_1.FluencePeer.isInstance(args[0])) {\n    peer = args[0];\n  } else {\n    peer = index_1.Fluence.getPeer();\n  }\n\n  if (typeof args[0] === 'string') {\n    serviceId = args[0];\n  } else if (typeof args[1] === 'string') {\n    serviceId = args[1];\n  } else {\n    serviceId = defaultServiceId;\n  } // Figuring out which overload is the service.\n  // If the first argument is not Fluence Peer and it is an object, then it can only be the service def\n  // If the first argument is peer, we are checking further. The second argument might either be\n  // an object, that it must be the service object\n  // or a string, which is the service id. In that case the service is the third argument\n\n\n  if (!FluencePeer_1.FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {\n    service = args[0];\n  } else if (typeof args[1] === 'object') {\n    service = args[1];\n  } else {\n    service = args[2];\n  }\n\n  return {\n    peer: peer,\n    serviceId: serviceId,\n    service: service\n  };\n};","map":{"version":3,"mappings":"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","names":["registerService","args","def","extractArgs","defaultServiceId","peer","service","serviceId","getStatus","isInitialized","Error","requiredKeys","functions","tag","Object","keys","fields","incorrectServiceDefinitions","filter","f","length","map","d","join","singleFunctions","entries","singleFunctions_1_1","singleFunction","name_1","type","userDefinedHandler","bind","serviceDescription","exports","FluencePeer_1","isInstance","index_1","getPeer"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/compilerSupport/v3impl/registerService.ts"],"sourcesContent":["import { FluencePeer } from '../../FluencePeer';\nimport { Fluence } from '../../../index';\nimport { ServiceDef } from './interface';\nimport { registerGlobalService, userHandlerService } from './services';\n\n/**\n * Convenience function to support Aqua `service` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param args - raw arguments passed by user to the generated function\n * @param def - service definition generated by the Aqua compiler\n */\nexport function registerService(args: any[], def: ServiceDef) {\n    const { peer, service, serviceId } = extractArgs(args, def.defaultServiceId);\n\n    if (!peer.getStatus().isInitialized) {\n        throw new Error(\n            'Could not register the service because the peer is not initialized. Are you passing the wrong peer to the register function?',\n        );\n    }\n\n    // Checking for missing keys\n    const requiredKeys = def.functions.tag === 'nil' ? [] : Object.keys(def.functions.fields);\n    const incorrectServiceDefinitions = requiredKeys.filter((f) => !(f in service));\n    if (!!incorrectServiceDefinitions.length) {\n        throw new Error(\n            `Error registering service ${serviceId}: missing functions: ` +\n                incorrectServiceDefinitions.map((d) => \"'\" + d + \"'\").join(', '),\n        );\n    }\n\n    const singleFunctions = def.functions.tag === 'nil' ? [] : Object.entries(def.functions.fields);\n    for (let singleFunction of singleFunctions) {\n        let [name, type] = singleFunction;\n        // The function has type of (arg1, arg2, arg3, ... , callParams) => CallServiceResultType | void\n        // Account for the fact that user service might be defined as a class - .bind(...)\n        const userDefinedHandler = service[name].bind(service);\n\n        const serviceDescription = userHandlerService(serviceId, singleFunction, userDefinedHandler);\n        registerGlobalService(peer, serviceDescription);\n    }\n}\n\n/**\n * Arguments could be passed in one these configurations:\n * [serviceObject]\n * [peer, serviceObject]\n * [defaultId, serviceObject]\n * [peer, defaultId, serviceObject]\n *\n * Where serviceObject is the raw object with function definitions passed by user\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, serviceId, service }\n */\nconst extractArgs = (\n    args: any[],\n    defaultServiceId?: string,\n): { peer: FluencePeer; serviceId: string; service: any } => {\n    let peer: FluencePeer;\n    let serviceId: any;\n    let service: any;\n    if (FluencePeer.isInstance(args[0])) {\n        peer = args[0];\n    } else {\n        peer = Fluence.getPeer();\n    }\n\n    if (typeof args[0] === 'string') {\n        serviceId = args[0];\n    } else if (typeof args[1] === 'string') {\n        serviceId = args[1];\n    } else {\n        serviceId = defaultServiceId;\n    }\n\n    // Figuring out which overload is the service.\n    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def\n    // If the first argument is peer, we are checking further. The second argument might either be\n    // an object, that it must be the service object\n    // or a string, which is the service id. In that case the service is the third argument\n    if (!FluencePeer.isInstance(args[0]) && typeof args[0] === 'object') {\n        service = args[0];\n    } else if (typeof args[1] === 'object') {\n        service = args[1];\n    } else {\n        service = args[2];\n    }\n\n    return {\n        peer: peer,\n        serviceId: serviceId,\n        service: service,\n    };\n};\n"]},"metadata":{},"sourceType":"script"}