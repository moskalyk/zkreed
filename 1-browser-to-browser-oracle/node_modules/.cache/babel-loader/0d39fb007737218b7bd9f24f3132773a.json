{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2021 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FluencePeer = void 0;\n\nvar multiaddr_1 = require(\"multiaddr\");\n\nvar commonTypes_1 = require(\"./commonTypes\");\n\nvar FluenceConnection_1 = require(\"./FluenceConnection\");\n\nvar Particle_1 = require(\"./Particle\");\n\nvar KeyPair_1 = require(\"./KeyPair\");\n\nvar utils_1 = require(\"./utils\");\n\nvar rxjs_1 = require(\"rxjs\");\n\nvar loglevel_1 = __importDefault(require(\"loglevel\"));\n\nvar common_1 = require(\"./builtins/common\");\n\nvar Sig_1 = require(\"./builtins/Sig\");\n\nvar services_1 = require(\"./_aqua/services\");\n\nvar Buffer_1 = __importDefault(require(\"./Buffer\"));\n\nvar marine_js_1 = require(\"@fluencelabs/marine-js\");\n\nvar avm_1 = require(\"./avm\");\n\nvar browser_or_node_1 = require(\"browser-or-node\");\n\nvar DEFAULT_TTL = 7000;\n/**\n * This class implements the Fluence protocol for javascript-based environments.\n * It provides all the necessary features to communicate with Fluence network\n */\n\nvar FluencePeer =\n/** @class */\nfunction () {\n  function FluencePeer() {\n    // Queues for incoming and outgoing particles\n    this._incomingParticles = new rxjs_1.Subject();\n    this._outgoingParticles = new rxjs_1.Subject(); // Call service handler\n\n    this._marineServices = new Set();\n    this._particleSpecificHandlers = new Map();\n    this._commonHandlers = new Map(); // Internal peer state\n\n    this._printParticleId = false;\n    this._defaultTTL = DEFAULT_TTL;\n    this._relayPeerId = null;\n    this._timeouts = [];\n    this._particleQueues = new Map();\n  }\n  /**\n   * Checks whether the object is instance of FluencePeer class\n   * @param obj - object to check if it is FluencePeer\n   * @returns true if the object is FluencePeer false otherwise\n   */\n\n\n  FluencePeer.isInstance = function (obj) {\n    return obj instanceof FluencePeer;\n  };\n  /**\n   * Get the peer's status\n   */\n\n\n  FluencePeer.prototype.getStatus = function () {\n    // TODO:: use explicit mechanism for peer's state\n    if (this._keyPair === undefined) {\n      return {\n        isInitialized: false,\n        peerId: null,\n        isConnected: false,\n        relayPeerId: null\n      };\n    }\n\n    if (this._connection === undefined || this._relayPeerId === null) {\n      return {\n        isInitialized: true,\n        peerId: this._keyPair.Libp2pPeerId.toB58String(),\n        isConnected: false,\n        relayPeerId: null\n      };\n    }\n\n    return {\n      isInitialized: true,\n      peerId: this._keyPair.Libp2pPeerId.toB58String(),\n      isConnected: true,\n      relayPeerId: this._relayPeerId\n    };\n  };\n  /**\n   * Initializes the peer: starts the Aqua VM, initializes the default call service handlers\n   * and (optionally) connect to the Fluence network\n   * @param config - object specifying peer configuration\n   */\n\n\n  FluencePeer.prototype.start = function (config) {\n    var _a, _b, _c, _d, _e;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var keyPair, _f, peerId, marineDeps, _g, connectToMultiAddr, fromNode, _h;\n\n      var _this = this;\n\n      return __generator(this, function (_j) {\n        switch (_j.label) {\n          case 0:\n            (0, utils_1.throwIfNotSupported)();\n            if (!((_a = config === null || config === void 0 ? void 0 : config.KeyPair) !== null && _a !== void 0)) return [3\n            /*break*/\n            , 1];\n            _f = _a;\n            return [3\n            /*break*/\n            , 3];\n\n          case 1:\n            return [4\n            /*yield*/\n            , KeyPair_1.KeyPair.randomEd25519()];\n\n          case 2:\n            _f = _j.sent();\n            _j.label = 3;\n\n          case 3:\n            keyPair = _f;\n            this._keyPair = keyPair;\n            peerId = keyPair.Libp2pPeerId.toB58String();\n\n            if ((_b = config === null || config === void 0 ? void 0 : config.debug) === null || _b === void 0 ? void 0 : _b.printParticleId) {\n              this._printParticleId = true;\n            }\n\n            this._defaultTTL = (_c = config === null || config === void 0 ? void 0 : config.defaultTtlMs) !== null && _c !== void 0 ? _c : DEFAULT_TTL;\n\n            if ((_d = config === null || config === void 0 ? void 0 : config.debug) === null || _d === void 0 ? void 0 : _d.marineLogLevel) {\n              this._marineLogLevel = config.debug.marineLogLevel;\n            }\n\n            this._fluenceAppService = new marine_js_1.FluenceAppService((_e = config === null || config === void 0 ? void 0 : config.marineJS) === null || _e === void 0 ? void 0 : _e.workerScriptPath);\n            if (!(config === null || config === void 0 ? void 0 : config.marineJS)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , loadMarineAndAvm(config.marineJS.marineWasmPath, config.marineJS.avmWasmPath)];\n\n          case 4:\n            _g = _j.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            return [4\n            /*yield*/\n            , (0, marine_js_1.loadDefaults)()];\n\n          case 6:\n            _g = _j.sent();\n            _j.label = 7;\n\n          case 7:\n            marineDeps = _g;\n            return [4\n            /*yield*/\n            , this._fluenceAppService.init(marineDeps.marine)];\n\n          case 8:\n            _j.sent();\n\n            return [4\n            /*yield*/\n            , this._fluenceAppService.createService(marineDeps.avm, 'avm', undefined, (0, utils_1.marineLogLevelToEnvs)(this._marineLogLevel))];\n\n          case 9:\n            _j.sent();\n\n            this._avmRunner = (config === null || config === void 0 ? void 0 : config.avmRunner) || new avm_1.AVM(this._fluenceAppService);\n            return [4\n            /*yield*/\n            , this._avmRunner.init((config === null || config === void 0 ? void 0 : config.avmLogLevel) || 'off')];\n\n          case 10:\n            _j.sent();\n\n            if (!(config === null || config === void 0 ? void 0 : config.connectTo)) return [3\n            /*break*/\n            , 15];\n            connectToMultiAddr = void 0;\n            fromNode = config.connectTo.multiaddr;\n\n            if (fromNode) {\n              connectToMultiAddr = new multiaddr_1.Multiaddr(fromNode);\n            } else {\n              connectToMultiAddr = new multiaddr_1.Multiaddr(config.connectTo);\n            }\n\n            this._relayPeerId = connectToMultiAddr.getPeerId();\n            if (!this._connection) return [3\n            /*break*/\n            , 12];\n            return [4\n            /*yield*/\n            , this._connection.disconnect()];\n\n          case 11:\n            _j.sent();\n\n            _j.label = 12;\n\n          case 12:\n            _h = this;\n            return [4\n            /*yield*/\n            , FluenceConnection_1.FluenceConnection.createConnection({\n              peerId: this._keyPair.Libp2pPeerId,\n              relayAddress: connectToMultiAddr,\n              dialTimeoutMs: config.dialTimeoutMs,\n              onIncomingParticle: function (p) {\n                return _this._incomingParticles.next({\n                  particle: p,\n                  onStageChange: function () {}\n                });\n              }\n            })];\n\n          case 13:\n            _h._connection = _j.sent();\n            return [4\n            /*yield*/\n            , this._connect()];\n\n          case 14:\n            _j.sent();\n\n            _j.label = 15;\n\n          case 15:\n            registerDefaultServices(this);\n            this._classServices = {\n              sig: new Sig_1.Sig(this._keyPair)\n            };\n            this._classServices.sig.securityGuard = (0, Sig_1.defaultSigGuard)(peerId);\n            (0, services_1.registerSig)(this, this._classServices.sig);\n            (0, services_1.registerSig)(this, peerId, this._classServices.sig);\n\n            this._startParticleProcessing();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  FluencePeer.prototype.getServices = function () {\n    if (this._classServices === undefined) {\n      throw new Error(\"Can't get services: peer is not initialized\");\n    }\n\n    return __assign({}, this._classServices);\n  };\n  /**\n   * Registers marine service within the Fluence peer from wasm file.\n   * Following helper functions can be used to load wasm files:\n   * * loadWasmFromFileSystem\n   * * loadWasmFromNpmPackage\n   * * loadWasmFromServer\n   * @param wasm - buffer with the wasm file for service\n   * @param serviceId - the service id by which the service can be accessed in aqua\n   */\n\n\n  FluencePeer.prototype.registerMarineService = function (wasm, serviceId) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this._fluenceAppService) {\n              throw new Error(\"Can't register marine service: peer is not initialized\");\n            }\n\n            if (this._containsService(serviceId)) {\n              throw new Error(\"Service with '\".concat(serviceId, \"' id already exists\"));\n            }\n\n            return [4\n            /*yield*/\n            , this._fluenceAppService.createService(wasm, serviceId, undefined, (0, utils_1.marineLogLevelToEnvs)(this._marineLogLevel))];\n\n          case 1:\n            _a.sent();\n\n            this._marineServices.add(serviceId);\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Removes the specified marine service from the Fluence peer\n   * @param serviceId - the service id to remove\n   */\n\n\n  FluencePeer.prototype.removeMarineService = function (serviceId) {\n    this._marineServices.delete(serviceId);\n  };\n  /**\n   * Un-initializes the peer: stops all the underlying workflows, stops the Aqua VM\n   * and disconnects from the Fluence network\n   */\n\n\n  FluencePeer.prototype.stop = function () {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            this._keyPair = undefined; // This will set peer to non-initialized state and stop particle processing\n\n            this._relayPeerId = null;\n\n            this._stopParticleProcessing();\n\n            return [4\n            /*yield*/\n            , this._disconnect()];\n\n          case 1:\n            _c.sent();\n\n            return [4\n            /*yield*/\n            , (_a = this._avmRunner) === null || _a === void 0 ? void 0 : _a.terminate()];\n\n          case 2:\n            _c.sent();\n\n            return [4\n            /*yield*/\n            , (_b = this._fluenceAppService) === null || _b === void 0 ? void 0 : _b.terminate()];\n\n          case 3:\n            _c.sent();\n\n            this._avmRunner = undefined;\n            this._fluenceAppService = undefined;\n            this._classServices = undefined;\n\n            this._particleSpecificHandlers.clear();\n\n            this._commonHandlers.clear();\n\n            this._marineServices.clear();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(FluencePeer.prototype, \"internals\", {\n    // internal api\n\n    /**\n     * Is not intended to be used manually. Subject to change\n     */\n    get: function () {\n      var _this = this;\n\n      return {\n        createNewParticle: function (script, ttl) {\n          if (ttl === void 0) {\n            ttl = _this._defaultTTL;\n          }\n\n          var status = _this.getStatus();\n\n          if (!status.isInitialized) {\n            return new Error(\"Can't create new particle: peer is not initialized\");\n          }\n\n          return Particle_1.Particle.createNew(script, ttl, status.peerId);\n        },\n\n        /**\n         * Initiates a new particle execution starting from local peer\n         * @param particle - particle to start execution of\n         */\n        initiateParticle: function (particle, onStageChange) {\n          var status = _this.getStatus();\n\n          if (!status.isInitialized) {\n            throw new Error('Cannot initiate new particle: peer is not initialized');\n          }\n\n          if (_this._printParticleId) {\n            console.log('Particle id: ', particle.id);\n          }\n\n          if (particle.initPeerId === undefined) {\n            particle.initPeerId = status.peerId;\n          }\n\n          if (particle.ttl === undefined) {\n            particle.ttl = _this._defaultTTL;\n          }\n\n          _this._incomingParticles.next({\n            particle: particle,\n            onStageChange: onStageChange\n          });\n        },\n\n        /**\n         * Register Call Service handler functions\n         */\n        regHandler: {\n          /**\n           * Register handler for all particles\n           */\n          common: function ( // force new line\n          serviceId, fnName, handler) {\n            _this._commonHandlers.set(serviceFnKey(serviceId, fnName), handler);\n          },\n\n          /**\n           * Register handler which will be called only for particle with the specific id\n           */\n          forParticle: function (particleId, serviceId, fnName, handler) {\n            var psh = _this._particleSpecificHandlers.get(particleId);\n\n            if (psh === undefined) {\n              psh = new Map();\n\n              _this._particleSpecificHandlers.set(particleId, psh);\n            }\n\n            psh.set(serviceFnKey(serviceId, fnName), handler);\n          }\n        }\n      };\n    },\n    enumerable: false,\n    configurable: true\n  }); // private\n  // TODO:: make public when full connection\\disconnection cycle is implemented properly\n\n  FluencePeer.prototype._connect = function () {\n    var _a;\n\n    return ((_a = this._connection) === null || _a === void 0 ? void 0 : _a.connect()) || Promise.resolve();\n  }; // TODO:: make public when full connection\\disconnection cycle is implemented properly\n\n\n  FluencePeer.prototype._disconnect = function () {\n    var _a;\n\n    return ((_a = this._connection) === null || _a === void 0 ? void 0 : _a.disconnect()) || Promise.resolve();\n  };\n\n  FluencePeer.prototype._containsService = function (serviceId) {\n    return this._marineServices.has(serviceId) || this._commonHandlers.has(serviceId);\n  };\n\n  FluencePeer.prototype._startParticleProcessing = function () {\n    var _this = this;\n\n    this._incomingParticles.pipe((0, rxjs_1.tap)(function (x) {\n      x.particle.logTo('debug', 'particle received:');\n    }), filterExpiredParticles(this._expireParticle.bind(this))).subscribe(function (item) {\n      var p = item.particle;\n\n      var particlesQueue = _this._particleQueues.get(p.id);\n\n      if (!particlesQueue) {\n        particlesQueue = _this._createParticlesProcessingQueue();\n\n        _this._particleQueues.set(p.id, particlesQueue);\n\n        var timeout = setTimeout(function () {\n          _this._expireParticle(item);\n        }, p.actualTtl());\n\n        _this._timeouts.push(timeout);\n      }\n\n      particlesQueue.next(item);\n    });\n\n    this._outgoingParticles.subscribe(function (item) {\n      // Do not send particle after the peer has been stopped\n      if (!_this.getStatus().isInitialized) {\n        return;\n      }\n\n      if (!_this._connection) {\n        item.particle.logTo('error', 'cannot send particle, peer is not connected');\n        item.onStageChange({\n          stage: 'sendingError'\n        });\n        return;\n      }\n\n      _this._connection.sendParticle(item.particle).then(function () {\n        item.onStageChange({\n          stage: 'sent'\n        });\n      }, function (e) {\n        loglevel_1.default.error(e);\n      });\n    });\n  };\n\n  FluencePeer.prototype._expireParticle = function (item) {\n    var particleId = item.particle.id;\n    loglevel_1.default.debug(\"particle \".concat(particleId, \" has expired after \").concat(item.particle.ttl, \". Deleting particle-related queues and handlers\"));\n\n    this._particleQueues.delete(particleId);\n\n    this._particleSpecificHandlers.delete(particleId);\n\n    item.onStageChange({\n      stage: 'expired'\n    });\n  };\n\n  FluencePeer.prototype._createParticlesProcessingQueue = function () {\n    var _this = this;\n\n    var particlesQueue = new rxjs_1.Subject();\n    var prevData = Buffer_1.default.from([]);\n    particlesQueue.pipe(filterExpiredParticles(this._expireParticle.bind(this)), (0, rxjs_1.concatMap)(function (item) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var status, result, newData;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              status = this.getStatus();\n\n              if (!status.isInitialized || this._avmRunner === undefined) {\n                // If `.stop()` was called return null to stop particle processing immediately\n                return [2\n                /*return*/\n                , null];\n              }\n\n              return [4\n              /*yield*/\n              , runAvmRunner(status.peerId, this._avmRunner, item.particle, prevData)];\n\n            case 1:\n              result = _a.sent();\n              newData = Buffer_1.default.from(result.data);\n              prevData = newData;\n              return [2\n              /*return*/\n              , __assign(__assign({}, item), {\n                result: result,\n                newData: newData\n              })];\n          }\n        });\n      });\n    })).subscribe(function (item) {\n      var e_1, _a; // If `.stop()` was called then item will be null and we need to stop particle processing immediately\n\n\n      if (item === null || !_this.getStatus().isInitialized) {\n        return;\n      } // Do not continue if there was an error in particle interpretation\n\n\n      if (!isInterpretationSuccessful(item.result)) {\n        item.onStageChange({\n          stage: 'interpreterError',\n          errorMessage: item.result.errorMessage\n        });\n        return;\n      }\n\n      setTimeout(function () {\n        item.onStageChange({\n          stage: 'interpreted'\n        });\n      }, 0); // send particle further if requested\n\n      if (item.result.nextPeerPks.length > 0) {\n        var newParticle = item.particle.clone();\n        newParticle.data = item.newData;\n\n        _this._outgoingParticles.next(__assign(__assign({}, item), {\n          particle: newParticle\n        }));\n      } // execute call requests if needed\n      // and put particle with the results back to queue\n\n\n      if (item.result.callRequests.length > 0) {\n        var _loop_1 = function (key, cr) {\n          var req = {\n            fnName: cr.functionName,\n            args: cr.arguments,\n            serviceId: cr.serviceId,\n            tetraplets: cr.tetraplets,\n            particleContext: item.particle.getParticleContext()\n          };\n\n          _this._execSingleCallRequest(req).catch(function (err) {\n            return {\n              retCode: commonTypes_1.ResultCodes.error,\n              result: \"Handler failed. fnName=\\\"\".concat(req.fnName, \"\\\" serviceId=\\\"\").concat(req.serviceId, \"\\\" error: \").concat(err.toString())\n            };\n          }).then(function (res) {\n            var serviceResult = {\n              result: (0, utils_1.jsonify)(res.result),\n              retCode: res.retCode\n            };\n            var newParticle = item.particle.clone();\n            newParticle.callResults = [[key, serviceResult]];\n            newParticle.data = Buffer_1.default.from([]);\n            particlesQueue.next(__assign(__assign({}, item), {\n              particle: newParticle\n            }));\n          });\n        };\n\n        try {\n          for (var _b = __values(item.result.callRequests), _c = _b.next(); !_c.done; _c = _b.next()) {\n            var _d = __read(_c.value, 2),\n                key = _d[0],\n                cr = _d[1];\n\n            _loop_1(key, cr);\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n      } else {\n        item.onStageChange({\n          stage: 'localWorkDone'\n        });\n      }\n    });\n    return particlesQueue;\n  };\n\n  FluencePeer.prototype._execSingleCallRequest = function (req) {\n    return __awaiter(this, void 0, void 0, function () {\n      var particleId, args, rawResult, result, key, psh, handler, res;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            loglevel_1.default.debug('executing call service handler', (0, utils_1.jsonify)(req));\n            particleId = req.particleContext.particleId;\n            if (!(this._fluenceAppService && this._marineServices.has(req.serviceId))) return [3\n            /*break*/\n            , 2];\n            args = JSON.stringify(req.args);\n            return [4\n            /*yield*/\n            , this._fluenceAppService.callService(req.serviceId, req.fnName, args, undefined)];\n\n          case 1:\n            rawResult = _a.sent();\n\n            try {\n              result = JSON.parse(rawResult);\n\n              if (typeof result.error === 'string' && result.error.length > 0) {\n                return [2\n                /*return*/\n                , {\n                  retCode: commonTypes_1.ResultCodes.error,\n                  result: result.error\n                }];\n              }\n\n              if (result.result === undefined) {\n                throw new Error(\"Call to marine-js returned no error and empty result. Original request: \".concat((0, utils_1.jsonify)(req)));\n              }\n\n              return [2\n              /*return*/\n              , {\n                retCode: commonTypes_1.ResultCodes.success,\n                result: result.result\n              }];\n            } catch (e) {\n              throw new Error(\"Call to marine-js. Result parsing error: \".concat(e, \", original text: \").concat(rawResult));\n            }\n\n            _a.label = 2;\n\n          case 2:\n            key = serviceFnKey(req.serviceId, req.fnName);\n            psh = this._particleSpecificHandlers.get(particleId); // we should prioritize handler for this particle if there is one\n            // if particle-specific handlers exist for this particle try getting handler there\n\n            if (psh !== undefined) {\n              handler = psh.get(key);\n            } // then try to find a common handler for all particles with this service-fn key\n            // if there is no particle-specific handler, get one from common map\n\n\n            if (handler === undefined) {\n              handler = this._commonHandlers.get(key);\n            } // if no handler is found return useful error message to AVM\n\n\n            if (handler === undefined) {\n              return [2\n              /*return*/\n              , {\n                retCode: commonTypes_1.ResultCodes.error,\n                result: \"No handler has been registered for serviceId='\".concat(req.serviceId, \"' fnName='\").concat(req.fnName, \"' args='\").concat((0, utils_1.jsonify)(req.args), \"'\")\n              }];\n            }\n\n            return [4\n            /*yield*/\n            , handler(req)];\n\n          case 3:\n            res = _a.sent();\n\n            if (res.result === undefined) {\n              res.result = null;\n            }\n\n            loglevel_1.default.debug('executed call service handler, req and res are: ', (0, utils_1.jsonify)(req), (0, utils_1.jsonify)(res));\n            return [2\n            /*return*/\n            , res];\n        }\n      });\n    });\n  };\n\n  FluencePeer.prototype._stopParticleProcessing = function () {\n    // do not hang if the peer has been stopped while some of the timeouts are still being executed\n    this._timeouts.forEach(function (timeout) {\n      clearTimeout(timeout);\n    });\n\n    this._particleQueues.clear();\n  };\n\n  return FluencePeer;\n}();\n\nexports.FluencePeer = FluencePeer;\n\nfunction isInterpretationSuccessful(result) {\n  return result.retCode === 0;\n}\n\nfunction serviceFnKey(serviceId, fnName) {\n  return \"\".concat(serviceId, \"/\").concat(fnName);\n}\n\nfunction registerDefaultServices(peer) {\n  Object.entries(common_1.builtInServices).forEach(function (_a) {\n    var _b = __read(_a, 2),\n        serviceId = _b[0],\n        service = _b[1];\n\n    Object.entries(service).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          fnName = _b[0],\n          fn = _b[1];\n\n      peer.internals.regHandler.common(serviceId, fnName, fn);\n    });\n  });\n}\n\nfunction runAvmRunner(currentPeerId, runner, particle, prevData) {\n  return __awaiter(this, void 0, void 0, function () {\n    var interpreterResult, toLog;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          particle.logTo('debug', 'Sending particle to interpreter');\n          loglevel_1.default.debug('prevData: ', (0, utils_1.dataToString)(prevData));\n          return [4\n          /*yield*/\n          , runner.run(particle.script, prevData, particle.data, {\n            initPeerId: particle.initPeerId,\n            currentPeerId: currentPeerId,\n            timestamp: particle.timestamp,\n            ttl: particle.ttl\n          }, particle.callResults)];\n\n        case 1:\n          interpreterResult = _a.sent();\n          toLog = __assign(__assign({}, interpreterResult), {\n            data: (0, utils_1.dataToString)(interpreterResult.data)\n          });\n\n          if (isInterpretationSuccessful(interpreterResult)) {\n            loglevel_1.default.debug('Interpreter result: ', (0, utils_1.jsonify)(toLog));\n          } else {\n            loglevel_1.default.error('Interpreter failed: ', (0, utils_1.jsonify)(toLog));\n          }\n\n          return [2\n          /*return*/\n          , interpreterResult];\n      }\n    });\n  });\n}\n\nfunction filterExpiredParticles(onParticleExpiration) {\n  return (0, rxjs_1.pipe)((0, rxjs_1.tap)(function (item) {\n    if (item.particle.hasExpired()) {\n      onParticleExpiration(item);\n    }\n  }), (0, rxjs_1.filter)(function (x) {\n    return !x.particle.hasExpired();\n  }));\n}\n\nfunction loadMarineAndAvm(marinePath, avmPath) {\n  return __awaiter(this, void 0, void 0, function () {\n    var promises, _a, marine, avm;\n\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          // check if we are running inside the browser and instantiate worker with the corresponding script\n          if (browser_or_node_1.isBrowser) {\n            promises = [// force new line\n            (0, marine_js_1.loadWasmFromServer)(marinePath), (0, marine_js_1.loadWasmFromServer)(avmPath)];\n          } else if (browser_or_node_1.isNode) {\n            promises = [// force new line\n            (0, marine_js_1.loadWasmFromFileSystem)(marinePath), (0, marine_js_1.loadWasmFromFileSystem)(avmPath)];\n          } else {\n            throw new Error('Unknown environment');\n          }\n\n          return [4\n          /*yield*/\n          , Promise.all(promises)];\n\n        case 1:\n          _a = __read.apply(void 0, [_b.sent(), 2]), marine = _a[0], avm = _a[1];\n          return [2\n          /*return*/\n          , {\n            marine: marine,\n            avm: avm\n          }];\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["DEFAULT_TTL","rxjs_1","Set","Map","FluencePeer","obj","_keyPair","undefined","isInitialized","peerId","isConnected","relayPeerId","_connection","_relayPeerId","Libp2pPeerId","toB58String","config","KeyPair","KeyPair_1","randomEd25519","_f","_j","keyPair","debug","_b","printParticleId","_printParticleId","_defaultTTL","defaultTtlMs","_c","_d","marineLogLevel","_marineLogLevel","_fluenceAppService","marine_js_1","marineJS","_e","workerScriptPath","loadMarineAndAvm","marineWasmPath","avmWasmPath","_g","marineDeps","init","marine","createService","avm","_avmRunner","avmRunner","avm_1","avmLogLevel","connectTo","connectToMultiAddr","fromNode","multiaddr","multiaddr_1","getPeerId","disconnect","_h","FluenceConnection_1","createConnection","relayAddress","dialTimeoutMs","onIncomingParticle","p","_incomingParticles","next","particle","onStageChange","_connect","registerDefaultServices","_classServices","sig","Sig_1","securityGuard","_startParticleProcessing","Error","wasm","serviceId","_containsService","_a","_marineServices","add","delete","_stopParticleProcessing","_disconnect","terminate","_particleSpecificHandlers","clear","_commonHandlers","Object","createNewParticle","script","ttl","_this","status","getStatus","Particle_1","createNew","initiateParticle","console","log","id","initPeerId","regHandler","common","fnName","handler","set","serviceFnKey","forParticle","particleId","psh","get","connect","Promise","resolve","has","pipe","x","logTo","filterExpiredParticles","_expireParticle","bind","subscribe","item","particlesQueue","_particleQueues","_createParticlesProcessingQueue","timeout","setTimeout","actualTtl","_timeouts","push","_outgoingParticles","stage","sendParticle","then","e","loglevel_1","error","concat","prevData","Buffer_1","from","runAvmRunner","result","newData","data","isInterpretationSuccessful","errorMessage","nextPeerPks","length","newParticle","clone","__assign","callRequests","key","cr","req","functionName","args","arguments","tetraplets","particleContext","getParticleContext","_execSingleCallRequest","catch","err","retCode","commonTypes_1","toString","res","serviceResult","callResults","JSON","stringify","callService","rawResult","parse","success","forEach","clearTimeout","exports","peer","entries","common_1","service","fn","internals","currentPeerId","runner","run","timestamp","interpreterResult","toLog","onParticleExpiration","hasExpired","marinePath","avmPath","browser_or_node_1","promises","all"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/FluencePeer.ts"],"sourcesContent":["/*\n * Copyright 2021 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Multiaddr } from 'multiaddr';\nimport { CallServiceData, CallServiceResult, GenericCallServiceHandler, ResultCodes } from './commonTypes';\nimport { PeerIdB58 } from './commonTypes';\nimport { FluenceConnection } from './FluenceConnection';\nimport { Particle, ParticleExecutionStage, ParticleQueueItem } from './Particle';\nimport { KeyPair } from './KeyPair';\nimport { throwIfNotSupported, dataToString, jsonify, MarineLoglevel, marineLogLevelToEnvs } from './utils';\nimport { concatMap, filter, pipe, Subject, tap } from 'rxjs';\nimport log from 'loglevel';\nimport { builtInServices } from './builtins/common';\nimport { defaultSigGuard, Sig } from './builtins/Sig';\nimport { registerSig } from './_aqua/services';\nimport Buffer from './Buffer';\nimport { FluenceAppService, loadDefaults, loadWasmFromFileSystem, loadWasmFromServer } from '@fluencelabs/marine-js';\nimport { AVM, AvmRunner } from './avm';\nimport { isBrowser, isNode } from 'browser-or-node';\nimport { InterpreterResult, LogLevel } from '@fluencelabs/avm';\n\n/**\n * Node of the Fluence network specified as a pair of node's multiaddr and it's peer id\n */\ntype Node = {\n    peerId: PeerIdB58;\n    multiaddr: string;\n};\n\nconst DEFAULT_TTL = 7000;\n\n/**\n * Configuration used when initiating Fluence Peer\n */\nexport interface PeerConfig {\n    /**\n     * Node in Fluence network to connect to.\n     * Can be in the form of:\n     * - string: multiaddr in string format\n     * - Multiaddr: multiaddr object, @see https://github.com/multiformats/js-multiaddr\n     * - Node: node structure, @see Node\n     * If not specified the will work locally and would not be able to send or receive particles.\n     */\n    connectTo?: string | Multiaddr | Node;\n\n    /**\n     * @deprecated. AVM run through marine-js infrastructure.\n     * @see debug.marineLogLevel option to configure logging level of AVM\n     */\n    avmLogLevel?: MarineLoglevel;\n\n    /**\n     * Specify the KeyPair to be used to identify the Fluence Peer.\n     * Will be generated randomly if not specified\n     */\n    KeyPair?: KeyPair;\n\n    /**\n     * When the peer established the connection to the network it sends a ping-like message to check if it works correctly.\n     * The options allows to specify the timeout for that message in milliseconds.\n     * If not specified the default timeout will be used\n     */\n    checkConnectionTimeoutMs?: number;\n\n    /**\n     * When the peer established the connection to the network it sends a ping-like message to check if it works correctly.\n     * If set to true, the ping-like message will be skipped\n     * Default: false\n     */\n    skipCheckConnection?: boolean;\n\n    /**\n     * The dialing timeout in milliseconds\n     */\n    dialTimeoutMs?: number;\n\n    /**\n     * Sets the default TTL for all particles originating from the peer with no TTL specified.\n     * If the originating particle's TTL is defined then that value will be used\n     * If the option is not set default TTL will be 7000\n     */\n    defaultTtlMs?: number;\n\n    /**\n     * @deprecated. AVM run through marine-js infrastructure.\n     * @see marineJS option to configure AVM\n     */\n    avmRunner?: AvmRunner;\n\n    /**\n     * This option allows to specify the location of various dependencies needed for marine-js.\n     * Each key specifies the location of the corresponding dependency.\n     * If Fluence peer is started inside browser the location is treated as the path to the file relative to origin.\n     * IF Fluence peer is started in nodejs the location is treated as the full path to file on the file system.\n     */\n    marineJS?: {\n        /**\n         * Configures path to the marine-js worker script.\n         */\n        workerScriptPath: string;\n\n        /**\n         * Configures the path to marine-js control wasm module\n         */\n        marineWasmPath: string;\n\n        /**\n         * Configures the path to AVM wasm module\n         */\n        avmWasmPath: string;\n    };\n\n    /**\n     * Enables\\disabled various debugging features\n     */\n    debug?: {\n        /**\n         * If set to true, newly initiated particle ids will be printed to console.\n         * Useful to see what particle id is responsible for aqua function\n         */\n        printParticleId?: boolean;\n\n        /**\n         * Log level for marine services. By default logging is turned off.\n         */\n        marineLogLevel?: LogLevel;\n    };\n}\n\n/**\n * Information about Fluence Peer connection\n */\nexport type PeerStatus =\n    | {\n          isInitialized: false;\n          peerId: null;\n          isConnected: false;\n          relayPeerId: null;\n      }\n    | {\n          isInitialized: true;\n          peerId: PeerIdB58;\n          isConnected: false;\n          relayPeerId: null;\n      }\n    | {\n          isInitialized: true;\n          peerId: PeerIdB58;\n          isConnected: true;\n          relayPeerId: PeerIdB58;\n      };\n\n/**\n * This class implements the Fluence protocol for javascript-based environments.\n * It provides all the necessary features to communicate with Fluence network\n */\nexport class FluencePeer {\n    /**\n     * Checks whether the object is instance of FluencePeer class\n     * @param obj - object to check if it is FluencePeer\n     * @returns true if the object is FluencePeer false otherwise\n     */\n    static isInstance(obj: unknown): obj is FluencePeer {\n        return obj instanceof FluencePeer;\n    }\n\n    /**\n     * Get the peer's status\n     */\n    getStatus(): PeerStatus {\n        // TODO:: use explicit mechanism for peer's state\n        if (this._keyPair === undefined) {\n            return {\n                isInitialized: false,\n                peerId: null,\n                isConnected: false,\n                relayPeerId: null,\n            };\n        }\n\n        if (this._connection === undefined || this._relayPeerId === null) {\n            return {\n                isInitialized: true,\n                peerId: this._keyPair.Libp2pPeerId.toB58String(),\n                isConnected: false,\n                relayPeerId: null,\n            };\n        }\n\n        return {\n            isInitialized: true,\n            peerId: this._keyPair.Libp2pPeerId.toB58String(),\n            isConnected: true,\n            relayPeerId: this._relayPeerId,\n        };\n    }\n\n    /**\n     * Initializes the peer: starts the Aqua VM, initializes the default call service handlers\n     * and (optionally) connect to the Fluence network\n     * @param config - object specifying peer configuration\n     */\n    async start(config?: PeerConfig): Promise<void> {\n        throwIfNotSupported();\n\n        const keyPair = config?.KeyPair ?? (await KeyPair.randomEd25519());\n        this._keyPair = keyPair;\n\n        const peerId = keyPair.Libp2pPeerId.toB58String();\n\n        if (config?.debug?.printParticleId) {\n            this._printParticleId = true;\n        }\n\n        this._defaultTTL = config?.defaultTtlMs ?? DEFAULT_TTL;\n\n        if (config?.debug?.marineLogLevel) {\n            this._marineLogLevel = config.debug.marineLogLevel;\n        }\n\n        this._fluenceAppService = new FluenceAppService(config?.marineJS?.workerScriptPath);\n        const marineDeps = config?.marineJS\n            ? await loadMarineAndAvm(config.marineJS.marineWasmPath, config.marineJS.avmWasmPath)\n            : await loadDefaults();\n        await this._fluenceAppService.init(marineDeps.marine);\n        await this._fluenceAppService.createService(\n            marineDeps.avm,\n            'avm',\n            undefined,\n            marineLogLevelToEnvs(this._marineLogLevel),\n        );\n        this._avmRunner = config?.avmRunner || new AVM(this._fluenceAppService);\n        await this._avmRunner.init(config?.avmLogLevel || 'off');\n\n        if (config?.connectTo) {\n            let connectToMultiAddr: Multiaddr;\n            const fromNode = (config.connectTo as any).multiaddr;\n            if (fromNode) {\n                connectToMultiAddr = new Multiaddr(fromNode);\n            } else {\n                connectToMultiAddr = new Multiaddr(config.connectTo as string);\n            }\n\n            this._relayPeerId = connectToMultiAddr.getPeerId();\n\n            if (this._connection) {\n                await this._connection.disconnect();\n            }\n\n            this._connection = await FluenceConnection.createConnection({\n                peerId: this._keyPair.Libp2pPeerId,\n                relayAddress: connectToMultiAddr,\n                dialTimeoutMs: config.dialTimeoutMs,\n                onIncomingParticle: (p) => this._incomingParticles.next({ particle: p, onStageChange: () => {} }),\n            });\n\n            await this._connect();\n        }\n\n        registerDefaultServices(this);\n\n        this._classServices = {\n            sig: new Sig(this._keyPair),\n        };\n        this._classServices.sig.securityGuard = defaultSigGuard(peerId);\n        registerSig(this, this._classServices.sig);\n        registerSig(this, peerId, this._classServices.sig);\n\n        this._startParticleProcessing();\n    }\n\n    getServices() {\n        if (this._classServices === undefined) {\n            throw new Error(`Can't get services: peer is not initialized`);\n        }\n        return {\n            ...this._classServices,\n        };\n    }\n\n    /**\n     * Registers marine service within the Fluence peer from wasm file.\n     * Following helper functions can be used to load wasm files:\n     * * loadWasmFromFileSystem\n     * * loadWasmFromNpmPackage\n     * * loadWasmFromServer\n     * @param wasm - buffer with the wasm file for service\n     * @param serviceId - the service id by which the service can be accessed in aqua\n     */\n    async registerMarineService(wasm: SharedArrayBuffer | Buffer, serviceId: string): Promise<void> {\n        if (!this._fluenceAppService) {\n            throw new Error(\"Can't register marine service: peer is not initialized\");\n        }\n        if (this._containsService(serviceId)) {\n            throw new Error(`Service with '${serviceId}' id already exists`);\n        }\n\n        await this._fluenceAppService.createService(\n            wasm,\n            serviceId,\n            undefined,\n            marineLogLevelToEnvs(this._marineLogLevel),\n        );\n        this._marineServices.add(serviceId);\n    }\n\n    /**\n     * Removes the specified marine service from the Fluence peer\n     * @param serviceId - the service id to remove\n     */\n    removeMarineService(serviceId: string): void {\n        this._marineServices.delete(serviceId);\n    }\n\n    /**\n     * Un-initializes the peer: stops all the underlying workflows, stops the Aqua VM\n     * and disconnects from the Fluence network\n     */\n    async stop() {\n        this._keyPair = undefined; // This will set peer to non-initialized state and stop particle processing\n        this._relayPeerId = null;\n        this._stopParticleProcessing();\n        await this._disconnect();\n        await this._avmRunner?.terminate();\n        await this._fluenceAppService?.terminate();\n        this._avmRunner = undefined;\n        this._fluenceAppService = undefined;\n        this._classServices = undefined;\n\n        this._particleSpecificHandlers.clear();\n        this._commonHandlers.clear();\n        this._marineServices.clear();\n    }\n\n    // internal api\n\n    /**\n     * Is not intended to be used manually. Subject to change\n     */\n    get internals() {\n        return {\n            createNewParticle: (script: string, ttl: number = this._defaultTTL) => {\n                const status = this.getStatus();\n\n                if (!status.isInitialized) {\n                    return new Error(\"Can't create new particle: peer is not initialized\");\n                }\n\n                return Particle.createNew(script, ttl, status.peerId);\n            },\n            /**\n             * Initiates a new particle execution starting from local peer\n             * @param particle - particle to start execution of\n             */\n            initiateParticle: (particle: Particle, onStageChange: (stage: ParticleExecutionStage) => void): void => {\n                const status = this.getStatus();\n                if (!status.isInitialized) {\n                    throw new Error('Cannot initiate new particle: peer is not initialized');\n                }\n\n                if (this._printParticleId) {\n                    console.log('Particle id: ', particle.id);\n                }\n\n                if (particle.initPeerId === undefined) {\n                    particle.initPeerId = status.peerId;\n                }\n\n                if (particle.ttl === undefined) {\n                    particle.ttl = this._defaultTTL;\n                }\n\n                this._incomingParticles.next({\n                    particle: particle,\n                    onStageChange: onStageChange,\n                });\n            },\n\n            /**\n             * Register Call Service handler functions\n             */\n            regHandler: {\n                /**\n                 * Register handler for all particles\n                 */\n                common: (\n                    // force new line\n                    serviceId: string,\n                    fnName: string,\n                    handler: GenericCallServiceHandler,\n                ) => {\n                    this._commonHandlers.set(serviceFnKey(serviceId, fnName), handler);\n                },\n                /**\n                 * Register handler which will be called only for particle with the specific id\n                 */\n                forParticle: (\n                    particleId: string,\n                    serviceId: string,\n                    fnName: string,\n                    handler: GenericCallServiceHandler,\n                ) => {\n                    let psh = this._particleSpecificHandlers.get(particleId);\n                    if (psh === undefined) {\n                        psh = new Map<string, GenericCallServiceHandler>();\n                        this._particleSpecificHandlers.set(particleId, psh);\n                    }\n\n                    psh.set(serviceFnKey(serviceId, fnName), handler);\n                },\n            },\n        };\n    }\n\n    // private\n\n    // TODO:: make public when full connection\\disconnection cycle is implemented properly\n    private _connect(): Promise<void> {\n        return this._connection?.connect() || Promise.resolve();\n    }\n\n    // TODO:: make public when full connection\\disconnection cycle is implemented properly\n    private _disconnect(): Promise<void> {\n        return this._connection?.disconnect() || Promise.resolve();\n    }\n\n    // Queues for incoming and outgoing particles\n\n    private _incomingParticles = new Subject<ParticleQueueItem>();\n    private _outgoingParticles = new Subject<ParticleQueueItem>();\n\n    // Call service handler\n\n    private _marineServices = new Set<string>();\n    private _marineLogLevel?: MarineLoglevel;\n    private _particleSpecificHandlers = new Map<string, Map<string, GenericCallServiceHandler>>();\n    private _commonHandlers = new Map<string, GenericCallServiceHandler>();\n\n    private _classServices?: {\n        sig: Sig;\n    };\n\n    private _containsService(serviceId: string): boolean {\n        return this._marineServices.has(serviceId) || this._commonHandlers.has(serviceId);\n    }\n\n    // Internal peer state\n\n    private _printParticleId = false;\n    private _defaultTTL: number = DEFAULT_TTL;\n    private _relayPeerId: PeerIdB58 | null = null;\n    private _keyPair: KeyPair | undefined;\n    private _connection?: FluenceConnection;\n\n    /**\n     * @deprecated. AVM run through marine-js infrastructure. This field is needed for backward compatibility with the previous API\n     */\n    private _avmRunner?: AvmRunner;\n    private _fluenceAppService?: FluenceAppService;\n    private _timeouts: Array<NodeJS.Timeout> = [];\n    private _particleQueues = new Map<string, Subject<ParticleQueueItem>>();\n\n    private _startParticleProcessing() {\n        this._incomingParticles\n            .pipe(\n                tap((x) => {\n                    x.particle.logTo('debug', 'particle received:');\n                }),\n                filterExpiredParticles(this._expireParticle.bind(this)),\n            )\n            .subscribe((item) => {\n                const p = item.particle;\n                let particlesQueue = this._particleQueues.get(p.id);\n\n                if (!particlesQueue) {\n                    particlesQueue = this._createParticlesProcessingQueue();\n                    this._particleQueues.set(p.id, particlesQueue);\n\n                    const timeout = setTimeout(() => {\n                        this._expireParticle(item);\n                    }, p.actualTtl());\n\n                    this._timeouts.push(timeout);\n                }\n\n                particlesQueue.next(item);\n            });\n\n        this._outgoingParticles.subscribe((item) => {\n            // Do not send particle after the peer has been stopped\n            if (!this.getStatus().isInitialized) {\n                return;\n            }\n\n            if (!this._connection) {\n                item.particle.logTo('error', 'cannot send particle, peer is not connected');\n                item.onStageChange({ stage: 'sendingError' });\n                return;\n            }\n            this._connection.sendParticle(item.particle).then(\n                () => {\n                    item.onStageChange({ stage: 'sent' });\n                },\n                (e) => {\n                    log.error(e);\n                },\n            );\n        });\n    }\n\n    private _expireParticle(item: ParticleQueueItem) {\n        const particleId = item.particle.id;\n        log.debug(\n            `particle ${particleId} has expired after ${item.particle.ttl}. Deleting particle-related queues and handlers`,\n        );\n\n        this._particleQueues.delete(particleId);\n        this._particleSpecificHandlers.delete(particleId);\n\n        item.onStageChange({ stage: 'expired' });\n    }\n\n    private _createParticlesProcessingQueue() {\n        const particlesQueue = new Subject<ParticleQueueItem>();\n        let prevData: Uint8Array = Buffer.from([]);\n\n        particlesQueue\n            .pipe(\n                filterExpiredParticles(this._expireParticle.bind(this)),\n\n                concatMap(async (item) => {\n                    const status = this.getStatus();\n                    if (!status.isInitialized || this._avmRunner === undefined) {\n                        // If `.stop()` was called return null to stop particle processing immediately\n                        return null;\n                    }\n\n                    // IMPORTANT!\n                    // AVM runner execution and prevData <-> newData swapping\n                    // MUST happen sequentially (in a critical section).\n                    // Otherwise the race between runner might occur corrupting the prevData\n\n                    const result = await runAvmRunner(status.peerId, this._avmRunner, item.particle, prevData);\n                    const newData = Buffer.from(result.data);\n                    prevData = newData;\n\n                    return {\n                        ...item,\n                        result: result,\n                        newData: newData,\n                    };\n                }),\n            )\n            .subscribe((item) => {\n                // If `.stop()` was called then item will be null and we need to stop particle processing immediately\n                if (item === null || !this.getStatus().isInitialized) {\n                    return;\n                }\n\n                // Do not continue if there was an error in particle interpretation\n                if (!isInterpretationSuccessful(item.result)) {\n                    item.onStageChange({ stage: 'interpreterError', errorMessage: item.result.errorMessage });\n                    return;\n                }\n\n                setTimeout(() => {\n                    item.onStageChange({ stage: 'interpreted' });\n                }, 0);\n\n                // send particle further if requested\n                if (item.result.nextPeerPks.length > 0) {\n                    const newParticle = item.particle.clone();\n                    newParticle.data = item.newData;\n                    this._outgoingParticles.next({ ...item, particle: newParticle });\n                }\n\n                // execute call requests if needed\n                // and put particle with the results back to queue\n                if (item.result.callRequests.length > 0) {\n                    for (const [key, cr] of item.result.callRequests) {\n                        const req = {\n                            fnName: cr.functionName,\n                            args: cr.arguments,\n                            serviceId: cr.serviceId,\n                            tetraplets: cr.tetraplets,\n                            particleContext: item.particle.getParticleContext(),\n                        };\n\n                        this._execSingleCallRequest(req)\n                            .catch(\n                                (err): CallServiceResult => ({\n                                    retCode: ResultCodes.error,\n                                    result: `Handler failed. fnName=\"${req.fnName}\" serviceId=\"${\n                                        req.serviceId\n                                    }\" error: ${err.toString()}`,\n                                }),\n                            )\n                            .then((res) => {\n                                const serviceResult = {\n                                    result: jsonify(res.result),\n                                    retCode: res.retCode,\n                                };\n\n                                const newParticle = item.particle.clone();\n                                newParticle.callResults = [[key, serviceResult]];\n                                newParticle.data = Buffer.from([]);\n\n                                particlesQueue.next({ ...item, particle: newParticle });\n                            });\n                    }\n                } else {\n                    item.onStageChange({ stage: 'localWorkDone' });\n                }\n            });\n\n        return particlesQueue;\n    }\n\n    private async _execSingleCallRequest(req: CallServiceData): Promise<CallServiceResult> {\n        log.debug('executing call service handler', jsonify(req));\n        const particleId = req.particleContext.particleId;\n\n        if (this._fluenceAppService && this._marineServices.has(req.serviceId)) {\n            const args = JSON.stringify(req.args);\n            const rawResult = await this._fluenceAppService.callService(req.serviceId, req.fnName, args, undefined);\n\n            try {\n                const result = JSON.parse(rawResult);\n                if (typeof result.error === 'string' && result.error.length > 0) {\n                    return {\n                        retCode: ResultCodes.error,\n                        result: result.error,\n                    };\n                }\n\n                if (result.result === undefined) {\n                    throw new Error(\n                        `Call to marine-js returned no error and empty result. Original request: ${jsonify(req)}`,\n                    );\n                }\n\n                return {\n                    retCode: ResultCodes.success,\n                    result: result.result,\n                };\n            } catch (e) {\n                throw new Error(`Call to marine-js. Result parsing error: ${e}, original text: ${rawResult}`);\n            }\n        }\n\n        const key = serviceFnKey(req.serviceId, req.fnName);\n        const psh = this._particleSpecificHandlers.get(particleId);\n        let handler: GenericCallServiceHandler | undefined;\n\n        // we should prioritize handler for this particle if there is one\n        // if particle-specific handlers exist for this particle try getting handler there\n        if (psh !== undefined) {\n            handler = psh.get(key);\n        }\n\n        // then try to find a common handler for all particles with this service-fn key\n        // if there is no particle-specific handler, get one from common map\n        if (handler === undefined) {\n            handler = this._commonHandlers.get(key);\n        }\n\n        // if no handler is found return useful error message to AVM\n        if (handler === undefined) {\n            return {\n                retCode: ResultCodes.error,\n                result: `No handler has been registered for serviceId='${req.serviceId}' fnName='${\n                    req.fnName\n                }' args='${jsonify(req.args)}'`,\n            };\n        }\n\n        // if we found a handler, execute it\n        const res = await handler(req);\n\n        if (res.result === undefined) {\n            res.result = null;\n        }\n\n        log.debug('executed call service handler, req and res are: ', jsonify(req), jsonify(res));\n        return res;\n    }\n\n    private _stopParticleProcessing() {\n        // do not hang if the peer has been stopped while some of the timeouts are still being executed\n        this._timeouts.forEach((timeout) => {\n            clearTimeout(timeout);\n        });\n        this._particleQueues.clear();\n    }\n}\n\nfunction isInterpretationSuccessful(result: InterpreterResult) {\n    return result.retCode === 0;\n}\n\nfunction serviceFnKey(serviceId: string, fnName: string) {\n    return `${serviceId}/${fnName}`;\n}\n\nfunction registerDefaultServices(peer: FluencePeer) {\n    Object.entries(builtInServices).forEach(([serviceId, service]) => {\n        Object.entries(service).forEach(([fnName, fn]) => {\n            peer.internals.regHandler.common(serviceId, fnName, fn);\n        });\n    });\n}\n\nasync function runAvmRunner(\n    currentPeerId: PeerIdB58,\n    runner: AvmRunner,\n    particle: Particle,\n    prevData: Uint8Array,\n): Promise<InterpreterResult> {\n    particle.logTo('debug', 'Sending particle to interpreter');\n    log.debug('prevData: ', dataToString(prevData));\n    const interpreterResult = await runner.run(\n        particle.script,\n        prevData,\n        particle.data,\n        {\n            initPeerId: particle.initPeerId,\n            currentPeerId: currentPeerId,\n            timestamp: particle.timestamp,\n            ttl: particle.ttl,\n        },\n        particle.callResults,\n    );\n\n    const toLog = { ...interpreterResult, data: dataToString(interpreterResult.data) };\n\n    if (isInterpretationSuccessful(interpreterResult)) {\n        log.debug('Interpreter result: ', jsonify(toLog));\n    } else {\n        log.error('Interpreter failed: ', jsonify(toLog));\n    }\n    return interpreterResult;\n}\n\nfunction filterExpiredParticles(onParticleExpiration: (item: ParticleQueueItem) => void) {\n    return pipe(\n        tap((item: ParticleQueueItem) => {\n            if (item.particle.hasExpired()) {\n                onParticleExpiration(item);\n            }\n        }),\n        filter((x: ParticleQueueItem) => !x.particle.hasExpired()),\n    );\n}\n\nasync function loadMarineAndAvm(\n    marinePath: string,\n    avmPath: string,\n): Promise<{\n    marine: SharedArrayBuffer | Buffer;\n    avm: SharedArrayBuffer | Buffer;\n}> {\n    let promises: [Promise<SharedArrayBuffer | Buffer>, Promise<SharedArrayBuffer | Buffer>];\n    // check if we are running inside the browser and instantiate worker with the corresponding script\n    if (isBrowser) {\n        promises = [\n            // force new line\n            loadWasmFromServer(marinePath),\n            loadWasmFromServer(avmPath),\n        ];\n    } else if (isNode) {\n        promises = [\n            // force new line\n            loadWasmFromFileSystem(marinePath),\n            loadWasmFromFileSystem(avmPath),\n        ];\n    } else {\n        throw new Error('Unknown environment');\n    }\n\n    const [marine, avm] = await Promise.all(promises);\n    return {\n        marine,\n        avm,\n    };\n}\n"]},"metadata":{},"sourceType":"script"}