{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerId = require('peer-id');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').ProtoBook} ProtoBook\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store:proto-book'), {\n  error: debug('libp2p:peer-store:proto-book:err')\n});\nconst EVENT_NAME = 'change:protocols';\n/**\n * @implements {ProtoBook}\n */\n\nclass PersistentProtoBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor(emit, store) {\n    this._emit = emit;\n    this._store = store;\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    log('get wait for read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.protocols;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async set(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n\n        if (new Set([...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      });\n      log(`stored provided protocols for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async add(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('add await write lock');\n    const release = await this._store.lock.writeLock();\n    log('add got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n\n        if (new Set([...peer.protocols, ...protocols]).size === peer.protocols.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        protocols\n      });\n      log(`added provided protocols for ${peerId.toB58String()}`);\n    } finally {\n      log('add release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n\n\n  async remove(peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data');\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('remove await write lock');\n    const release = await this._store.lock.writeLock();\n    log('remove got write lock');\n    let updatedPeer;\n\n    try {\n      try {\n        const peer = await this._store.load(peerId);\n        const protocolSet = new Set(peer.protocols);\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol);\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return;\n        }\n\n        protocols = Array.from(protocolSet);\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      });\n    } finally {\n      log('remove release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      protocols: updatedPeer.protocols\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n    let has;\n\n    try {\n      has = await this._store.has(peerId);\n      await this._store.patchOrCreate(peerId, {\n        protocols: []\n      });\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        protocols: []\n      });\n    }\n  }\n\n}\n\nmodule.exports = PersistentProtoBook;","map":{"version":3,"names":["debug","require","errcode","codes","PeerId","log","Object","assign","error","EVENT_NAME","PersistentProtoBook","constructor","emit","store","_emit","_store","get","peerId","release","lock","readLock","peer","load","protocols","err","code","ERR_NOT_FOUND","set","isPeerId","Error","ERR_INVALID_PARAMETERS","Array","isArray","writeLock","updatedPeer","Set","size","length","patchOrCreate","toB58String","add","mergeOrCreate","remove","protocolSet","protocol","delete","from","has","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/peer-store/proto-book.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { codes } = require('../errors')\nconst PeerId = require('peer-id')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').ProtoBook} ProtoBook\n */\n\nconst log = Object.assign(debug('libp2p:peer-store:proto-book'), {\n  error: debug('libp2p:peer-store:proto-book:err')\n})\n\nconst EVENT_NAME = 'change:protocols'\n\n/**\n * @implements {ProtoBook}\n */\nclass PersistentProtoBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   */\n  constructor (emit, store) {\n    this._emit = emit\n    this._store = store\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    log('get wait for read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.protocols\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async set (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n\n        if (new Set([\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      })\n\n      log(`stored provided protocols for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async add (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('add await write lock')\n    const release = await this._store.lock.writeLock()\n    log('add got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n\n        if (new Set([\n          ...peer.protocols,\n          ...protocols\n        ]).size === peer.protocols.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        protocols\n      })\n\n      log(`added provided protocols for ${peerId.toB58String()}`)\n    } finally {\n      log('add release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {string[]} protocols\n   */\n  async remove (peerId, protocols) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(protocols)) {\n      log.error('protocols must be provided to store data')\n      throw errcode(new Error('protocols must be provided'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('remove await write lock')\n    const release = await this._store.lock.writeLock()\n    log('remove got write lock')\n\n    let updatedPeer\n\n    try {\n      try {\n        const peer = await this._store.load(peerId)\n        const protocolSet = new Set(peer.protocols)\n\n        for (const protocol of protocols) {\n          protocolSet.delete(protocol)\n        }\n\n        if (peer.protocols.length === protocolSet.size) {\n          return\n        }\n\n        protocols = Array.from(protocolSet)\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        protocols\n      })\n    } finally {\n      log('remove release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, protocols: updatedPeer.protocols })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n    let has\n\n    try {\n      has = await this._store.has(peerId)\n\n      await this._store.patchOrCreate(peerId, {\n        protocols: []\n      })\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, { peerId, protocols: [] })\n    }\n  }\n}\n\nmodule.exports = PersistentProtoBook\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}