{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VirtualAction = exports.VirtualTimeScheduler = void 0;\n\nvar AsyncAction_1 = require(\"./AsyncAction\");\n\nvar Subscription_1 = require(\"../Subscription\");\n\nvar AsyncScheduler_1 = require(\"./AsyncScheduler\");\n\nvar VirtualTimeScheduler = function (_super) {\n  __extends(VirtualTimeScheduler, _super);\n\n  function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {\n    if (schedulerActionCtor === void 0) {\n      schedulerActionCtor = VirtualAction;\n    }\n\n    if (maxFrames === void 0) {\n      maxFrames = Infinity;\n    }\n\n    var _this = _super.call(this, schedulerActionCtor, function () {\n      return _this.frame;\n    }) || this;\n\n    _this.maxFrames = maxFrames;\n    _this.frame = 0;\n    _this.index = -1;\n    return _this;\n  }\n\n  VirtualTimeScheduler.prototype.flush = function () {\n    var _a = this,\n        actions = _a.actions,\n        maxFrames = _a.maxFrames;\n\n    var error;\n    var action;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    }\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  VirtualTimeScheduler.frameTimeFactor = 10;\n  return VirtualTimeScheduler;\n}(AsyncScheduler_1.AsyncScheduler);\n\nexports.VirtualTimeScheduler = VirtualTimeScheduler;\n\nvar VirtualAction = function (_super) {\n  __extends(VirtualAction, _super);\n\n  function VirtualAction(scheduler, work, index) {\n    if (index === void 0) {\n      index = scheduler.index += 1;\n    }\n\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.index = index;\n    _this.active = true;\n    _this.index = scheduler.index = index;\n    return _this;\n  }\n\n  VirtualAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return _super.prototype.schedule.call(this, state, delay);\n      }\n\n      this.active = false;\n      var action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      return Subscription_1.Subscription.EMPTY;\n    }\n  };\n\n  VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    this.delay = scheduler.frame + delay;\n    var actions = scheduler.actions;\n    actions.push(this);\n    actions.sort(VirtualAction.sortActions);\n    return true;\n  };\n\n  VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return undefined;\n  };\n\n  VirtualAction.prototype._execute = function (state, delay) {\n    if (this.active === true) {\n      return _super.prototype._execute.call(this, state, delay);\n    }\n  };\n\n  VirtualAction.sortActions = function (a, b) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  };\n\n  return VirtualAction;\n}(AsyncAction_1.AsyncAction);\n\nexports.VirtualAction = VirtualAction;","map":{"version":3,"mappings":"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","names":["__extends","schedulerActionCtor","maxFrames","VirtualAction","_super","frame","_this","VirtualTimeScheduler","actions","error","action","delay","shift","execute","state","unsubscribe","AsyncScheduler_1","exports","scheduler","work","index","Number","isFinite","id","schedule","call","active","add","Subscription_1","EMPTY","push","sort","sortActions","undefined","_execute","a","b","AsyncAction_1"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/rxjs/src/internal/scheduler/VirtualTimeScheduler.ts"],"sourcesContent":["import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The the difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   * @return {void}\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return true;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): any {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}