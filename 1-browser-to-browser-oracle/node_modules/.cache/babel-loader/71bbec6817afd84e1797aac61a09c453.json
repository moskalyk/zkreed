{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst {\n  codes\n} = require('../errors');\n\nconst PeerRecord = require('../record/peer-record');\n\nconst Envelope = require('../record/envelope');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst all = require('it-all');\n\nconst filter = require('it-filter');\n\nconst map = require('it-map');\n\nconst each = require('it-foreach');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Address} Address\n * @typedef {import('./types').AddressBook} AddressBook\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n});\nconst EVENT_NAME = 'change:multiaddrs';\n/**\n * @implements {AddressBook}\n */\n\nclass PeerStoreAddressBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n   */\n  constructor(emit, store, addressFilter) {\n    this._emit = emit;\n    this._store = store;\n    this._addressFilter = addressFilter;\n  }\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   */\n\n\n  async consumePeerRecord(envelope) {\n    log('consumePeerRecord await write lock');\n    const release = await this._store.lock.writeLock();\n    log('consumePeerRecord got write lock');\n    let peerId;\n    let updatedPeer;\n\n    try {\n      let peerRecord;\n\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error('invalid peer record received');\n        return false;\n      }\n\n      peerId = peerRecord.peerId;\n      const multiaddrs = peerRecord.multiaddrs; // Verify peerId\n\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord');\n        return false;\n      } // ensure the record has multiaddrs\n\n\n      if (!multiaddrs || !multiaddrs.length) {\n        return false;\n      }\n\n      if (await this._store.has(peerId)) {\n        const peer = await this._store.load(peerId);\n\n        if (peer.peerRecordEnvelope) {\n          const storedEnvelope = await Envelope.createFromProtobuf(peer.peerRecordEnvelope);\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload); // ensure seq is greater than, or equal to, the last received\n\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            return false;\n          }\n        }\n      } // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses: await filterMultiaddrs(peerId, multiaddrs, this._addressFilter, true),\n        peerRecordEnvelope: envelope.marshal()\n      });\n      log(`stored provided peer record for ${peerRecord.peerId.toB58String()}`);\n    } finally {\n      log('consumePeerRecord release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(_ref => {\n        let {\n          multiaddr\n        } = _ref;\n        return multiaddr;\n      })\n    });\n\n    return true;\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async getRawEnvelope(peerId) {\n    log('getRawEnvelope await read lock');\n    const release = await this._store.lock.readLock();\n    log('getRawEnvelope got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.peerRecordEnvelope;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('getRawEnvelope release read lock');\n      release();\n    }\n  }\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async getPeerRecord(peerId) {\n    const raw = await this.getRawEnvelope(peerId);\n\n    if (!raw) {\n      return undefined;\n    }\n\n    return Envelope.createFromProtobuf(raw);\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('get wait for read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      const peer = await this._store.load(peerId);\n      return peer.addresses;\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n    } finally {\n      log('get release read lock');\n      release();\n    }\n\n    return [];\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n\n\n  async set(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('set await write lock');\n    const release = await this._store.lock.writeLock();\n    log('set got write lock');\n    let hasPeer = false;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter); // No valid addresses found\n\n      if (!addresses.length) {\n        return;\n      }\n\n      try {\n        const peer = await this._store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref2 => {\n          let {\n            multiaddr\n          } = _ref2;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref3 => {\n          let {\n            multiaddr\n          } = _ref3;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses\n      });\n      log(`set multiaddrs for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr)\n    }); // Notify the existence of a new peer\n\n\n    if (!hasPeer) {\n      this._emit('peer', peerId);\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n\n\n  async add(peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs');\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('add await write lock');\n    const release = await this._store.lock.writeLock();\n    log('add got write lock');\n    let hasPeer;\n    let updatedPeer;\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter); // No valid addresses found\n\n      if (!addresses.length) {\n        return;\n      }\n\n      try {\n        const peer = await this._store.load(peerId);\n        hasPeer = true;\n\n        if (new Set([...addresses.map(_ref4 => {\n          let {\n            multiaddr\n          } = _ref4;\n          return multiaddr.toString();\n        }), ...peer.addresses.map(_ref5 => {\n          let {\n            multiaddr\n          } = _ref5;\n          return multiaddr.toString();\n        })]).size === peer.addresses.length) {\n          return;\n        }\n      } catch (\n      /** @type {any} */\n      err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err;\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, {\n        addresses\n      });\n      log(`added multiaddrs for ${peerId.toB58String()}`);\n    } finally {\n      log('set release write lock');\n      release();\n    }\n\n    this._emit(EVENT_NAME, {\n      peerId,\n      multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr)\n    }); // Notify the existence of a new peer\n\n\n    if (!hasPeer) {\n      this._emit('peer', peerId);\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n    let has;\n\n    try {\n      has = await this._store.has(peerId);\n      await this._store.patchOrCreate(peerId, {\n        addresses: []\n      });\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, {\n        peerId,\n        multiaddrs: []\n      });\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   */\n\n\n  async getMultiaddrsForPeer(peerId) {\n    let addressSorter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ms => ms;\n    const addresses = await this.get(peerId);\n    return addressSorter(addresses).map(address => {\n      const multiaddr = address.multiaddr;\n      const idString = multiaddr.getPeerId();\n      if (idString && idString === peerId.toB58String()) return multiaddr;\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);\n    });\n  }\n\n}\n/**\n * @param {PeerId} peerId\n * @param {Multiaddr[]} multiaddrs\n * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n * @param {boolean} isCertified\n */\n\n\nfunction filterMultiaddrs(peerId, multiaddrs, addressFilter) {\n  let isCertified = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return pipe(multiaddrs, source => each(source, multiaddr => {\n    if (!Multiaddr.isMultiaddr(multiaddr)) {\n      log.error('multiaddr must be an instance of Multiaddr');\n      throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS);\n    }\n  }), source => filter(source, multiaddr => addressFilter(peerId, multiaddr)), source => map(source, multiaddr => {\n    return {\n      multiaddr: new Multiaddr(multiaddr.toString()),\n      isCertified\n    };\n  }), source => all(source));\n}\n\nmodule.exports = PeerStoreAddressBook;","map":{"version":3,"names":["debug","require","errcode","Multiaddr","PeerId","codes","PeerRecord","Envelope","pipe","all","filter","map","each","log","Object","assign","error","EVENT_NAME","PeerStoreAddressBook","constructor","emit","store","addressFilter","_emit","_store","_addressFilter","consumePeerRecord","envelope","release","lock","writeLock","peerId","updatedPeer","peerRecord","createFromProtobuf","payload","err","multiaddrs","equals","length","has","peer","load","peerRecordEnvelope","storedEnvelope","storedRecord","seqNumber","patchOrCreate","addresses","filterMultiaddrs","marshal","toB58String","multiaddr","getRawEnvelope","readLock","code","ERR_NOT_FOUND","getPeerRecord","raw","undefined","get","isPeerId","Error","ERR_INVALID_PARAMETERS","set","Array","isArray","hasPeer","Set","toString","size","addr","add","mergeOrCreate","delete","getMultiaddrsForPeer","addressSorter","ms","address","idString","getPeerId","encapsulate","isCertified","source","isMultiaddr","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/peer-store/address-book.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst errcode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\nconst PeerId = require('peer-id')\nconst { codes } = require('../errors')\nconst PeerRecord = require('../record/peer-record')\nconst Envelope = require('../record/envelope')\nconst { pipe } = require('it-pipe')\nconst all = require('it-all')\nconst filter = require('it-filter')\nconst map = require('it-map')\nconst each = require('it-foreach')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Address} Address\n * @typedef {import('./types').AddressBook} AddressBook\n */\n\nconst log = Object.assign(debug('libp2p:peer-store:address-book'), {\n  error: debug('libp2p:peer-store:address-book:err')\n})\n\nconst EVENT_NAME = 'change:multiaddrs'\n\n/**\n * @implements {AddressBook}\n */\nclass PeerStoreAddressBook {\n  /**\n   * @param {PeerStore[\"emit\"]} emit\n   * @param {import('./types').Store} store\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n   */\n  constructor (emit, store, addressFilter) {\n    this._emit = emit\n    this._store = store\n    this._addressFilter = addressFilter\n  }\n\n  /**\n   * ConsumePeerRecord adds addresses from a signed peer record contained in a record envelope.\n   * This will return a boolean that indicates if the record was successfully processed and added\n   * into the AddressBook.\n   *\n   * @param {Envelope} envelope\n   */\n  async consumePeerRecord (envelope) {\n    log('consumePeerRecord await write lock')\n    const release = await this._store.lock.writeLock()\n    log('consumePeerRecord got write lock')\n\n    let peerId\n    let updatedPeer\n\n    try {\n      let peerRecord\n      try {\n        peerRecord = PeerRecord.createFromProtobuf(envelope.payload)\n      } catch (/** @type {any} */ err) {\n        log.error('invalid peer record received')\n        return false\n      }\n\n      peerId = peerRecord.peerId\n      const multiaddrs = peerRecord.multiaddrs\n\n      // Verify peerId\n      if (!peerId.equals(envelope.peerId)) {\n        log('signing key does not match PeerId in the PeerRecord')\n        return false\n      }\n\n      // ensure the record has multiaddrs\n      if (!multiaddrs || !multiaddrs.length) {\n        return false\n      }\n\n      if (await this._store.has(peerId)) {\n        const peer = await this._store.load(peerId)\n\n        if (peer.peerRecordEnvelope) {\n          const storedEnvelope = await Envelope.createFromProtobuf(peer.peerRecordEnvelope)\n          const storedRecord = PeerRecord.createFromProtobuf(storedEnvelope.payload)\n\n          // ensure seq is greater than, or equal to, the last received\n          if (storedRecord.seqNumber >= peerRecord.seqNumber) {\n            return false\n          }\n        }\n      }\n\n      // Replace unsigned addresses by the new ones from the record\n      // TODO: Once we have ttls for the addresses, we should merge these in\n      updatedPeer = await this._store.patchOrCreate(peerId, {\n        addresses: await filterMultiaddrs(peerId, multiaddrs, this._addressFilter, true),\n        peerRecordEnvelope: envelope.marshal()\n      })\n\n      log(`stored provided peer record for ${peerRecord.peerId.toB58String()}`)\n    } finally {\n      log('consumePeerRecord release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(({ multiaddr }) => multiaddr) })\n\n    return true\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async getRawEnvelope (peerId) {\n    log('getRawEnvelope await read lock')\n    const release = await this._store.lock.readLock()\n    log('getRawEnvelope got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.peerRecordEnvelope\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('getRawEnvelope release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Get an Envelope containing a PeerRecord for the given peer.\n   * Returns undefined if no record exists.\n   *\n   * @param {PeerId} peerId\n   */\n  async getPeerRecord (peerId) {\n    const raw = await this.getRawEnvelope(peerId)\n\n    if (!raw) {\n      return undefined\n    }\n\n    return Envelope.createFromProtobuf(raw)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('get wait for read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      const peer = await this._store.load(peerId)\n\n      return peer.addresses\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n    } finally {\n      log('get release read lock')\n      release()\n    }\n\n    return []\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n  async set (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('set await write lock')\n    const release = await this._store.lock.writeLock()\n    log('set got write lock')\n\n    let hasPeer = false\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter)\n\n      // No valid addresses found\n      if (!addresses.length) {\n        return\n      }\n\n      try {\n        const peer = await this._store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length && addresses.length === peer.addresses.length) {\n          // not changing anything, no need to update\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.patchOrCreate(peerId, { addresses })\n\n      log(`set multiaddrs for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr) })\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this._emit('peer', peerId)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Multiaddr[]} multiaddrs\n   */\n  async add (peerId, multiaddrs) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    if (!Array.isArray(multiaddrs)) {\n      log.error('multiaddrs must be an array of Multiaddrs')\n      throw errcode(new Error('multiaddrs must be an array of Multiaddrs'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('add await write lock')\n    const release = await this._store.lock.writeLock()\n    log('add got write lock')\n\n    let hasPeer\n    let updatedPeer\n\n    try {\n      const addresses = await filterMultiaddrs(peerId, multiaddrs, this._addressFilter)\n\n      // No valid addresses found\n      if (!addresses.length) {\n        return\n      }\n\n      try {\n        const peer = await this._store.load(peerId)\n        hasPeer = true\n\n        if (new Set([\n          ...addresses.map(({ multiaddr }) => multiaddr.toString()),\n          ...peer.addresses.map(({ multiaddr }) => multiaddr.toString())\n        ]).size === peer.addresses.length) {\n          return\n        }\n      } catch (/** @type {any} */ err) {\n        if (err.code !== codes.ERR_NOT_FOUND) {\n          throw err\n        }\n      }\n\n      updatedPeer = await this._store.mergeOrCreate(peerId, { addresses })\n\n      log(`added multiaddrs for ${peerId.toB58String()}`)\n    } finally {\n      log('set release write lock')\n      release()\n    }\n\n    this._emit(EVENT_NAME, { peerId, multiaddrs: updatedPeer.addresses.map(addr => addr.multiaddr) })\n\n    // Notify the existence of a new peer\n    if (!hasPeer) {\n      this._emit('peer', peerId)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n\n    let has\n\n    try {\n      has = await this._store.has(peerId)\n\n      await this._store.patchOrCreate(peerId, {\n        addresses: []\n      })\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n\n    if (has) {\n      this._emit(EVENT_NAME, { peerId, multiaddrs: [] })\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {(addresses: Address[]) => Address[]} [addressSorter]\n   */\n  async getMultiaddrsForPeer (peerId, addressSorter = (ms) => ms) {\n    const addresses = await this.get(peerId)\n\n    return addressSorter(\n      addresses\n    ).map((address) => {\n      const multiaddr = address.multiaddr\n\n      const idString = multiaddr.getPeerId()\n      if (idString && idString === peerId.toB58String()) return multiaddr\n\n      return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`)\n    })\n  }\n}\n\n/**\n * @param {PeerId} peerId\n * @param {Multiaddr[]} multiaddrs\n * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} addressFilter\n * @param {boolean} isCertified\n */\nfunction filterMultiaddrs (peerId, multiaddrs, addressFilter, isCertified = false) {\n  return pipe(\n    multiaddrs,\n    (source) => each(source, (multiaddr) => {\n      if (!Multiaddr.isMultiaddr(multiaddr)) {\n        log.error('multiaddr must be an instance of Multiaddr')\n        throw errcode(new Error('multiaddr must be an instance of Multiaddr'), codes.ERR_INVALID_PARAMETERS)\n      }\n    }),\n    (source) => filter(source, (multiaddr) => addressFilter(peerId, multiaddr)),\n    (source) => map(source, (multiaddr) => {\n      return {\n        multiaddr: new Multiaddr(multiaddr.toString()),\n        isCertified\n      }\n    }),\n    (source) => all(source)\n  )\n}\n\nmodule.exports = PeerStoreAddressBook\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}