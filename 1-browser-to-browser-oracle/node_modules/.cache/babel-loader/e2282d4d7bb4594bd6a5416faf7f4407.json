{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObservablePromise = void 0;\n\nconst observable_fns_1 = require(\"observable-fns\");\n\nconst doNothing = () => undefined;\n\nconst returnInput = input => input;\n\nconst runDeferred = fn => Promise.resolve().then(fn);\n\nfunction fail(error) {\n  throw error;\n}\n\nfunction isThenable(thing) {\n  return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\n\n\nclass ObservablePromise extends observable_fns_1.Observable {\n  constructor(init) {\n    super(originalObserver => {\n      // tslint:disable-next-line no-this-assignment\n      const self = this;\n      const observer = Object.assign(Object.assign({}, originalObserver), {\n        complete() {\n          originalObserver.complete();\n          self.onCompletion();\n        },\n\n        error(error) {\n          originalObserver.error(error);\n          self.onError(error);\n        },\n\n        next(value) {\n          originalObserver.next(value);\n          self.onNext(value);\n        }\n\n      });\n\n      try {\n        this.initHasRun = true;\n        return init(observer);\n      } catch (error) {\n        observer.error(error);\n      }\n    });\n    this.initHasRun = false;\n    this.fulfillmentCallbacks = [];\n    this.rejectionCallbacks = [];\n    this.firstValueSet = false;\n    this.state = \"pending\";\n  }\n\n  onNext(value) {\n    if (!this.firstValueSet) {\n      this.firstValue = value;\n      this.firstValueSet = true;\n    }\n  }\n\n  onError(error) {\n    this.state = \"rejected\";\n    this.rejection = error;\n\n    for (const onRejected of this.rejectionCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onRejected(error));\n    }\n  }\n\n  onCompletion() {\n    this.state = \"fulfilled\";\n\n    for (const onFulfilled of this.fulfillmentCallbacks) {\n      // Promisifying the call to turn errors into unhandled promise rejections\n      // instead of them failing sync and cancelling the iteration\n      runDeferred(() => onFulfilled(this.firstValue));\n    }\n  }\n\n  then(onFulfilledRaw, onRejectedRaw) {\n    const onFulfilled = onFulfilledRaw || returnInput;\n    const onRejected = onRejectedRaw || fail;\n    let onRejectedCalled = false;\n    return new Promise((resolve, reject) => {\n      const rejectionCallback = error => {\n        if (onRejectedCalled) return;\n        onRejectedCalled = true;\n\n        try {\n          resolve(onRejected(error));\n        } catch (anotherError) {\n          reject(anotherError);\n        }\n      };\n\n      const fulfillmentCallback = value => {\n        try {\n          resolve(onFulfilled(value));\n        } catch (error) {\n          rejectionCallback(error);\n        }\n      };\n\n      if (!this.initHasRun) {\n        this.subscribe({\n          error: rejectionCallback\n        });\n      }\n\n      if (this.state === \"fulfilled\") {\n        return resolve(onFulfilled(this.firstValue));\n      }\n\n      if (this.state === \"rejected\") {\n        onRejectedCalled = true;\n        return resolve(onRejected(this.rejection));\n      }\n\n      this.fulfillmentCallbacks.push(fulfillmentCallback);\n      this.rejectionCallbacks.push(rejectionCallback);\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(undefined, onRejected);\n  }\n\n  finally(onCompleted) {\n    const handler = onCompleted || doNothing;\n    return this.then(value => {\n      handler();\n      return value;\n    }, () => handler());\n  }\n\n  static from(thing) {\n    if (isThenable(thing)) {\n      return new ObservablePromise(observer => {\n        const onFulfilled = value => {\n          observer.next(value);\n          observer.complete();\n        };\n\n        const onRejected = error => {\n          observer.error(error);\n        };\n\n        thing.then(onFulfilled, onRejected);\n      });\n    } else {\n      return super.from(thing);\n    }\n  }\n\n}\n\nexports.ObservablePromise = ObservablePromise;","map":{"version":3,"names":["Object","defineProperty","exports","value","ObservablePromise","observable_fns_1","require","doNothing","undefined","returnInput","input","runDeferred","fn","Promise","resolve","then","fail","error","isThenable","thing","Observable","constructor","init","originalObserver","self","observer","assign","complete","onCompletion","onError","next","onNext","initHasRun","fulfillmentCallbacks","rejectionCallbacks","firstValueSet","state","firstValue","rejection","onRejected","onFulfilled","onFulfilledRaw","onRejectedRaw","onRejectedCalled","reject","rejectionCallback","anotherError","fulfillmentCallback","subscribe","push","catch","finally","onCompleted","handler","from"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/threads/dist/observable-promise.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ObservablePromise = void 0;\nconst observable_fns_1 = require(\"observable-fns\");\nconst doNothing = () => undefined;\nconst returnInput = (input) => input;\nconst runDeferred = (fn) => Promise.resolve().then(fn);\nfunction fail(error) {\n    throw error;\n}\nfunction isThenable(thing) {\n    return thing && typeof thing.then === \"function\";\n}\n/**\n * Creates a hybrid, combining the APIs of an Observable and a Promise.\n *\n * It is used to proxy async process states when we are initially not sure\n * if that async process will yield values once (-> Promise) or multiple\n * times (-> Observable).\n *\n * Note that the observable promise inherits some of the observable's characteristics:\n * The `init` function will be called *once for every time anyone subscribes to it*.\n *\n * If this is undesired, derive a hot observable from it using `makeHot()` and\n * subscribe to that.\n */\nclass ObservablePromise extends observable_fns_1.Observable {\n    constructor(init) {\n        super((originalObserver) => {\n            // tslint:disable-next-line no-this-assignment\n            const self = this;\n            const observer = Object.assign(Object.assign({}, originalObserver), { complete() {\n                    originalObserver.complete();\n                    self.onCompletion();\n                }, error(error) {\n                    originalObserver.error(error);\n                    self.onError(error);\n                },\n                next(value) {\n                    originalObserver.next(value);\n                    self.onNext(value);\n                } });\n            try {\n                this.initHasRun = true;\n                return init(observer);\n            }\n            catch (error) {\n                observer.error(error);\n            }\n        });\n        this.initHasRun = false;\n        this.fulfillmentCallbacks = [];\n        this.rejectionCallbacks = [];\n        this.firstValueSet = false;\n        this.state = \"pending\";\n    }\n    onNext(value) {\n        if (!this.firstValueSet) {\n            this.firstValue = value;\n            this.firstValueSet = true;\n        }\n    }\n    onError(error) {\n        this.state = \"rejected\";\n        this.rejection = error;\n        for (const onRejected of this.rejectionCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onRejected(error));\n        }\n    }\n    onCompletion() {\n        this.state = \"fulfilled\";\n        for (const onFulfilled of this.fulfillmentCallbacks) {\n            // Promisifying the call to turn errors into unhandled promise rejections\n            // instead of them failing sync and cancelling the iteration\n            runDeferred(() => onFulfilled(this.firstValue));\n        }\n    }\n    then(onFulfilledRaw, onRejectedRaw) {\n        const onFulfilled = onFulfilledRaw || returnInput;\n        const onRejected = onRejectedRaw || fail;\n        let onRejectedCalled = false;\n        return new Promise((resolve, reject) => {\n            const rejectionCallback = (error) => {\n                if (onRejectedCalled)\n                    return;\n                onRejectedCalled = true;\n                try {\n                    resolve(onRejected(error));\n                }\n                catch (anotherError) {\n                    reject(anotherError);\n                }\n            };\n            const fulfillmentCallback = (value) => {\n                try {\n                    resolve(onFulfilled(value));\n                }\n                catch (error) {\n                    rejectionCallback(error);\n                }\n            };\n            if (!this.initHasRun) {\n                this.subscribe({ error: rejectionCallback });\n            }\n            if (this.state === \"fulfilled\") {\n                return resolve(onFulfilled(this.firstValue));\n            }\n            if (this.state === \"rejected\") {\n                onRejectedCalled = true;\n                return resolve(onRejected(this.rejection));\n            }\n            this.fulfillmentCallbacks.push(fulfillmentCallback);\n            this.rejectionCallbacks.push(rejectionCallback);\n        });\n    }\n    catch(onRejected) {\n        return this.then(undefined, onRejected);\n    }\n    finally(onCompleted) {\n        const handler = onCompleted || doNothing;\n        return this.then((value) => {\n            handler();\n            return value;\n        }, () => handler());\n    }\n    static from(thing) {\n        if (isThenable(thing)) {\n            return new ObservablePromise(observer => {\n                const onFulfilled = (value) => {\n                    observer.next(value);\n                    observer.complete();\n                };\n                const onRejected = (error) => {\n                    observer.error(error);\n                };\n                thing.then(onFulfilled, onRejected);\n            });\n        }\n        else {\n            return super.from(thing);\n        }\n    }\n}\nexports.ObservablePromise = ObservablePromise;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}