{"ast":null,"code":"'use strict'; // @ts-expect-error no types\n\nconst Reader = require('it-reader');\n\nconst debug = require('debug');\n\nconst multistream = require('./multistream'); // @ts-expect-error no types\n\n\nconst handshake = require('it-handshake');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst log = Object.assign(debug('mss:ls'), {\n  error: debug('mss:ls:error')\n});\n/**\n * @typedef {import('bl/BufferList')} BufferList\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {AbortOptions} [options]\n */\n\nmodule.exports = async function ls(stream, options) {\n  const {\n    reader,\n    writer,\n    rest,\n    stream: shakeStream\n  } = handshake(stream);\n  log('write \"ls\"');\n  multistream.write(writer, 'ls');\n  rest(); // Next message from remote will be (e.g. for 2 protocols):\n  // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n  const res = await multistream.read(reader, options); // After reading response we have:\n  // <varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n\n  const protocolsReader = Reader([res]);\n  /**\n   * @type {string[]}\n   */\n\n  const protocols = []; // Decode each of the protocols from the reader\n\n  await pipe(protocolsReader, lp.decode(), async (\n  /** @type {AsyncIterable<BufferList>} */\n  source) => {\n    for await (const protocol of source) {\n      // Remove the newline\n      protocols.push(protocol.shallowSlice(0, -1).toString());\n    }\n  });\n  /** @type {{ stream: DuplexStream, protocols: string[] }} */\n\n  const output = {\n    stream: shakeStream,\n    protocols\n  };\n  return output;\n};","map":{"version":3,"names":["Reader","require","debug","multistream","handshake","lp","pipe","log","Object","assign","error","module","exports","ls","stream","options","reader","writer","rest","shakeStream","write","res","read","protocolsReader","protocols","decode","source","protocol","push","shallowSlice","toString","output"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/multistream-select/src/ls.js"],"sourcesContent":["'use strict'\n\n// @ts-expect-error no types\nconst Reader = require('it-reader')\nconst debug = require('debug')\nconst multistream = require('./multistream')\n// @ts-expect-error no types\nconst handshake = require('it-handshake')\nconst lp = require('it-length-prefixed')\nconst { pipe } = require('it-pipe')\n\nconst log = Object.assign(debug('mss:ls'), {\n  error: debug('mss:ls:error')\n})\n\n/**\n * @typedef {import('bl/BufferList')} BufferList\n * @typedef {import('./types').DuplexStream<Uint8Array | BufferList>} DuplexStream\n * @typedef {import('./types').AbortOptions} AbortOptions\n */\n\n/**\n * @param {DuplexStream} stream\n * @param {AbortOptions} [options]\n */\nmodule.exports = async function ls (stream, options) {\n  const { reader, writer, rest, stream: shakeStream } = handshake(stream)\n\n  log('write \"ls\"')\n  multistream.write(writer, 'ls')\n  rest()\n\n  // Next message from remote will be (e.g. for 2 protocols):\n  // <varint-msg-len><varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n  const res = await multistream.read(reader, options)\n\n  // After reading response we have:\n  // <varint-proto-name-len><proto-name>\\n<varint-proto-name-len><proto-name>\\n\n  const protocolsReader = Reader([res])\n\n  /**\n   * @type {string[]}\n   */\n  const protocols = []\n\n  // Decode each of the protocols from the reader\n  await pipe(\n    protocolsReader,\n    lp.decode(),\n    async (/** @type {AsyncIterable<BufferList>} */ source) => {\n      for await (const protocol of source) {\n        // Remove the newline\n        protocols.push(protocol.shallowSlice(0, -1).toString())\n      }\n    }\n  )\n\n  /** @type {{ stream: DuplexStream, protocols: string[] }} */\n  const output = { stream: shakeStream, protocols }\n\n  return output\n}\n"],"mappings":"AAAA,a,CAEA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAD,CAArB;;AACA,MAAME,WAAW,GAAGF,OAAO,CAAC,eAAD,CAA3B,C,CACA;;;AACA,MAAMG,SAAS,GAAGH,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAMI,EAAE,GAAGJ,OAAO,CAAC,oBAAD,CAAlB;;AACA,MAAM;EAAEK;AAAF,IAAWL,OAAO,CAAC,SAAD,CAAxB;;AAEA,MAAMM,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcP,KAAK,CAAC,QAAD,CAAnB,EAA+B;EACzCQ,KAAK,EAAER,KAAK,CAAC,cAAD;AAD6B,CAA/B,CAAZ;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACAS,MAAM,CAACC,OAAP,GAAiB,eAAeC,EAAf,CAAmBC,MAAnB,EAA2BC,OAA3B,EAAoC;EACnD,MAAM;IAAEC,MAAF;IAAUC,MAAV;IAAkBC,IAAlB;IAAwBJ,MAAM,EAAEK;EAAhC,IAAgDf,SAAS,CAACU,MAAD,CAA/D;EAEAP,GAAG,CAAC,YAAD,CAAH;EACAJ,WAAW,CAACiB,KAAZ,CAAkBH,MAAlB,EAA0B,IAA1B;EACAC,IAAI,GAL+C,CAOnD;EACA;;EACA,MAAMG,GAAG,GAAG,MAAMlB,WAAW,CAACmB,IAAZ,CAAiBN,MAAjB,EAAyBD,OAAzB,CAAlB,CATmD,CAWnD;EACA;;EACA,MAAMQ,eAAe,GAAGvB,MAAM,CAAC,CAACqB,GAAD,CAAD,CAA9B;EAEA;AACF;AACA;;EACE,MAAMG,SAAS,GAAG,EAAlB,CAlBmD,CAoBnD;;EACA,MAAMlB,IAAI,CACRiB,eADQ,EAERlB,EAAE,CAACoB,MAAH,EAFQ,EAGR;EAAO;EAAyCC,MAAhD,KAA2D;IACzD,WAAW,MAAMC,QAAjB,IAA6BD,MAA7B,EAAqC;MACnC;MACAF,SAAS,CAACI,IAAV,CAAeD,QAAQ,CAACE,YAAT,CAAsB,CAAtB,EAAyB,CAAC,CAA1B,EAA6BC,QAA7B,EAAf;IACD;EACF,CARO,CAAV;EAWA;;EACA,MAAMC,MAAM,GAAG;IAAEjB,MAAM,EAAEK,WAAV;IAAuBK;EAAvB,CAAf;EAEA,OAAOO,MAAP;AACD,CApCD"},"metadata":{},"sourceType":"script"}