{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:fetch'), {\n  error: debug('libp2p:fetch:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst lp = require('it-length-prefixed');\n\nconst {\n  FetchRequest,\n  FetchResponse\n} = require('./proto'); // @ts-ignore it-handshake does not export types\n\n\nconst handshake = require('it-handshake');\n\nconst {\n  PROTOCOL\n} = require('./constants');\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {(key: string) => Promise<Uint8Array | null>} LookupFunction\n */\n\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\n\n\nclass FetchProtocol {\n  /**\n   * @param {Libp2p} libp2p\n   */\n  constructor(libp2p) {\n    this._lookupFunctions = new Map(); // Maps key prefix to value lookup function\n\n    this._libp2p = libp2p;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {string} key\n   * @returns {Promise<Uint8Array | null>}\n   */\n\n\n  async fetch(peer, key) {\n    // @ts-ignore multiaddr might not have toB58String\n    log('dialing %s to %s', this._protocol, peer.toB58String ? peer.toB58String() : peer);\n    const connection = await this._libp2p.dial(peer);\n    const {\n      stream\n    } = await connection.newStream(FetchProtocol.PROTOCOL);\n    const shake = handshake(stream); // send message\n\n    const request = new FetchRequest({\n      identifier: key\n    });\n    shake.write(lp.encode.single(FetchRequest.encode(request).finish())); // read response\n\n    const response = FetchResponse.decode((await lp.decode.fromReader(shake.reader).next()).value.slice());\n\n    switch (response.status) {\n      case FetchResponse.StatusCode.OK:\n        {\n          return response.data;\n        }\n\n      case FetchResponse.StatusCode.NOT_FOUND:\n        {\n          return null;\n        }\n\n      case FetchResponse.StatusCode.ERROR:\n        {\n          const errmsg = new TextDecoder().decode(response.data);\n          throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS);\n        }\n\n      default:\n        {\n          throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE);\n        }\n    }\n  }\n  /**\n   * Invoked when a fetch request is received.  Reads the request message off the given stream and\n   * responds based on looking up the key in the request via the lookup callback that corresponds\n   * to the key's prefix.\n   *\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  async handleMessage(options) {\n    const {\n      stream\n    } = options;\n    const shake = handshake(stream);\n    const request = FetchRequest.decode((await lp.decode.fromReader(shake.reader).next()).value.slice());\n    let response;\n\n    const lookup = this._getLookupFunction(request.identifier);\n\n    if (lookup) {\n      const data = await lookup(request.identifier);\n\n      if (data) {\n        response = new FetchResponse({\n          status: FetchResponse.StatusCode.OK,\n          data\n        });\n      } else {\n        response = new FetchResponse({\n          status: FetchResponse.StatusCode.NOT_FOUND\n        });\n      }\n    } else {\n      const errmsg = new TextEncoder().encode('No lookup function registered for key: ' + request.identifier);\n      response = new FetchResponse({\n        status: FetchResponse.StatusCode.ERROR,\n        data: errmsg\n      });\n    }\n\n    shake.write(lp.encode.single(FetchResponse.encode(response).finish()));\n  }\n  /**\n   * Given a key, finds the appropriate function for looking up its corresponding value, based on\n   * the key's prefix.\n   *\n   * @param {string} key\n   */\n\n\n  _getLookupFunction(key) {\n    for (const prefix of this._lookupFunctions.keys()) {\n      if (key.startsWith(prefix)) {\n        return this._lookupFunctions.get(prefix);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @param {string} prefix\n   * @param {LookupFunction} lookup\n   */\n\n\n  registerLookupFunction(prefix, lookup) {\n    if (this._lookupFunctions.has(prefix)) {\n      throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS);\n    }\n\n    this._lookupFunctions.set(prefix, lookup);\n  }\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @param {string} prefix\n   * @param {LookupFunction} [lookup]\n   */\n\n\n  unregisterLookupFunction(prefix, lookup) {\n    if (lookup != null) {\n      const existingLookup = this._lookupFunctions.get(prefix);\n\n      if (existingLookup !== lookup) {\n        return;\n      }\n    }\n\n    this._lookupFunctions.delete(prefix);\n  }\n\n}\n\nFetchProtocol.PROTOCOL = PROTOCOL;\nexports = module.exports = FetchProtocol;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","codes","lp","FetchRequest","FetchResponse","handshake","PROTOCOL","FetchProtocol","constructor","libp2p","_lookupFunctions","Map","_libp2p","handleMessage","bind","fetch","peer","key","_protocol","toB58String","connection","dial","stream","newStream","shake","request","identifier","write","encode","single","finish","response","decode","fromReader","reader","next","value","slice","status","StatusCode","OK","data","NOT_FOUND","ERROR","errmsg","TextDecoder","Error","ERR_INVALID_PARAMETERS","ERR_INVALID_MESSAGE","options","lookup","_getLookupFunction","TextEncoder","prefix","keys","startsWith","get","registerLookupFunction","has","ERR_KEY_ALREADY_EXISTS","set","unregisterLookupFunction","existingLookup","delete","exports","module"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/fetch/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:fetch'), {\n  error: debug('libp2p:fetch:err')\n})\nconst errCode = require('err-code')\nconst { codes } = require('../errors')\nconst lp = require('it-length-prefixed')\nconst { FetchRequest, FetchResponse } = require('./proto')\n// @ts-ignore it-handshake does not export types\nconst handshake = require('it-handshake')\nconst { PROTOCOL } = require('./constants')\n\n/**\n * @typedef {import('../')} Libp2p\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {(key: string) => Promise<Uint8Array | null>} LookupFunction\n */\n\n/**\n * A simple libp2p protocol for requesting a value corresponding to a key from a peer.\n * Developers can register one or more lookup function for retrieving the value corresponding to\n * a given key.  Each lookup function must act on a distinct part of the overall key space, defined\n * by a fixed prefix that all keys that should be routed to that lookup function will start with.\n */\nclass FetchProtocol {\n  /**\n   * @param {Libp2p} libp2p\n   */\n  constructor (libp2p) {\n    this._lookupFunctions = new Map() // Maps key prefix to value lookup function\n    this._libp2p = libp2p\n    this.handleMessage = this.handleMessage.bind(this)\n  }\n\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {string} key\n   * @returns {Promise<Uint8Array | null>}\n   */\n  async fetch (peer, key) {\n    // @ts-ignore multiaddr might not have toB58String\n    log('dialing %s to %s', this._protocol, peer.toB58String ? peer.toB58String() : peer)\n\n    const connection = await this._libp2p.dial(peer)\n    const { stream } = await connection.newStream(FetchProtocol.PROTOCOL)\n    const shake = handshake(stream)\n\n    // send message\n    const request = new FetchRequest({ identifier: key })\n    shake.write(lp.encode.single(FetchRequest.encode(request).finish()))\n\n    // read response\n    const response = FetchResponse.decode((await lp.decode.fromReader(shake.reader).next()).value.slice())\n    switch (response.status) {\n      case (FetchResponse.StatusCode.OK): {\n        return response.data\n      }\n      case (FetchResponse.StatusCode.NOT_FOUND): {\n        return null\n      }\n      case (FetchResponse.StatusCode.ERROR): {\n        const errmsg = (new TextDecoder()).decode(response.data)\n        throw errCode(new Error('Error in fetch protocol response: ' + errmsg), codes.ERR_INVALID_PARAMETERS)\n      }\n      default: {\n        throw errCode(new Error('Unknown response status'), codes.ERR_INVALID_MESSAGE)\n      }\n    }\n  }\n\n  /**\n   * Invoked when a fetch request is received.  Reads the request message off the given stream and\n   * responds based on looking up the key in the request via the lookup callback that corresponds\n   * to the key's prefix.\n   *\n   * @param {object} options\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  async handleMessage (options) {\n    const { stream } = options\n    const shake = handshake(stream)\n    const request = FetchRequest.decode((await lp.decode.fromReader(shake.reader).next()).value.slice())\n\n    let response\n    const lookup = this._getLookupFunction(request.identifier)\n    if (lookup) {\n      const data = await lookup(request.identifier)\n      if (data) {\n        response = new FetchResponse({ status: FetchResponse.StatusCode.OK, data })\n      } else {\n        response = new FetchResponse({ status: FetchResponse.StatusCode.NOT_FOUND })\n      }\n    } else {\n      const errmsg = (new TextEncoder()).encode('No lookup function registered for key: ' + request.identifier)\n      response = new FetchResponse({ status: FetchResponse.StatusCode.ERROR, data: errmsg })\n    }\n\n    shake.write(lp.encode.single(FetchResponse.encode(response).finish()))\n  }\n\n  /**\n   * Given a key, finds the appropriate function for looking up its corresponding value, based on\n   * the key's prefix.\n   *\n   * @param {string} key\n   */\n  _getLookupFunction (key) {\n    for (const prefix of this._lookupFunctions.keys()) {\n      if (key.startsWith(prefix)) {\n        return this._lookupFunctions.get(prefix)\n      }\n    }\n    return null\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @param {string} prefix\n   * @param {LookupFunction} lookup\n   */\n  registerLookupFunction (prefix, lookup) {\n    if (this._lookupFunctions.has(prefix)) {\n      throw errCode(new Error(\"Fetch protocol handler for key prefix '\" + prefix + \"' already registered\"), codes.ERR_KEY_ALREADY_EXISTS)\n    }\n    this._lookupFunctions.set(prefix, lookup)\n  }\n\n  /**\n   * Registers a new lookup callback that can map keys to values, for a given set of keys that\n   * share the same prefix.\n   *\n   * @param {string} prefix\n   * @param {LookupFunction} [lookup]\n   */\n  unregisterLookupFunction (prefix, lookup) {\n    if (lookup != null) {\n      const existingLookup = this._lookupFunctions.get(prefix)\n\n      if (existingLookup !== lookup) {\n        return\n      }\n    }\n\n    this._lookupFunctions.delete(prefix)\n  }\n}\n\nFetchProtocol.PROTOCOL = PROTOCOL\n\nexports = module.exports = FetchProtocol\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}