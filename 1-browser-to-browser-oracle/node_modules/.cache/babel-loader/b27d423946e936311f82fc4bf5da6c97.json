{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.XXHandshake = void 0;\n\nconst buffer_1 = require(\"buffer\");\n\nconst xx_1 = require(\"./handshakes/xx\");\n\nconst utils_1 = require(\"./utils\");\n\nconst logger_1 = require(\"./logger\");\n\nconst encoder_1 = require(\"./encoder\");\n\nclass XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = buffer_1.Buffer.alloc(0);\n  } // stage 0\n\n\n  async propose() {\n    logger_1.logLocalStaticKeys(this.session.hs.s);\n\n    if (this.isInitiator) {\n      logger_1.logger('Stage 0 - Initiator starting to send first message.');\n      const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));\n      this.connection.writeLP(encoder_1.encode0(messageBuffer));\n      logger_1.logger('Stage 0 - Initiator finished sending first message.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger_1.logger('Stage 0 - Responder waiting to receive first message...');\n      const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 0 validation fail');\n      }\n\n      logger_1.logger('Stage 0 - Responder received first message.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      logger_1.logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 1 validation fail');\n      }\n\n      logger_1.logger('Stage 1 - Initiator received the message.');\n      logger_1.logRemoteEphemeralKey(this.session.hs.re);\n      logger_1.logRemoteStaticKey(this.session.hs.rs);\n      logger_1.logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        this.remotePeer = await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n\n      logger_1.logger('All good with the signature!');\n    } else {\n      logger_1.logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode1(messageBuffer));\n      logger_1.logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n      logger_1.logLocalEphemeralKeys(this.session.hs.e);\n    }\n  } // stage 2\n\n\n  async finish() {\n    if (this.isInitiator) {\n      logger_1.logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encoder_1.encode2(messageBuffer));\n      logger_1.logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger_1.logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error('xx handshake stage 2 validation fail');\n      }\n\n      logger_1.logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await utils_1.decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await utils_1.getPeerIdFromPayload(decodedPayload));\n        await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        const err = e;\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`);\n      }\n    }\n\n    logger_1.logCipherState(this.session);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session) {\n    let encryption = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.');\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}\n\nexports.XXHandshake = XXHandshake;","map":{"version":3,"mappings":"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","names":["XXHandshake","constructor","isInitiator","payload","prologue","staticKeypair","connection","remotePeer","handshake","xx","xx_1","session","initSession","remoteEarlyData","buffer_1","alloc","propose","logger_1","hs","s","messageBuffer","sendMessage","writeLP","encoder_1","e","receivedMessageBuffer","readLP","slice","valid","recvMessage","Error","re","exchange","plaintext","rs","decodedPayload","utils_1","setRemoteEarlyData","data","err","message","finish","encrypt","cs","getCS","encryptWithAd","decrypt","ciphertext","decryptWithAd","getRemoteStaticKey","encryption","cs1","cs2","from","buffer","byteOffset","length","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@chainsafe/libp2p-noise/src/handshake-xx.ts"],"sourcesContent":["import { Buffer } from 'buffer'\n\nimport { XX } from './handshakes/xx'\nimport { KeyPair } from './@types/libp2p'\nimport { bytes, bytes32 } from './@types/basic'\nimport { NoiseSession } from './@types/handshake'\nimport { IHandshake } from './@types/handshake-interface'\nimport {\n  decodePayload,\n  getPeerIdFromPayload,\n  verifySignedPayload\n} from './utils'\nimport {\n  logger,\n  logLocalStaticKeys,\n  logLocalEphemeralKeys,\n  logRemoteEphemeralKey,\n  logRemoteStaticKey,\n  logCipherState\n} from './logger'\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from './encoder'\nimport { WrappedConnection } from './noise'\nimport PeerId from 'peer-id'\n\nexport class XXHandshake implements IHandshake {\n  public isInitiator: boolean\n  public session: NoiseSession\n  public remotePeer!: PeerId\n  public remoteEarlyData: Buffer\n\n  protected payload: bytes\n  protected connection: WrappedConnection\n  protected xx: XX\n  protected staticKeypair: KeyPair\n\n  private readonly prologue: bytes32\n\n  constructor (\n    isInitiator: boolean,\n    payload: bytes,\n    prologue: bytes32,\n    staticKeypair: KeyPair,\n    connection: WrappedConnection,\n    remotePeer?: PeerId,\n    handshake?: XX\n  ) {\n    this.isInitiator = isInitiator\n    this.payload = payload\n    this.prologue = prologue\n    this.staticKeypair = staticKeypair\n    this.connection = connection\n    if (remotePeer) {\n      this.remotePeer = remotePeer\n    }\n    this.xx = handshake ?? new XX()\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)\n    this.remoteEarlyData = Buffer.alloc(0)\n  }\n\n  // stage 0\n  public async propose (): Promise<void> {\n    logLocalStaticKeys(this.session.hs.s)\n    if (this.isInitiator) {\n      logger('Stage 0 - Initiator starting to send first message.')\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0))\n      this.connection.writeLP(encode0(messageBuffer))\n      logger('Stage 0 - Initiator finished sending first message.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    } else {\n      logger('Stage 0 - Responder waiting to receive first message...')\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice())\n      const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 0 validation fail')\n      }\n      logger('Stage 0 - Responder received first message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n    }\n  }\n\n  // stage 1\n  public async exchange (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...')\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 1 validation fail')\n      }\n      logger('Stage 1 - Initiator received the message.')\n      logRemoteEphemeralKey(this.session.hs.re)\n      logRemoteStaticKey(this.session.hs.rs)\n\n      logger(\"Initiator going to check remote's signature...\")\n      try {\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        this.remotePeer = await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        const err = e as Error\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n      logger('All good with the signature!')\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode1(messageBuffer))\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.')\n      logLocalEphemeralKeys(this.session.hs.e)\n    }\n  }\n\n  // stage 2\n  public async finish (): Promise<void> {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.')\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload)\n      this.connection.writeLP(encode2(messageBuffer))\n      logger('Stage 2 - Initiator sent message with signed payload.')\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...')\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice())\n      const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer)\n      if (!valid) {\n        throw new Error('xx handshake stage 2 validation fail')\n      }\n      logger('Stage 2 - Responder received the message, finished handshake.')\n\n      try {\n        const decodedPayload = await decodePayload(plaintext)\n        this.remotePeer = this.remotePeer || await getPeerIdFromPayload(decodedPayload)\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer)\n        this.setRemoteEarlyData(decodedPayload.data)\n      } catch (e) {\n        const err = e as Error\n        throw new Error(`Error occurred while verifying signed payload: ${err.message}`)\n      }\n    }\n    logCipherState(this.session)\n  }\n\n  public encrypt (plaintext: bytes, session: NoiseSession): bytes {\n    const cs = this.getCS(session)\n\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext)\n  }\n\n  public decrypt (ciphertext: bytes, session: NoiseSession): {plaintext: bytes, valid: boolean} {\n    const cs = this.getCS(session, false)\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext)\n  }\n\n  public getRemoteStaticKey (): bytes {\n    return this.session.hs.rs\n  }\n\n  private getCS (session: NoiseSession, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error('Handshake not completed properly, cipher state does not exist.')\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2\n    } else {\n      return encryption ? session.cs2 : session.cs1\n    }\n  }\n\n  protected setRemoteEarlyData (data: Uint8Array|null|undefined): void {\n    if (data) {\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length)\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}