{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n});\n\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\nconst {\n  toString: uint8ArrayToString\n} = require('uint8arrays/to-string');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst all = require('it-all');\n\nconst {\n  relay: multicodec\n} = require('./multicodec');\n\nconst {\n  canHop\n} = require('./circuit/hop');\n\nconst {\n  namespaceToCid\n} = require('./utils');\n\nconst {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} = require('./constants');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor(_ref) {\n    let {\n      libp2p,\n      maxListeners = 1,\n      onError\n    } = _ref;\n    this._libp2p = libp2p;\n    this._peerId = libp2p.peerId;\n    this._peerStore = libp2p.peerStore;\n    this._connectionManager = libp2p.connectionManager;\n    this._transportManager = libp2p.transportManager;\n    this._addressSorter = libp2p.dialer.addressSorter;\n    this.maxListeners = maxListeners;\n    /**\n     * @type {Set<string>}\n     */\n\n    this._listenRelays = new Set();\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n\n    this._peerStore.on('change:protocols', this._onProtocolChange);\n\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected);\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n\n\n    this._onError = (error, msg) => {\n      log.error(msg || error);\n      onError && onError(error, msg);\n    };\n  }\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n\n\n  async _onProtocolChange(_ref2) {\n    let {\n      peerId,\n      protocols\n    } = _ref2;\n    const id = peerId.toB58String(); // Check if it has the protocol\n\n    const hasProtocol = protocols.find(protocol => protocol === multicodec); // If no protocol, check if we were keeping the peer before as a listenRelay\n\n    if (!hasProtocol && this._listenRelays.has(id)) {\n      await this._removeListenRelay(id);\n      return;\n    } else if (!hasProtocol || this._listenRelays.has(id)) {\n      return;\n    } // If protocol, check if can hop, store info in the metadataBook and listen on it\n\n\n    try {\n      const connection = this._connectionManager.get(peerId);\n\n      if (!connection) {\n        return;\n      } // Do not hop on a relayed connection\n\n\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`);\n        return;\n      }\n\n      const supportsHop = await canHop({\n        connection\n      });\n\n      if (supportsHop) {\n        await this._peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));\n        await this._addListenRelay(connection, id);\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      this._onError(err);\n    }\n  }\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   */\n\n\n  _onPeerDisconnected(connection) {\n    const peerId = connection.remotePeer;\n    const id = peerId.toB58String(); // Not listening on this relay\n\n    if (!this._listenRelays.has(id)) {\n      return;\n    }\n\n    this._removeListenRelay(id).catch(err => {\n      log.error(err);\n    });\n  }\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n\n\n  async _addListenRelay(connection, id) {\n    try {\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return;\n      } // Get peer known addresses and sort them per public addresses first\n\n\n      const remoteAddrs = await this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter); // Attempt to listen on relay\n\n      const result = await Promise.all(remoteAddrs.map(async addr => {\n        try {\n          // Announce multiaddrs will update on listen success by TransportManager event being triggered\n          await this._transportManager.listen([new Multiaddr(`${addr.toString()}/p2p-circuit`)]);\n          return true;\n        } catch (\n        /** @type {any} */\n        err) {\n          this._onError(err);\n        }\n\n        return false;\n      }));\n\n      if (result.includes(true)) {\n        this._listenRelays.add(id);\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      this._onError(err);\n\n      this._listenRelays.delete(id);\n    }\n  }\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   */\n\n\n  async _removeListenRelay(id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id]);\n    }\n  }\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   */\n\n\n  async _listenOnAvailableHopRelays() {\n    let peersToIgnore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return;\n    }\n\n    const knownHopsToDial = [];\n    const peers = await all(this._peerStore.getPeers()); // Check if we have known hop peers to use and attempt to listen on the already connected\n\n    for await (const {\n      id,\n      metadata\n    } of peers) {\n      const idStr = id.toB58String(); // Continue to next if listening on this or peer to ignore\n\n      if (this._listenRelays.has(idStr)) {\n        continue;\n      }\n\n      if (peersToIgnore.includes(idStr)) {\n        continue;\n      }\n\n      const supportsHop = metadata.get(HOP_METADATA_KEY); // Continue to next if it does not support Hop\n\n      if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue;\n      }\n\n      const connection = this._connectionManager.get(id); // If not connected, store for possible later use.\n\n\n      if (!connection) {\n        knownHopsToDial.push(id);\n        continue;\n      }\n\n      await this._addListenRelay(connection, idStr); // Check if already listening on enough relays\n\n      if (this._listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to listen on known peers that are not connected\n\n\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n      if (this._listenRelays.size >= this.maxListeners) {\n        return;\n      }\n    } // Try to find relays to hop on the network\n\n\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);\n\n      for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {\n        if (!provider.multiaddrs.length) {\n          continue;\n        }\n\n        const peerId = provider.id;\n        await this._peerStore.addressBook.add(peerId, provider.multiaddrs);\n        await this._tryToListenOnRelay(peerId); // Check if already listening on enough relays\n\n        if (this._listenRelays.size >= this.maxListeners) {\n          return;\n        }\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      this._onError(err);\n    }\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async _tryToListenOnRelay(peerId) {\n    try {\n      const connection = await this._libp2p.dial(peerId);\n      await this._addListenRelay(connection, peerId.toB58String());\n    } catch (\n    /** @type {any} */\n    err) {\n      this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`);\n    }\n  }\n\n}\n\nmodule.exports = AutoRelay;","map":{"version":3,"names":["debug","require","log","Object","assign","error","fromString","uint8ArrayFromString","toString","uint8ArrayToString","Multiaddr","all","relay","multicodec","canHop","namespaceToCid","CIRCUIT_PROTO_CODE","HOP_METADATA_KEY","HOP_METADATA_VALUE","RELAY_RENDEZVOUS_NS","AutoRelay","constructor","libp2p","maxListeners","onError","_libp2p","_peerId","peerId","_peerStore","peerStore","_connectionManager","connectionManager","_transportManager","transportManager","_addressSorter","dialer","addressSorter","_listenRelays","Set","_onProtocolChange","bind","_onPeerDisconnected","on","_onError","msg","protocols","id","toB58String","hasProtocol","find","protocol","has","_removeListenRelay","connection","get","remoteAddr","protoCodes","includes","supportsHop","metadataBook","setValue","_addListenRelay","err","remotePeer","catch","size","remoteAddrs","addressBook","getMultiaddrsForPeer","result","Promise","map","addr","listen","add","delete","_listenOnAvailableHopRelays","peersToIgnore","knownHopsToDial","peers","getPeers","metadata","idStr","push","_tryToListenOnRelay","cid","provider","contentRouting","findProviders","multiaddrs","length","dial","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/circuit/auto-relay.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:auto-relay'), {\n  error: debug('libp2p:auto-relay:err')\n})\n\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst { Multiaddr } = require('multiaddr')\nconst all = require('it-all')\n\nconst { relay: multicodec } = require('./multicodec')\nconst { canHop } = require('./circuit/hop')\nconst { namespaceToCid } = require('./utils')\nconst {\n  CIRCUIT_PROTO_CODE,\n  HOP_METADATA_KEY,\n  HOP_METADATA_VALUE,\n  RELAY_RENDEZVOUS_NS\n} = require('./constants')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('peer-id')} PeerId\n */\n\n/**\n * @typedef {Object} AutoRelayProperties\n * @property {import('../')} libp2p\n *\n * @typedef {Object} AutoRelayOptions\n * @property {number} [maxListeners = 1] - maximum number of relays to listen.\n * @property {(error: Error, msg?: string) => {}} [onError]\n */\n\nclass AutoRelay {\n  /**\n   * Creates an instance of AutoRelay.\n   *\n   * @class\n   * @param {AutoRelayProperties & AutoRelayOptions} props\n   */\n  constructor ({ libp2p, maxListeners = 1, onError }) {\n    this._libp2p = libp2p\n    this._peerId = libp2p.peerId\n    this._peerStore = libp2p.peerStore\n    this._connectionManager = libp2p.connectionManager\n    this._transportManager = libp2p.transportManager\n    this._addressSorter = libp2p.dialer.addressSorter\n\n    this.maxListeners = maxListeners\n\n    /**\n     * @type {Set<string>}\n     */\n    this._listenRelays = new Set()\n\n    this._onProtocolChange = this._onProtocolChange.bind(this)\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this)\n\n    this._peerStore.on('change:protocols', this._onProtocolChange)\n    this._connectionManager.on('peer:disconnect', this._onPeerDisconnected)\n\n    /**\n     * @param {Error} error\n     * @param {string} [msg]\n     */\n    this._onError = (error, msg) => {\n      log.error(msg || error)\n      onError && onError(error, msg)\n    }\n  }\n\n  /**\n   * Check if a peer supports the relay protocol.\n   * If the protocol is not supported, check if it was supported before and remove it as a listen relay.\n   * If the protocol is supported, check if the peer supports **HOP** and add it as a listener if\n   * inside the threshold.\n   *\n   * @param {Object} props\n   * @param {PeerId} props.peerId\n   * @param {string[]} props.protocols\n   * @returns {Promise<void>}\n   */\n  async _onProtocolChange ({ peerId, protocols }) {\n    const id = peerId.toB58String()\n\n    // Check if it has the protocol\n    const hasProtocol = protocols.find(protocol => protocol === multicodec)\n\n    // If no protocol, check if we were keeping the peer before as a listenRelay\n    if (!hasProtocol && this._listenRelays.has(id)) {\n      await this._removeListenRelay(id)\n      return\n    } else if (!hasProtocol || this._listenRelays.has(id)) {\n      return\n    }\n\n    // If protocol, check if can hop, store info in the metadataBook and listen on it\n    try {\n      const connection = this._connectionManager.get(peerId)\n      if (!connection) {\n        return\n      }\n\n      // Do not hop on a relayed connection\n      if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {\n        log(`relayed connection to ${id} will not be used to hop on`)\n        return\n      }\n\n      const supportsHop = await canHop({ connection })\n\n      if (supportsHop) {\n        await this._peerStore.metadataBook.setValue(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE))\n        await this._addListenRelay(connection, id)\n      }\n    } catch (/** @type {any} */ err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * Peer disconnects.\n   *\n   * @param {Connection} connection - connection to the peer\n   */\n  _onPeerDisconnected (connection) {\n    const peerId = connection.remotePeer\n    const id = peerId.toB58String()\n\n    // Not listening on this relay\n    if (!this._listenRelays.has(id)) {\n      return\n    }\n\n    this._removeListenRelay(id).catch(err => {\n      log.error(err)\n    })\n  }\n\n  /**\n   * Attempt to listen on the given relay connection.\n   *\n   * @private\n   * @param {Connection} connection - connection to the peer\n   * @param {string} id - peer identifier string\n   * @returns {Promise<void>}\n   */\n  async _addListenRelay (connection, id) {\n    try {\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n\n      // Get peer known addresses and sort them per public addresses first\n      const remoteAddrs = await this._peerStore.addressBook.getMultiaddrsForPeer(\n        connection.remotePeer, this._addressSorter\n      )\n\n      // Attempt to listen on relay\n      const result = await Promise.all(\n        remoteAddrs.map(async addr => {\n          try {\n            // Announce multiaddrs will update on listen success by TransportManager event being triggered\n            await this._transportManager.listen([new Multiaddr(`${addr.toString()}/p2p-circuit`)])\n            return true\n          } catch (/** @type {any} */ err) {\n            this._onError(err)\n          }\n\n          return false\n        })\n      )\n\n      if (result.includes(true)) {\n        this._listenRelays.add(id)\n      }\n    } catch (/** @type {any} */ err) {\n      this._onError(err)\n      this._listenRelays.delete(id)\n    }\n  }\n\n  /**\n   * Remove listen relay.\n   *\n   * @private\n   * @param {string} id - peer identifier string.\n   */\n  async _removeListenRelay (id) {\n    if (this._listenRelays.delete(id)) {\n      // TODO: this should be responsibility of the connMgr\n      await this._listenOnAvailableHopRelays([id])\n    }\n  }\n\n  /**\n   * Try to listen on available hop relay connections.\n   * The following order will happen while we do not have enough relays.\n   * 1. Check the metadata store for known relays, try to listen on the ones we are already connected.\n   * 2. Dial and try to listen on the peers we know that support hop but are not connected.\n   * 3. Search the network.\n   *\n   * @param {string[]} [peersToIgnore]\n   */\n  async _listenOnAvailableHopRelays (peersToIgnore = []) {\n    // TODO: The peer redial issue on disconnect should be handled by connection gating\n    // Check if already listening on enough relays\n    if (this._listenRelays.size >= this.maxListeners) {\n      return\n    }\n\n    const knownHopsToDial = []\n    const peers = await all(this._peerStore.getPeers())\n\n    // Check if we have known hop peers to use and attempt to listen on the already connected\n    for await (const { id, metadata } of peers) {\n      const idStr = id.toB58String()\n\n      // Continue to next if listening on this or peer to ignore\n      if (this._listenRelays.has(idStr)) {\n        continue\n      }\n\n      if (peersToIgnore.includes(idStr)) {\n        continue\n      }\n\n      const supportsHop = metadata.get(HOP_METADATA_KEY)\n\n      // Continue to next if it does not support Hop\n      if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {\n        continue\n      }\n\n      const connection = this._connectionManager.get(id)\n\n      // If not connected, store for possible later use.\n      if (!connection) {\n        knownHopsToDial.push(id)\n        continue\n      }\n\n      await this._addListenRelay(connection, idStr)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to listen on known peers that are not connected\n    for (const peerId of knownHopsToDial) {\n      await this._tryToListenOnRelay(peerId)\n\n      // Check if already listening on enough relays\n      if (this._listenRelays.size >= this.maxListeners) {\n        return\n      }\n    }\n\n    // Try to find relays to hop on the network\n    try {\n      const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS)\n      for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {\n        if (!provider.multiaddrs.length) {\n          continue\n        }\n\n        const peerId = provider.id\n        await this._peerStore.addressBook.add(peerId, provider.multiaddrs)\n\n        await this._tryToListenOnRelay(peerId)\n\n        // Check if already listening on enough relays\n        if (this._listenRelays.size >= this.maxListeners) {\n          return\n        }\n      }\n    } catch (/** @type {any} */ err) {\n      this._onError(err)\n    }\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async _tryToListenOnRelay (peerId) {\n    try {\n      const connection = await this._libp2p.dial(peerId)\n      await this._addListenRelay(connection, peerId.toB58String())\n    } catch (/** @type {any} */ err) {\n      this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`)\n    }\n  }\n}\n\nmodule.exports = AutoRelay\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}