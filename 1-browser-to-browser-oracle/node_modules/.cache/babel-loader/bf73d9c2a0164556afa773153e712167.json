{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.responseServiceValue2ts = exports.returnType2Aqua = exports.ts2aqua = exports.aquaArgs2Ts = exports.aqua2ts = void 0;\n\nvar utils_1 = require(\"../../utils\");\n\nvar ts_pattern_1 = require(\"ts-pattern\");\n/**\n * Convert value from its representation in aqua language to representation in typescript\n * @param value - value as represented in aqua\n * @param type - definition of the aqua type\n * @returns value represented in typescript\n */\n\n\nvar aqua2ts = function (value, type) {\n  var res = (0, ts_pattern_1.match)(type).with({\n    tag: 'nil'\n  }, function () {\n    return null;\n  }).with({\n    tag: 'option'\n  }, function (opt) {\n    if (value.length === 0) {\n      return null;\n    } else {\n      return (0, exports.aqua2ts)(value[0], opt.type);\n    }\n  }).with({\n    tag: 'scalar'\n  }, {\n    tag: 'bottomType'\n  }, {\n    tag: 'topType'\n  }, function () {\n    return value;\n  }).with({\n    tag: 'array'\n  }, function (arr) {\n    return value.map(function (y) {\n      return (0, exports.aqua2ts)(y, arr.type);\n    });\n  }).with({\n    tag: 'struct'\n  }, function (x) {\n    return Object.entries(x.fields).reduce(function (agg, _a) {\n      var _b;\n\n      var _c = __read(_a, 2),\n          key = _c[0],\n          type = _c[1];\n\n      var val = (0, exports.aqua2ts)(value[key], type);\n      return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));\n    }, {});\n  }).with({\n    tag: 'labeledProduct'\n  }, function (x) {\n    return Object.entries(x.fields).reduce(function (agg, _a) {\n      var _b;\n\n      var _c = __read(_a, 2),\n          key = _c[0],\n          type = _c[1];\n\n      var val = (0, exports.aqua2ts)(value[key], type);\n      return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));\n    }, {});\n  }).with({\n    tag: 'unlabeledProduct'\n  }, function (x) {\n    return x.items.map(function (type, index) {\n      return (0, exports.aqua2ts)(value[index], type);\n    });\n  }) // uncomment to check that every pattern in matched\n  // .exhaustive();\n  .otherwise(function () {\n    throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(type));\n  });\n  return res;\n};\n\nexports.aqua2ts = aqua2ts;\n/**\n * Convert call service arguments list from their aqua representation to representation in typescript\n * @param req - call service data\n * @param arrow - aqua type definition\n * @returns arguments in typescript representation\n */\n\nvar aquaArgs2Ts = function (req, arrow) {\n  var argTypes = (0, ts_pattern_1.match)(arrow.domain).with({\n    tag: 'labeledProduct'\n  }, function (x) {\n    return Object.values(x.fields);\n  }).with({\n    tag: 'unlabeledProduct'\n  }, function (x) {\n    return x.items;\n  }).with({\n    tag: 'nil'\n  }, function (x) {\n    return [];\n  }) // uncomment to check that every pattern in matched\n  // .exhaustive()\n  .otherwise(function () {\n    throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(arrow.domain));\n  });\n\n  if (req.args.length !== argTypes.length) {\n    throw new Error(\"incorrect number of arguments, expected: \".concat(argTypes.length, \", got: \").concat(req.args.length));\n  }\n\n  return req.args.map(function (arg, index) {\n    return (0, exports.aqua2ts)(arg, argTypes[index]);\n  });\n};\n\nexports.aquaArgs2Ts = aquaArgs2Ts;\n/**\n * Convert value from its typescript representation to representation in aqua\n * @param value - the value as represented in typescript\n * @param type - definition of the aqua type\n * @returns value represented in aqua\n */\n\nvar ts2aqua = function (value, type) {\n  var res = (0, ts_pattern_1.match)(type).with({\n    tag: 'nil'\n  }, function () {\n    return null;\n  }).with({\n    tag: 'option'\n  }, function (opt) {\n    if (value === null || value === undefined) {\n      return [];\n    } else {\n      return [(0, exports.ts2aqua)(value, opt.type)];\n    }\n  }).with({\n    tag: 'scalar'\n  }, {\n    tag: 'bottomType'\n  }, {\n    tag: 'topType'\n  }, function () {\n    return value;\n  }).with({\n    tag: 'array'\n  }, function (arr) {\n    return value.map(function (y) {\n      return (0, exports.ts2aqua)(y, arr.type);\n    });\n  }).with({\n    tag: 'struct'\n  }, function (x) {\n    return Object.entries(x.fields).reduce(function (agg, _a) {\n      var _b;\n\n      var _c = __read(_a, 2),\n          key = _c[0],\n          type = _c[1];\n\n      var val = (0, exports.ts2aqua)(value[key], type);\n      return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));\n    }, {});\n  }).with({\n    tag: 'labeledProduct'\n  }, function (x) {\n    return Object.entries(x.fields).reduce(function (agg, _a) {\n      var _b;\n\n      var _c = __read(_a, 2),\n          key = _c[0],\n          type = _c[1];\n\n      var val = (0, exports.ts2aqua)(value[key], type);\n      return __assign(__assign({}, agg), (_b = {}, _b[key] = val, _b));\n    }, {});\n  }).with({\n    tag: 'unlabeledProduct'\n  }, function (x) {\n    return x.items.map(function (type, index) {\n      return (0, exports.ts2aqua)(value[index], type);\n    });\n  }) // uncomment to check that every pattern in matched\n  // .exhaustive()\n  .otherwise(function () {\n    throw new Error('Unexpected tag: ' + (0, utils_1.jsonify)(type));\n  });\n  return res;\n};\n\nexports.ts2aqua = ts2aqua;\n/**\n * Convert return type of the service from it's typescript representation to representation in aqua\n * @param returnValue - the value as represented in typescript\n * @param arrowType - the arrow type which describes the service\n * @returns - value represented in aqua\n */\n\nvar returnType2Aqua = function (returnValue, arrowType) {\n  if (arrowType.codomain.tag === 'nil') {\n    return {};\n  }\n\n  if (arrowType.codomain.items.length === 0) {\n    return {};\n  }\n\n  if (arrowType.codomain.items.length === 1) {\n    return (0, exports.ts2aqua)(returnValue, arrowType.codomain.items[0]);\n  }\n\n  return arrowType.codomain.items.map(function (type, index) {\n    return (0, exports.ts2aqua)(returnValue[index], type);\n  });\n};\n\nexports.returnType2Aqua = returnType2Aqua;\n/**\n * Converts response value from aqua its representation to representation in typescript\n * @param req - call service data\n * @param arrow - aqua type definition\n * @returns response value in typescript representation\n */\n\nvar responseServiceValue2ts = function (req, arrow) {\n  return (0, ts_pattern_1.match)(arrow.codomain).with({\n    tag: 'nil'\n  }, function () {\n    return undefined;\n  }).with({\n    tag: 'unlabeledProduct'\n  }, function (x) {\n    if (x.items.length === 0) {\n      return undefined;\n    }\n\n    if (x.items.length === 1) {\n      return (0, exports.aqua2ts)(req.args[0], x.items[0]);\n    }\n\n    return req.args.map(function (y, index) {\n      return (0, exports.aqua2ts)(y, x.items[index]);\n    });\n  }).exhaustive();\n};\n\nexports.responseServiceValue2ts = responseServiceValue2ts;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;AAIA;;;;;;;;AAMO,IAAMA,OAAO,GAAG,UAACC,KAAD,EAAaC,IAAb,EAA+B;EAClD,IAAMC,GAAG,GAAG,wBAAMD,IAAN,EACPE,IADO,CACF;IAAEC,GAAG,EAAE;EAAP,CADE,EACc;IAClB,OAAO,IAAP;EACH,CAHO,EAIPD,IAJO,CAIF;IAAEC,GAAG,EAAE;EAAP,CAJE,EAIiB,UAACC,GAAD,EAAI;IACzB,IAAIL,KAAK,CAACM,MAAN,KAAiB,CAArB,EAAwB;MACpB,OAAO,IAAP;IACH,CAFD,MAEO;MACH,OAAO,qBAAQN,KAAK,CAAC,CAAD,CAAb,EAAkBK,GAAG,CAACJ,IAAtB,CAAP;IACH;EACJ,CAVO,EAWPE,IAXO,CAWF;IAAEC,GAAG,EAAE;EAAP,CAXE,EAWiB;IAAEA,GAAG,EAAE;EAAP,CAXjB,EAWwC;IAAEA,GAAG,EAAE;EAAP,CAXxC,EAW4D;IAChE,OAAOJ,KAAP;EACH,CAbO,EAcPG,IAdO,CAcF;IAAEC,GAAG,EAAE;EAAP,CAdE,EAcgB,UAACG,GAAD,EAAI;IACxB,OAAOP,KAAK,CAACQ,GAAN,CAAU,UAACC,CAAD,EAAO;MAAK,4BAAQA,CAAR,EAAWF,GAAG,CAACN,IAAf;IAAoB,CAA1C,CAAP;EACH,CAhBO,EAiBPE,IAjBO,CAiBF;IAAEC,GAAG,EAAE;EAAP,CAjBE,EAiBiB,UAACM,CAAD,EAAE;IACvB,OAAOC,MAAM,CAACC,OAAP,CAAeF,CAAC,CAACG,MAAjB,EAAyBC,MAAzB,CAAgC,UAACC,GAAD,EAAMC,EAAN,EAAiB;;;UAAXC;UAACC,GAAG;UAAEjB,IAAI;;MACnD,IAAMkB,GAAG,GAAG,qBAAQnB,KAAK,CAACkB,GAAD,CAAb,EAAoBjB,IAApB,CAAZ;MACA,6BAAYc,GAAZ,IAAeK,YAAGF,GAAH,IAASC,GAAT,EAAYC,EAA3B;IACH,CAHM,EAGJ,EAHI,CAAP;EAIH,CAtBO,EAuBPjB,IAvBO,CAuBF;IAAEC,GAAG,EAAE;EAAP,CAvBE,EAuByB,UAACM,CAAD,EAAE;IAC/B,OAAOC,MAAM,CAACC,OAAP,CAAeF,CAAC,CAACG,MAAjB,EAAyBC,MAAzB,CAAgC,UAACC,GAAD,EAAMC,EAAN,EAAiB;;;UAAXC;UAACC,GAAG;UAAEjB,IAAI;;MACnD,IAAMkB,GAAG,GAAG,qBAAQnB,KAAK,CAACkB,GAAD,CAAb,EAAoBjB,IAApB,CAAZ;MACA,6BAAYc,GAAZ,IAAeK,YAAGF,GAAH,IAASC,GAAT,EAAYC,EAA3B;IACH,CAHM,EAGJ,EAHI,CAAP;EAIH,CA5BO,EA6BPjB,IA7BO,CA6BF;IAAEC,GAAG,EAAE;EAAP,CA7BE,EA6B2B,UAACM,CAAD,EAAE;IACjC,OAAOA,CAAC,CAACW,KAAF,CAAQb,GAAR,CAAY,UAACP,IAAD,EAAOqB,KAAP,EAAY;MAC3B,OAAO,qBAAQtB,KAAK,CAACsB,KAAD,CAAb,EAAsBrB,IAAtB,CAAP;IACH,CAFM,CAAP;EAGH,CAjCO,EAkCR;EACA;EAnCQ,CAoCPsB,SApCO,CAoCG;IACP,MAAM,IAAIC,KAAJ,CAAU,qBAAqB,qBAAQvB,IAAR,CAA/B,CAAN;EACH,CAtCO,CAAZ;EAuCA,OAAOC,GAAP;AACH,CAzCM;;AAAMuB,kBAAO1B,OAAP;AA2Cb;;;;;;;AAMO,IAAM2B,WAAW,GAAG,UAACC,GAAD,EAAuBC,KAAvB,EAAmD;EAC1E,IAAMC,QAAQ,GAAG,wBAAMD,KAAK,CAACE,MAAZ,EACZ3B,IADY,CACP;IAAEC,GAAG,EAAE;EAAP,CADO,EACoB,UAACM,CAAD,EAAE;IAC/B,OAAOC,MAAM,CAACoB,MAAP,CAAcrB,CAAC,CAACG,MAAhB,CAAP;EACH,CAHY,EAIZV,IAJY,CAIP;IAAEC,GAAG,EAAE;EAAP,CAJO,EAIsB,UAACM,CAAD,EAAE;IACjC,OAAOA,CAAC,CAACW,KAAT;EACH,CANY,EAOZlB,IAPY,CAOP;IAAEC,GAAG,EAAE;EAAP,CAPO,EAOS,UAACM,CAAD,EAAE;IACpB,OAAO,EAAP;EACH,CATY,EAUb;EACA;EAXa,CAYZa,SAZY,CAYF;IACP,MAAM,IAAIC,KAAJ,CAAU,qBAAqB,qBAAQI,KAAK,CAACE,MAAd,CAA/B,CAAN;EACH,CAdY,CAAjB;;EAgBA,IAAIH,GAAG,CAACK,IAAJ,CAAS1B,MAAT,KAAoBuB,QAAQ,CAACvB,MAAjC,EAAyC;IACrC,MAAM,IAAIkB,KAAJ,CAAU,mDAA4CK,QAAQ,CAACvB,MAArD,EAA2D,SAA3D,EAA2D2B,MAA3D,CAAqEN,GAAG,CAACK,IAAJ,CAAS1B,MAA9E,CAAV,CAAN;EACH;;EAED,OAAOqB,GAAG,CAACK,IAAJ,CAASxB,GAAT,CAAa,UAAC0B,GAAD,EAAMZ,KAAN,EAAW;IAC3B,OAAO,qBAAQY,GAAR,EAAaL,QAAQ,CAACP,KAAD,CAArB,CAAP;EACH,CAFM,CAAP;AAGH,CAxBM;;AAAMG,sBAAWC,WAAX;AA0Bb;;;;;;;AAMO,IAAMS,OAAO,GAAG,UAACnC,KAAD,EAAaC,IAAb,EAA+B;EAClD,IAAMC,GAAG,GAAG,wBAAMD,IAAN,EACPE,IADO,CACF;IAAEC,GAAG,EAAE;EAAP,CADE,EACc;IAClB,OAAO,IAAP;EACH,CAHO,EAIPD,IAJO,CAIF;IAAEC,GAAG,EAAE;EAAP,CAJE,EAIiB,UAACC,GAAD,EAAI;IACzB,IAAIL,KAAK,KAAK,IAAV,IAAkBA,KAAK,KAAKoC,SAAhC,EAA2C;MACvC,OAAO,EAAP;IACH,CAFD,MAEO;MACH,OAAO,CAAC,qBAAQpC,KAAR,EAAeK,GAAG,CAACJ,IAAnB,CAAD,CAAP;IACH;EACJ,CAVO,EAWPE,IAXO,CAWF;IAAEC,GAAG,EAAE;EAAP,CAXE,EAWiB;IAAEA,GAAG,EAAE;EAAP,CAXjB,EAWwC;IAAEA,GAAG,EAAE;EAAP,CAXxC,EAW4D;IAChE,OAAOJ,KAAP;EACH,CAbO,EAcPG,IAdO,CAcF;IAAEC,GAAG,EAAE;EAAP,CAdE,EAcgB,UAACG,GAAD,EAAI;IACxB,OAAOP,KAAK,CAACQ,GAAN,CAAU,UAACC,CAAD,EAAO;MAAK,4BAAQA,CAAR,EAAWF,GAAG,CAACN,IAAf;IAAoB,CAA1C,CAAP;EACH,CAhBO,EAiBPE,IAjBO,CAiBF;IAAEC,GAAG,EAAE;EAAP,CAjBE,EAiBiB,UAACM,CAAD,EAAE;IACvB,OAAOC,MAAM,CAACC,OAAP,CAAeF,CAAC,CAACG,MAAjB,EAAyBC,MAAzB,CAAgC,UAACC,GAAD,EAAMC,EAAN,EAAiB;;;UAAXC;UAACC,GAAG;UAAEjB,IAAI;;MACnD,IAAMkB,GAAG,GAAG,qBAAQnB,KAAK,CAACkB,GAAD,CAAb,EAAoBjB,IAApB,CAAZ;MACA,6BAAYc,GAAZ,IAAeK,YAAGF,GAAH,IAASC,GAAT,EAAYC,EAA3B;IACH,CAHM,EAGJ,EAHI,CAAP;EAIH,CAtBO,EAuBPjB,IAvBO,CAuBF;IAAEC,GAAG,EAAE;EAAP,CAvBE,EAuByB,UAACM,CAAD,EAAE;IAC/B,OAAOC,MAAM,CAACC,OAAP,CAAeF,CAAC,CAACG,MAAjB,EAAyBC,MAAzB,CAAgC,UAACC,GAAD,EAAMC,EAAN,EAAiB;;;UAAXC;UAACC,GAAG;UAAEjB,IAAI;;MACnD,IAAMkB,GAAG,GAAG,qBAAQnB,KAAK,CAACkB,GAAD,CAAb,EAAoBjB,IAApB,CAAZ;MACA,6BAAYc,GAAZ,IAAeK,YAAGF,GAAH,IAASC,GAAT,EAAYC,EAA3B;IACH,CAHM,EAGJ,EAHI,CAAP;EAIH,CA5BO,EA6BPjB,IA7BO,CA6BF;IAAEC,GAAG,EAAE;EAAP,CA7BE,EA6B2B,UAACM,CAAD,EAAE;IACjC,OAAOA,CAAC,CAACW,KAAF,CAAQb,GAAR,CAAY,UAACP,IAAD,EAAOqB,KAAP,EAAY;MAC3B,OAAO,qBAAQtB,KAAK,CAACsB,KAAD,CAAb,EAAsBrB,IAAtB,CAAP;IACH,CAFM,CAAP;EAGH,CAjCO,EAkCR;EACA;EAnCQ,CAoCPsB,SApCO,CAoCG;IACP,MAAM,IAAIC,KAAJ,CAAU,qBAAqB,qBAAQvB,IAAR,CAA/B,CAAN;EACH,CAtCO,CAAZ;EAwCA,OAAOC,GAAP;AACH,CA1CM;;AAAMuB,kBAAOU,OAAP;AA4Cb;;;;;;;AAMO,IAAME,eAAe,GAAG,UAACC,WAAD,EAAmBC,SAAnB,EAAqD;EAChF,IAAIA,SAAS,CAACC,QAAV,CAAmBpC,GAAnB,KAA2B,KAA/B,EAAsC;IAClC,OAAO,EAAP;EACH;;EAED,IAAImC,SAAS,CAACC,QAAV,CAAmBnB,KAAnB,CAAyBf,MAAzB,KAAoC,CAAxC,EAA2C;IACvC,OAAO,EAAP;EACH;;EAED,IAAIiC,SAAS,CAACC,QAAV,CAAmBnB,KAAnB,CAAyBf,MAAzB,KAAoC,CAAxC,EAA2C;IACvC,OAAO,qBAAQgC,WAAR,EAAqBC,SAAS,CAACC,QAAV,CAAmBnB,KAAnB,CAAyB,CAAzB,CAArB,CAAP;EACH;;EAED,OAAOkB,SAAS,CAACC,QAAV,CAAmBnB,KAAnB,CAAyBb,GAAzB,CAA6B,UAACP,IAAD,EAAOqB,KAAP,EAAY;IAC5C,OAAO,qBAAQgB,WAAW,CAAChB,KAAD,CAAnB,EAA4BrB,IAA5B,CAAP;EACH,CAFM,CAAP;AAGH,CAhBM;;AAAMwB,0BAAeY,eAAf;AAkBb;;;;;;;AAMO,IAAMI,uBAAuB,GAAG,UAACd,GAAD,EAAuBC,KAAvB,EAA4C;EAC/E,OAAO,wBAAMA,KAAK,CAACY,QAAZ,EACFrC,IADE,CACG;IAAEC,GAAG,EAAE;EAAP,CADH,EACmB;IAClB,OAAOgC,SAAP;EACH,CAHE,EAIFjC,IAJE,CAIG;IAAEC,GAAG,EAAE;EAAP,CAJH,EAIgC,UAACM,CAAD,EAAE;IACjC,IAAIA,CAAC,CAACW,KAAF,CAAQf,MAAR,KAAmB,CAAvB,EAA0B;MACtB,OAAO8B,SAAP;IACH;;IAED,IAAI1B,CAAC,CAACW,KAAF,CAAQf,MAAR,KAAmB,CAAvB,EAA0B;MACtB,OAAO,qBAAQqB,GAAG,CAACK,IAAJ,CAAS,CAAT,CAAR,EAAqBtB,CAAC,CAACW,KAAF,CAAQ,CAAR,CAArB,CAAP;IACH;;IAED,OAAOM,GAAG,CAACK,IAAJ,CAASxB,GAAT,CAAa,UAACC,CAAD,EAAIa,KAAJ,EAAS;MAAK,4BAAQb,CAAR,EAAWC,CAAC,CAACW,KAAF,CAAQC,KAAR,CAAX;IAA0B,CAArD,CAAP;EACH,CAdE,EAeFoB,UAfE,EAAP;AAgBH,CAjBM;;AAAMjB,kCAAuBgB,uBAAvB","names":["aqua2ts","value","type","res","with","tag","opt","length","arr","map","y","x","Object","entries","fields","reduce","agg","_a","_c","key","val","_b","items","index","otherwise","Error","exports","aquaArgs2Ts","req","arrow","argTypes","domain","values","args","concat","arg","ts2aqua","undefined","returnType2Aqua","returnValue","arrowType","codomain","responseServiceValue2ts","exhaustive"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/compilerSupport/v3impl/conversions.ts"],"sourcesContent":["import { jsonify } from '../../utils';\nimport { match } from 'ts-pattern';\nimport { ArrowType, ArrowWithoutCallbacks, NonArrowType, UnlabeledProductType } from './interface';\nimport { CallServiceData } from 'src/internal/commonTypes';\n\n/**\n * Convert value from its representation in aqua language to representation in typescript\n * @param value - value as represented in aqua\n * @param type - definition of the aqua type\n * @returns value represented in typescript\n */\nexport const aqua2ts = (value: any, type: NonArrowType): any => {\n    const res = match(type)\n        .with({ tag: 'nil' }, () => {\n            return null;\n        })\n        .with({ tag: 'option' }, (opt) => {\n            if (value.length === 0) {\n                return null;\n            } else {\n                return aqua2ts(value[0], opt.type);\n            }\n        })\n        .with({ tag: 'scalar' }, { tag: 'bottomType' }, { tag: 'topType' }, () => {\n            return value;\n        })\n        .with({ tag: 'array' }, (arr) => {\n            return value.map((y: any) => aqua2ts(y, arr.type));\n        })\n        .with({ tag: 'struct' }, (x) => {\n            return Object.entries(x.fields).reduce((agg, [key, type]) => {\n                const val = aqua2ts(value[key], type);\n                return { ...agg, [key]: val };\n            }, {});\n        })\n        .with({ tag: 'labeledProduct' }, (x) => {\n            return Object.entries(x.fields).reduce((agg, [key, type]) => {\n                const val = aqua2ts(value[key], type);\n                return { ...agg, [key]: val };\n            }, {});\n        })\n        .with({ tag: 'unlabeledProduct' }, (x) => {\n            return x.items.map((type, index) => {\n                return aqua2ts(value[index], type);\n            });\n        })\n        // uncomment to check that every pattern in matched\n        // .exhaustive();\n        .otherwise(() => {\n            throw new Error('Unexpected tag: ' + jsonify(type));\n        });\n    return res;\n};\n\n/**\n * Convert call service arguments list from their aqua representation to representation in typescript\n * @param req - call service data\n * @param arrow - aqua type definition\n * @returns arguments in typescript representation\n */\nexport const aquaArgs2Ts = (req: CallServiceData, arrow: ArrowWithoutCallbacks) => {\n    const argTypes = match(arrow.domain)\n        .with({ tag: 'labeledProduct' }, (x) => {\n            return Object.values(x.fields);\n        })\n        .with({ tag: 'unlabeledProduct' }, (x) => {\n            return x.items;\n        })\n        .with({ tag: 'nil' }, (x) => {\n            return [];\n        })\n        // uncomment to check that every pattern in matched\n        // .exhaustive()\n        .otherwise(() => {\n            throw new Error('Unexpected tag: ' + jsonify(arrow.domain));\n        });\n\n    if (req.args.length !== argTypes.length) {\n        throw new Error(`incorrect number of arguments, expected: ${argTypes.length}, got: ${req.args.length}`);\n    }\n\n    return req.args.map((arg, index) => {\n        return aqua2ts(arg, argTypes[index]);\n    });\n};\n\n/**\n * Convert value from its typescript representation to representation in aqua\n * @param value - the value as represented in typescript\n * @param type - definition of the aqua type\n * @returns value represented in aqua\n */\nexport const ts2aqua = (value: any, type: NonArrowType): any => {\n    const res = match(type)\n        .with({ tag: 'nil' }, () => {\n            return null;\n        })\n        .with({ tag: 'option' }, (opt) => {\n            if (value === null || value === undefined) {\n                return [];\n            } else {\n                return [ts2aqua(value, opt.type)];\n            }\n        })\n        .with({ tag: 'scalar' }, { tag: 'bottomType' }, { tag: 'topType' }, () => {\n            return value;\n        })\n        .with({ tag: 'array' }, (arr) => {\n            return value.map((y: any) => ts2aqua(y, arr.type));\n        })\n        .with({ tag: 'struct' }, (x) => {\n            return Object.entries(x.fields).reduce((agg, [key, type]) => {\n                const val = ts2aqua(value[key], type);\n                return { ...agg, [key]: val };\n            }, {});\n        })\n        .with({ tag: 'labeledProduct' }, (x) => {\n            return Object.entries(x.fields).reduce((agg, [key, type]) => {\n                const val = ts2aqua(value[key], type);\n                return { ...agg, [key]: val };\n            }, {});\n        })\n        .with({ tag: 'unlabeledProduct' }, (x) => {\n            return x.items.map((type, index) => {\n                return ts2aqua(value[index], type);\n            });\n        })\n        // uncomment to check that every pattern in matched\n        // .exhaustive()\n        .otherwise(() => {\n            throw new Error('Unexpected tag: ' + jsonify(type));\n        });\n\n    return res;\n};\n\n/**\n * Convert return type of the service from it's typescript representation to representation in aqua\n * @param returnValue - the value as represented in typescript\n * @param arrowType - the arrow type which describes the service\n * @returns - value represented in aqua\n */\nexport const returnType2Aqua = (returnValue: any, arrowType: ArrowType<NonArrowType>) => {\n    if (arrowType.codomain.tag === 'nil') {\n        return {};\n    }\n\n    if (arrowType.codomain.items.length === 0) {\n        return {};\n    }\n\n    if (arrowType.codomain.items.length === 1) {\n        return ts2aqua(returnValue, arrowType.codomain.items[0]);\n    }\n\n    return arrowType.codomain.items.map((type, index) => {\n        return ts2aqua(returnValue[index], type);\n    });\n};\n\n/**\n * Converts response value from aqua its representation to representation in typescript\n * @param req - call service data\n * @param arrow - aqua type definition\n * @returns response value in typescript representation\n */\nexport const responseServiceValue2ts = (req: CallServiceData, arrow: ArrowType<any>) => {\n    return match(arrow.codomain)\n        .with({ tag: 'nil' }, () => {\n            return undefined;\n        })\n        .with({ tag: 'unlabeledProduct' }, (x) => {\n            if (x.items.length === 0) {\n                return undefined;\n            }\n\n            if (x.items.length === 1) {\n                return aqua2ts(req.args[0], x.items[0]);\n            }\n\n            return req.args.map((y, index) => aqua2ts(y, x.items[index]));\n        })\n        .exhaustive();\n};\n"]},"metadata":{},"sourceType":"script"}