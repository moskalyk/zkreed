{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.streamingIterables = {}));\n})(this, function (exports) {\n  'use strict';\n\n  async function* _batch(size, iterable) {\n    let dataBatch = [];\n\n    for await (const data of iterable) {\n      dataBatch.push(data);\n\n      if (dataBatch.length === size) {\n        yield dataBatch;\n        dataBatch = [];\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield dataBatch;\n    }\n  }\n\n  function* _syncBatch(size, iterable) {\n    let dataBatch = [];\n\n    for (const data of iterable) {\n      dataBatch.push(data);\n\n      if (dataBatch.length === size) {\n        yield dataBatch;\n        dataBatch = [];\n      }\n    }\n\n    if (dataBatch.length > 0) {\n      yield dataBatch;\n    }\n  }\n\n  function batch(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => batch(size, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _batch(size, iterable);\n    }\n\n    return _syncBatch(size, iterable);\n  }\n\n  const TIMEOUT = Symbol('TIMEOUT');\n\n  const createTimer = duration => {\n    let timeoutId;\n    return [new Promise(resolve => {\n      timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n    }), () => {\n      clearTimeout(timeoutId);\n    }];\n  }; // Like `batch` but flushes early if the `timeout` is reached\n  // NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\n\n\n  async function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n\n    const startTimer = () => {\n      deleteTimer();\n      [timer, clearTimer] = createTimer(timeout);\n    };\n\n    const deleteTimer = () => {\n      if (clearTimer) {\n        clearTimer();\n      }\n\n      timer = undefined;\n    };\n\n    pendingData = iterator.next();\n\n    while (true) {\n      const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n\n      if (res === TIMEOUT || res.done) {\n        // Flush early (before we reach the batch size)\n        if (batchData.length) {\n          yield batchData;\n          batchData = [];\n        }\n\n        deleteTimer(); // And exit appropriately\n\n        if (res !== TIMEOUT) {\n          // done\n          break;\n        }\n\n        continue;\n      } // Fetch next item early doors (before we potentially yield)\n\n\n      pendingData = iterator.next(); // Then handle the value\n\n      batchData.push(res.value);\n\n      if (batchData.length === 1) {\n        // Start timer once we have at least 1 item ready to go\n        startTimer();\n      }\n\n      if (batchData.length === size) {\n        yield batchData;\n        batchData = [];\n        deleteTimer();\n        continue;\n      }\n    }\n  }\n\n  function batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n      return _batchWithTimeout(size, timeout, iterable);\n    } // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n\n\n    return batch(size, iterable);\n  }\n\n  function getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n      return iterable;\n    }\n\n    if (typeof iterable[Symbol.iterator] === 'function') {\n      return iterable[Symbol.iterator]();\n    }\n\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n      return iterable[Symbol.asyncIterator]();\n    }\n\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n  }\n\n  function defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n      resolve = resolveFunc;\n      reject = rejectFunc;\n    });\n    return {\n      promise,\n      reject,\n      resolve\n    };\n  }\n\n  function _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const readDeferred = readQueue.shift();\n        const {\n          error,\n          value\n        } = resultQueue.shift();\n\n        if (error) {\n          readDeferred.reject(error);\n        } else {\n          readDeferred.resolve({\n            done: false,\n            value\n          });\n        }\n      }\n\n      while (readQueue.length > 0 && ended) {\n        const {\n          resolve\n        } = readQueue.shift();\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n\n    async function fillQueue() {\n      if (ended) {\n        return;\n      }\n\n      if (reading) {\n        return;\n      }\n\n      if (resultQueue.length >= size) {\n        return;\n      }\n\n      reading = true;\n\n      try {\n        const {\n          done,\n          value\n        } = await iterator.next();\n\n        if (done) {\n          ended = true;\n        } else {\n          resultQueue.push({\n            value\n          });\n        }\n      } catch (error) {\n        ended = true;\n        resultQueue.push({\n          error\n        });\n      }\n\n      fulfillReadQueue();\n      reading = false;\n      fillQueue();\n    }\n\n    async function next() {\n      if (resultQueue.length > 0) {\n        const {\n          error,\n          value\n        } = resultQueue.shift();\n\n        if (error) {\n          throw error;\n        }\n\n        fillQueue();\n        return {\n          done: false,\n          value\n        };\n      }\n\n      if (ended) {\n        return {\n          done: true,\n          value: undefined\n        }; // stupid ts\n      }\n\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n\n    try {\n      for (const value of iterable) {\n        valueQueue.push(value);\n\n        if (valueQueue.length <= size) {\n          continue;\n        }\n\n        yield valueQueue.shift();\n      }\n    } catch (error) {\n      e = error;\n    }\n\n    for (const value of valueQueue) {\n      yield value;\n    }\n\n    if (e) {\n      throw e;\n    }\n  }\n\n  function buffer(size, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => buffer(size, curriedIterable);\n    }\n\n    if (size === 0) {\n      return iterable;\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _buffer(size, iterable);\n    }\n\n    return syncBuffer(size, iterable);\n  }\n\n  async function _collect(iterable) {\n    const values = [];\n\n    for await (const value of iterable) {\n      values.push(value);\n    }\n\n    return values;\n  }\n\n  function collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _collect(iterable);\n    }\n\n    return Array.from(iterable);\n  }\n\n  async function* _concat(iterables) {\n    for await (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n\n  function* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n      yield* iterable;\n    }\n  }\n\n  function concat() {\n    for (var _len = arguments.length, iterables = new Array(_len), _key = 0; _key < _len; _key++) {\n      iterables[_key] = arguments[_key];\n    }\n\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n\n    if (hasAnyAsync) {\n      return _concat(iterables);\n    } else {\n      return _syncConcat(iterables);\n    }\n  }\n\n  async function _consume(iterable) {\n    for await (const val of iterable) {// do nothing\n    }\n  }\n\n  function consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n      return _consume(iterable);\n    }\n\n    for (const val of iterable) {// do nothing\n    }\n  }\n\n  async function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n      if (await filterFunc(data)) {\n        yield data;\n      }\n    }\n  }\n\n  function filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _filter(filterFunc, curriedIterable);\n    }\n\n    return _filter(filterFunc, iterable);\n  }\n\n  async function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n      if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n        yield* flatten(maybeItr);\n      } else {\n        yield maybeItr;\n      }\n    }\n  }\n\n  async function* _map(func, iterable) {\n    for await (const val of iterable) {\n      yield await func(val);\n    }\n  }\n\n  function map(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _map(func, curriedIterable);\n    }\n\n    return _map(func, iterable);\n  }\n\n  function flatMap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => flatMap(func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n  }\n\n  function _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    async function fillQueue() {\n      if (ended) {\n        fulfillReadQueue();\n        return;\n      }\n\n      if (reading) {\n        return;\n      }\n\n      if (inflightCount + resultQueue.length >= concurrency) {\n        return;\n      }\n\n      reading = true;\n      inflightCount++;\n\n      try {\n        const {\n          done,\n          value\n        } = await iterator.next();\n\n        if (done) {\n          ended = true;\n          inflightCount--;\n          fulfillReadQueue();\n        } else {\n          mapAndQueue(value);\n        }\n      } catch (error) {\n        ended = true;\n        inflightCount--;\n        lastError = error;\n        fulfillReadQueue();\n      }\n\n      reading = false;\n      fillQueue();\n    }\n\n    async function mapAndQueue(itrValue) {\n      try {\n        const value = await func(itrValue);\n\n        if (value && value[Symbol.asyncIterator]) {\n          for await (const asyncVal of value) {\n            resultQueue.push(asyncVal);\n          }\n        } else {\n          resultQueue.push(value);\n        }\n      } catch (error) {\n        ended = true;\n        lastError = error;\n      }\n\n      inflightCount--;\n      fulfillReadQueue();\n      fillQueue();\n    }\n\n    async function next() {\n      if (resultQueue.length === 0) {\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n      }\n\n      const value = resultQueue.shift();\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n  }\n\n  async function onceReadable(stream) {\n    return new Promise(resolve => {\n      stream.once('readable', () => {\n        resolve();\n      });\n    });\n  }\n\n  async function* _fromStream(stream) {\n    while (true) {\n      const data = stream.read();\n\n      if (data !== null) {\n        yield data;\n        continue;\n      }\n\n      if (stream._readableState.ended) {\n        break;\n      }\n\n      await onceReadable(stream);\n    }\n  }\n\n  function fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n      return stream;\n    }\n\n    return _fromStream(stream);\n  }\n\n  async function* merge() {\n    for (var _len2 = arguments.length, iterables = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      iterables[_key2] = arguments[_key2];\n    }\n\n    const sources = new Set(iterables.map(getIterator));\n\n    while (sources.size > 0) {\n      for (const iterator of sources) {\n        const nextVal = await iterator.next();\n\n        if (nextVal.done) {\n          sources.delete(iterator);\n        } else {\n          yield nextVal.value;\n        }\n      }\n    }\n  }\n\n  function pipeline(firstFn) {\n    let previousFn = firstFn();\n\n    for (var _len3 = arguments.length, fns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      fns[_key3 - 1] = arguments[_key3];\n    }\n\n    for (const func of fns) {\n      previousFn = func(previousFn);\n    }\n\n    return previousFn;\n  }\n\n  async function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n\n    const wrapFunc = value => ({\n      value: func(value)\n    });\n\n    const stopOnError = async function* (source) {\n      for await (const value of source) {\n        if (transformError) {\n          return;\n        }\n\n        yield value;\n      }\n    };\n\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n\n    while (true) {\n      const {\n        value,\n        done\n      } = await itr.next();\n\n      if (done) {\n        break;\n      }\n\n      try {\n        const val = await value.value;\n\n        if (!transformError) {\n          yield val;\n        }\n      } catch (error) {\n        transformError = error;\n      }\n    }\n\n    if (transformError) {\n      throw transformError;\n    }\n  }\n\n  function parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n\n    if (concurrency === 1) {\n      return map(func, iterable);\n    }\n\n    return _parallelMap(concurrency, func, iterable);\n  }\n\n  function parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n  }\n\n  async function* parallelMerge() {\n    for (var _len4 = arguments.length, iterables = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      iterables[_key4] = arguments[_key4];\n    }\n\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n\n    const notifyError = err => {\n      lastError = err;\n\n      if (errCb) {\n        errCb(err);\n      }\n    };\n\n    const notifyDone = value => {\n      if (valueCb) {\n        valueCb(value);\n      }\n    };\n\n    const waitForQueue = () => new Promise((resolve, reject) => {\n      if (lastError) {\n        reject(lastError);\n      }\n\n      if (values.size > 0) {\n        return resolve();\n      }\n\n      valueCb = resolve;\n      errCb = reject;\n    });\n\n    const queueNext = input => {\n      const nextVal = Promise.resolve(input.next()).then(async _ref => {\n        let {\n          done,\n          value\n        } = _ref;\n\n        if (!done) {\n          values.set(input, value);\n        }\n\n        concurrentWork.delete(nextVal);\n      });\n      concurrentWork.add(nextVal);\n      nextVal.then(notifyDone, notifyError);\n    };\n\n    for (const input of inputs) {\n      queueNext(input);\n    }\n\n    while (true) {\n      // We technically don't have to check `values.size` as the for loop should have emptied it\n      // However I haven't yet found specs verifying that behavior, only tests\n      // the guard in waitForQueue() checking for values is in place for the same reason\n      if (concurrentWork.size === 0 && values.size === 0) {\n        return;\n      }\n\n      await waitForQueue();\n\n      for (const [input, value] of values) {\n        values.delete(input);\n        yield value;\n        queueNext(input);\n      }\n    }\n  }\n\n  async function _reduce(func, start, iterable) {\n    let value = start;\n\n    for await (const nextItem of iterable) {\n      value = await func(value, nextItem);\n    }\n\n    return value;\n  }\n\n  function reduce(func, start, iterable) {\n    if (start === undefined) {\n      return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => reduce(func, start, curriedIterable);\n    }\n\n    return _reduce(func, start, iterable);\n  }\n\n  async function* _take(count, iterable) {\n    let taken = 0;\n\n    for await (const val of iterable) {\n      yield await val;\n      taken++;\n\n      if (taken >= count) {\n        break;\n      }\n    }\n  }\n\n  function* _syncTake(count, iterable) {\n    let taken = 0;\n\n    for (const val of iterable) {\n      yield val;\n      taken++;\n\n      if (taken >= count) {\n        break;\n      }\n    }\n  }\n\n  function take(count, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => take(count, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator]) {\n      return _take(count, iterable);\n    }\n\n    return _syncTake(count, iterable);\n  }\n\n  async function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n      await func(val);\n      yield val;\n    }\n  }\n\n  function tap(func, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _asyncTap(func, curriedIterable);\n    }\n\n    return _asyncTap(func, iterable);\n  }\n\n  const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\n\n  function _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n      throw new TypeError('Expected `limit` to be a finite number');\n    }\n\n    if (limit <= 0) {\n      throw new TypeError('Expected `limit` to be greater than 0');\n    }\n\n    if (!Number.isFinite(interval)) {\n      throw new TypeError('Expected `interval` to be a finite number');\n    }\n\n    return async function* __throttle() {\n      let sent = 0;\n      let time;\n\n      for await (const val of iterable) {\n        if (sent < limit) {\n          if (typeof time === 'undefined') {\n            time = Date.now();\n          }\n\n          sent++;\n          yield val;\n          continue;\n        } // Only wait if the interval hasn't already passed while we were\n        // yielding the previous values.\n\n\n        const elapsedMs = Date.now() - time;\n        const waitFor = interval - elapsedMs;\n\n        if (waitFor > 0) {\n          await sleep(waitFor);\n        }\n\n        time = Date.now();\n        sent = 1;\n        yield val;\n      }\n    }();\n  }\n\n  function throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _throttle(limit, interval, curriedIterable);\n    }\n\n    return _throttle(limit, interval, iterable);\n  }\n\n  function addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n\n    if (nanoseconds >= 1000000000) {\n      const remainder = nanoseconds % 1000000000;\n      seconds += (nanoseconds - remainder) / 1000000000;\n      nanoseconds = remainder;\n    }\n\n    return [seconds, nanoseconds];\n  }\n\n  async function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = await itr.next();\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return value;\n      }\n\n      yield value;\n    }\n  }\n\n  function* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n\n    while (true) {\n      const start = process.hrtime();\n      const {\n        value,\n        done\n      } = itr.next();\n      const delta = process.hrtime(start);\n      total = addTime(total, delta);\n\n      if (config.progress) {\n        config.progress(delta, total);\n      }\n\n      if (done) {\n        if (config.total) {\n          config.total(total);\n        }\n\n        return value;\n      }\n\n      yield value;\n    }\n  }\n\n  function time() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let iterable = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (iterable === undefined) {\n      return curriedIterable => time(config, curriedIterable);\n    }\n\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n      return _asyncTime(config, iterable);\n    } else {\n      return _syncTime(config, iterable);\n    }\n  }\n\n  function _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n\n    function fulfillReadQueue() {\n      while (readQueue.length > 0 && resultQueue.length > 0) {\n        const {\n          resolve\n        } = readQueue.shift();\n        const value = resultQueue.shift();\n        resolve({\n          done: false,\n          value\n        });\n      }\n\n      while (readQueue.length > 0 && inflightCount === 0 && ended) {\n        const {\n          resolve,\n          reject\n        } = readQueue.shift();\n\n        if (lastError) {\n          reject(lastError);\n          lastError = null;\n        } else {\n          resolve({\n            done: true,\n            value: undefined\n          });\n        }\n      }\n    }\n\n    async function fillQueue() {\n      if (ended) {\n        fulfillReadQueue();\n        return;\n      }\n\n      if (reading) {\n        return;\n      }\n\n      if (inflightCount + resultQueue.length >= concurrency) {\n        return;\n      }\n\n      reading = true;\n      inflightCount++;\n\n      try {\n        const {\n          done,\n          value\n        } = await iterator.next();\n\n        if (done) {\n          ended = true;\n          inflightCount--;\n          fulfillReadQueue();\n        } else {\n          mapAndQueue(value);\n        }\n      } catch (error) {\n        ended = true;\n        inflightCount--;\n        lastError = error;\n        fulfillReadQueue();\n      }\n\n      reading = false;\n      fillQueue();\n    }\n\n    async function mapAndQueue(itrValue) {\n      try {\n        const value = await func(itrValue);\n        resultQueue.push(value);\n      } catch (error) {\n        ended = true;\n        lastError = error;\n      }\n\n      inflightCount--;\n      fulfillReadQueue();\n      fillQueue();\n    }\n\n    async function next() {\n      if (resultQueue.length === 0) {\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n      }\n\n      const value = resultQueue.shift();\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n\n    const asyncIterableIterator = {\n      next,\n      [Symbol.asyncIterator]: () => asyncIterableIterator\n    };\n    return asyncIterableIterator;\n  }\n\n  function transform(concurrency, func, iterable) {\n    if (func === undefined) {\n      return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n    }\n\n    if (iterable === undefined) {\n      return curriedIterable => transform(concurrency, func, curriedIterable);\n    }\n\n    return _transform(concurrency, func, iterable);\n  }\n\n  async function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n\n    const notifyError = err => {\n      lastError = err;\n\n      if (errCb) {\n        errCb(err);\n      }\n    };\n\n    const notifyDrain = () => {\n      if (drainCb) {\n        drainCb();\n      }\n    };\n\n    const cleanup = () => {\n      stream.removeListener('error', notifyError);\n      stream.removeListener('drain', notifyDrain);\n    };\n\n    stream.once('error', notifyError);\n\n    const waitForDrain = () => new Promise((resolve, reject) => {\n      if (lastError) {\n        return reject(lastError);\n      }\n\n      stream.once('drain', notifyDrain);\n      drainCb = resolve;\n      errCb = reject;\n    });\n\n    for await (const value of iterable) {\n      if (stream.write(value) === false) {\n        await waitForDrain();\n      }\n\n      if (lastError) {\n        break;\n      }\n    }\n\n    cleanup();\n\n    if (lastError) {\n      throw lastError;\n    }\n  }\n\n  function writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n      return curriedIterable => _writeToStream(stream, curriedIterable);\n    }\n\n    return _writeToStream(stream, iterable);\n  }\n\n  exports.batch = batch;\n  exports.batchWithTimeout = batchWithTimeout;\n  exports.buffer = buffer;\n  exports.collect = collect;\n  exports.concat = concat;\n  exports.consume = consume;\n  exports.filter = filter;\n  exports.flatMap = flatMap;\n  exports.flatTransform = flatTransform;\n  exports.flatten = flatten;\n  exports.fromStream = fromStream;\n  exports.getIterator = getIterator;\n  exports.map = map;\n  exports.merge = merge;\n  exports.parallelFlatMap = parallelFlatMap;\n  exports.parallelMap = parallelMap;\n  exports.parallelMerge = parallelMerge;\n  exports.pipeline = pipeline;\n  exports.reduce = reduce;\n  exports.take = take;\n  exports.tap = tap;\n  exports.throttle = throttle;\n  exports.time = time;\n  exports.transform = transform;\n  exports.writeToStream = writeToStream;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","globalThis","self","streamingIterables","_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","TIMEOUT","createTimer","duration","timeoutId","Promise","resolve","setTimeout","clearTimeout","_batchWithTimeout","timeout","iterator","pendingData","batchData","timer","clearTimer","startTimer","deleteTimer","next","res","race","done","value","batchWithTimeout","Infinity","getIterator","TypeError","defer","reject","promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","previousFn","fns","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","sleep","ms","_throttle","limit","interval","Number","isFinite","__throttle","sent","time","Date","now","elapsedMs","waitFor","throttle","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream","Object","defineProperty"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/streaming-iterables/dist/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.streamingIterables = {}));\n})(this, (function (exports) { 'use strict';\n\n    async function* _batch(size, iterable) {\n        let dataBatch = [];\n        for await (const data of iterable) {\n            dataBatch.push(data);\n            if (dataBatch.length === size) {\n                yield dataBatch;\n                dataBatch = [];\n            }\n        }\n        if (dataBatch.length > 0) {\n            yield dataBatch;\n        }\n    }\n    function* _syncBatch(size, iterable) {\n        let dataBatch = [];\n        for (const data of iterable) {\n            dataBatch.push(data);\n            if (dataBatch.length === size) {\n                yield dataBatch;\n                dataBatch = [];\n            }\n        }\n        if (dataBatch.length > 0) {\n            yield dataBatch;\n        }\n    }\n    function batch(size, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => batch(size, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _batch(size, iterable);\n        }\n        return _syncBatch(size, iterable);\n    }\n\n    const TIMEOUT = Symbol('TIMEOUT');\n    const createTimer = (duration) => {\n        let timeoutId;\n        return [\n            new Promise(resolve => {\n                timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n            }),\n            () => {\n                clearTimeout(timeoutId);\n            },\n        ];\n    };\n    // Like `batch` but flushes early if the `timeout` is reached\n    // NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\n    async function* _batchWithTimeout(size, timeout, iterable) {\n        const iterator = iterable[Symbol.asyncIterator]();\n        let pendingData;\n        let batchData = [];\n        let timer;\n        let clearTimer;\n        const startTimer = () => {\n            deleteTimer();\n            [timer, clearTimer] = createTimer(timeout);\n        };\n        const deleteTimer = () => {\n            if (clearTimer) {\n                clearTimer();\n            }\n            timer = undefined;\n        };\n        pendingData = iterator.next();\n        while (true) {\n            const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n            if (res === TIMEOUT || res.done) {\n                // Flush early (before we reach the batch size)\n                if (batchData.length) {\n                    yield batchData;\n                    batchData = [];\n                }\n                deleteTimer();\n                // And exit appropriately\n                if (res !== TIMEOUT) {\n                    // done\n                    break;\n                }\n                continue;\n            }\n            // Fetch next item early doors (before we potentially yield)\n            pendingData = iterator.next();\n            // Then handle the value\n            batchData.push(res.value);\n            if (batchData.length === 1) {\n                // Start timer once we have at least 1 item ready to go\n                startTimer();\n            }\n            if (batchData.length === size) {\n                yield batchData;\n                batchData = [];\n                deleteTimer();\n                continue;\n            }\n        }\n    }\n    function batchWithTimeout(size, timeout, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n            return _batchWithTimeout(size, timeout, iterable);\n        }\n        // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n        return batch(size, iterable);\n    }\n\n    function getIterator(iterable) {\n        if (typeof iterable.next === 'function') {\n            return iterable;\n        }\n        if (typeof iterable[Symbol.iterator] === 'function') {\n            return iterable[Symbol.iterator]();\n        }\n        if (typeof iterable[Symbol.asyncIterator] === 'function') {\n            return iterable[Symbol.asyncIterator]();\n        }\n        throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n    }\n\n    function defer() {\n        let reject;\n        let resolve;\n        const promise = new Promise((resolveFunc, rejectFunc) => {\n            resolve = resolveFunc;\n            reject = rejectFunc;\n        });\n        return {\n            promise,\n            reject,\n            resolve,\n        };\n    }\n\n    function _buffer(size, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let reading = false;\n        let ended = false;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const readDeferred = readQueue.shift();\n                const { error, value } = resultQueue.shift();\n                if (error) {\n                    readDeferred.reject(error);\n                }\n                else {\n                    readDeferred.resolve({ done: false, value });\n                }\n            }\n            while (readQueue.length > 0 && ended) {\n                const { resolve } = readQueue.shift();\n                resolve({ done: true, value: undefined });\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (resultQueue.length >= size) {\n                return;\n            }\n            reading = true;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                }\n                else {\n                    resultQueue.push({ value });\n                }\n            }\n            catch (error) {\n                ended = true;\n                resultQueue.push({ error });\n            }\n            fulfillReadQueue();\n            reading = false;\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length > 0) {\n                const { error, value } = resultQueue.shift();\n                if (error) {\n                    throw error;\n                }\n                fillQueue();\n                return { done: false, value };\n            }\n            if (ended) {\n                return { done: true, value: undefined }; // stupid ts\n            }\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function* syncBuffer(size, iterable) {\n        const valueQueue = [];\n        let e;\n        try {\n            for (const value of iterable) {\n                valueQueue.push(value);\n                if (valueQueue.length <= size) {\n                    continue;\n                }\n                yield valueQueue.shift();\n            }\n        }\n        catch (error) {\n            e = error;\n        }\n        for (const value of valueQueue) {\n            yield value;\n        }\n        if (e) {\n            throw e;\n        }\n    }\n    function buffer(size, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => buffer(size, curriedIterable);\n        }\n        if (size === 0) {\n            return iterable;\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _buffer(size, iterable);\n        }\n        return syncBuffer(size, iterable);\n    }\n\n    async function _collect(iterable) {\n        const values = [];\n        for await (const value of iterable) {\n            values.push(value);\n        }\n        return values;\n    }\n    function collect(iterable) {\n        if (iterable[Symbol.asyncIterator]) {\n            return _collect(iterable);\n        }\n        return Array.from(iterable);\n    }\n\n    async function* _concat(iterables) {\n        for await (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    function* _syncConcat(iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    function concat(...iterables) {\n        const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n        if (hasAnyAsync) {\n            return _concat(iterables);\n        }\n        else {\n            return _syncConcat(iterables);\n        }\n    }\n\n    async function _consume(iterable) {\n        for await (const val of iterable) {\n            // do nothing\n        }\n    }\n    function consume(iterable) {\n        if (iterable[Symbol.asyncIterator]) {\n            return _consume(iterable);\n        }\n        for (const val of iterable) {\n            // do nothing\n        }\n    }\n\n    async function* _filter(filterFunc, iterable) {\n        for await (const data of iterable) {\n            if (await filterFunc(data)) {\n                yield data;\n            }\n        }\n    }\n    function filter(filterFunc, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _filter(filterFunc, curriedIterable);\n        }\n        return _filter(filterFunc, iterable);\n    }\n\n    async function* flatten(iterable) {\n        for await (const maybeItr of iterable) {\n            if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n                yield* flatten(maybeItr);\n            }\n            else {\n                yield maybeItr;\n            }\n        }\n    }\n\n    async function* _map(func, iterable) {\n        for await (const val of iterable) {\n            yield await func(val);\n        }\n    }\n    function map(func, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => _map(func, curriedIterable);\n        }\n        return _map(func, iterable);\n    }\n\n    function flatMap(func, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => flatMap(func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n    }\n\n    function _flatTransform(concurrency, func, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let ended = false;\n        let reading = false;\n        let inflightCount = 0;\n        let lastError = null;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const { resolve } = readQueue.shift();\n                const value = resultQueue.shift();\n                resolve({ done: false, value });\n            }\n            while (readQueue.length > 0 && inflightCount === 0 && ended) {\n                const { resolve, reject } = readQueue.shift();\n                if (lastError) {\n                    reject(lastError);\n                    lastError = null;\n                }\n                else {\n                    resolve({ done: true, value: undefined });\n                }\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                fulfillReadQueue();\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (inflightCount + resultQueue.length >= concurrency) {\n                return;\n            }\n            reading = true;\n            inflightCount++;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                    inflightCount--;\n                    fulfillReadQueue();\n                }\n                else {\n                    mapAndQueue(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                inflightCount--;\n                lastError = error;\n                fulfillReadQueue();\n            }\n            reading = false;\n            fillQueue();\n        }\n        async function mapAndQueue(itrValue) {\n            try {\n                const value = await func(itrValue);\n                if (value && value[Symbol.asyncIterator]) {\n                    for await (const asyncVal of value) {\n                        resultQueue.push(asyncVal);\n                    }\n                }\n                else {\n                    resultQueue.push(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                lastError = error;\n            }\n            inflightCount--;\n            fulfillReadQueue();\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length === 0) {\n                const deferred = defer();\n                readQueue.push(deferred);\n                fillQueue();\n                return deferred.promise;\n            }\n            const value = resultQueue.shift();\n            fillQueue();\n            return { done: false, value };\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function flatTransform(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? flatTransform(concurrency, curriedFunc, curriedIterable)\n                : flatTransform(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n    }\n\n    async function onceReadable(stream) {\n        return new Promise(resolve => {\n            stream.once('readable', () => {\n                resolve();\n            });\n        });\n    }\n    async function* _fromStream(stream) {\n        while (true) {\n            const data = stream.read();\n            if (data !== null) {\n                yield data;\n                continue;\n            }\n            if (stream._readableState.ended) {\n                break;\n            }\n            await onceReadable(stream);\n        }\n    }\n    function fromStream(stream) {\n        if (typeof stream[Symbol.asyncIterator] === 'function') {\n            return stream;\n        }\n        return _fromStream(stream);\n    }\n\n    async function* merge(...iterables) {\n        const sources = new Set(iterables.map(getIterator));\n        while (sources.size > 0) {\n            for (const iterator of sources) {\n                const nextVal = await iterator.next();\n                if (nextVal.done) {\n                    sources.delete(iterator);\n                }\n                else {\n                    yield nextVal.value;\n                }\n            }\n        }\n    }\n\n    function pipeline(firstFn, ...fns) {\n        let previousFn = firstFn();\n        for (const func of fns) {\n            previousFn = func(previousFn);\n        }\n        return previousFn;\n    }\n\n    async function* _parallelMap(concurrency, func, iterable) {\n        let transformError = null;\n        const wrapFunc = value => ({\n            value: func(value),\n        });\n        const stopOnError = async function* (source) {\n            for await (const value of source) {\n                if (transformError) {\n                    return;\n                }\n                yield value;\n            }\n        };\n        const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n        const itr = getIterator(output);\n        while (true) {\n            const { value, done } = await itr.next();\n            if (done) {\n                break;\n            }\n            try {\n                const val = await value.value;\n                if (!transformError) {\n                    yield val;\n                }\n            }\n            catch (error) {\n                transformError = error;\n            }\n        }\n        if (transformError) {\n            throw transformError;\n        }\n    }\n    function parallelMap(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n        }\n        if (iterable === undefined) {\n            return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n        }\n        if (concurrency === 1) {\n            return map(func, iterable);\n        }\n        return _parallelMap(concurrency, func, iterable);\n    }\n\n    function parallelFlatMap(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n                : parallelFlatMap(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n        }\n        return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n    }\n\n    async function* parallelMerge(...iterables) {\n        const inputs = iterables.map(getIterator);\n        const concurrentWork = new Set();\n        const values = new Map();\n        let lastError = null;\n        let errCb = null;\n        let valueCb = null;\n        const notifyError = err => {\n            lastError = err;\n            if (errCb) {\n                errCb(err);\n            }\n        };\n        const notifyDone = value => {\n            if (valueCb) {\n                valueCb(value);\n            }\n        };\n        const waitForQueue = () => new Promise((resolve, reject) => {\n            if (lastError) {\n                reject(lastError);\n            }\n            if (values.size > 0) {\n                return resolve();\n            }\n            valueCb = resolve;\n            errCb = reject;\n        });\n        const queueNext = input => {\n            const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n                if (!done) {\n                    values.set(input, value);\n                }\n                concurrentWork.delete(nextVal);\n            });\n            concurrentWork.add(nextVal);\n            nextVal.then(notifyDone, notifyError);\n        };\n        for (const input of inputs) {\n            queueNext(input);\n        }\n        while (true) {\n            // We technically don't have to check `values.size` as the for loop should have emptied it\n            // However I haven't yet found specs verifying that behavior, only tests\n            // the guard in waitForQueue() checking for values is in place for the same reason\n            if (concurrentWork.size === 0 && values.size === 0) {\n                return;\n            }\n            await waitForQueue();\n            for (const [input, value] of values) {\n                values.delete(input);\n                yield value;\n                queueNext(input);\n            }\n        }\n    }\n\n    async function _reduce(func, start, iterable) {\n        let value = start;\n        for await (const nextItem of iterable) {\n            value = await func(value, nextItem);\n        }\n        return value;\n    }\n    function reduce(func, start, iterable) {\n        if (start === undefined) {\n            return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => reduce(func, start, curriedIterable);\n        }\n        return _reduce(func, start, iterable);\n    }\n\n    async function* _take(count, iterable) {\n        let taken = 0;\n        for await (const val of iterable) {\n            yield await val;\n            taken++;\n            if (taken >= count) {\n                break;\n            }\n        }\n    }\n    function* _syncTake(count, iterable) {\n        let taken = 0;\n        for (const val of iterable) {\n            yield val;\n            taken++;\n            if (taken >= count) {\n                break;\n            }\n        }\n    }\n    function take(count, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => take(count, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator]) {\n            return _take(count, iterable);\n        }\n        return _syncTake(count, iterable);\n    }\n\n    async function* _asyncTap(func, iterable) {\n        for await (const val of iterable) {\n            await func(val);\n            yield val;\n        }\n    }\n    function tap(func, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _asyncTap(func, curriedIterable);\n        }\n        return _asyncTap(func, iterable);\n    }\n\n    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\n    function _throttle(limit, interval, iterable) {\n        if (!Number.isFinite(limit)) {\n            throw new TypeError('Expected `limit` to be a finite number');\n        }\n        if (limit <= 0) {\n            throw new TypeError('Expected `limit` to be greater than 0');\n        }\n        if (!Number.isFinite(interval)) {\n            throw new TypeError('Expected `interval` to be a finite number');\n        }\n        return (async function* __throttle() {\n            let sent = 0;\n            let time;\n            for await (const val of iterable) {\n                if (sent < limit) {\n                    if (typeof time === 'undefined') {\n                        time = Date.now();\n                    }\n                    sent++;\n                    yield val;\n                    continue;\n                }\n                // Only wait if the interval hasn't already passed while we were\n                // yielding the previous values.\n                const elapsedMs = Date.now() - time;\n                const waitFor = interval - elapsedMs;\n                if (waitFor > 0) {\n                    await sleep(waitFor);\n                }\n                time = Date.now();\n                sent = 1;\n                yield val;\n            }\n        })();\n    }\n    function throttle(limit, interval, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n        }\n        return _throttle(limit, interval, iterable);\n    }\n\n    function addTime(a, b) {\n        let seconds = a[0] + b[0];\n        let nanoseconds = a[1] + b[1];\n        if (nanoseconds >= 1000000000) {\n            const remainder = nanoseconds % 1000000000;\n            seconds += (nanoseconds - remainder) / 1000000000;\n            nanoseconds = remainder;\n        }\n        return [seconds, nanoseconds];\n    }\n    async function* _asyncTime(config, iterable) {\n        const itr = iterable[Symbol.asyncIterator]();\n        let total = [0, 0];\n        while (true) {\n            const start = process.hrtime();\n            const { value, done } = await itr.next();\n            const delta = process.hrtime(start);\n            total = addTime(total, delta);\n            if (config.progress) {\n                config.progress(delta, total);\n            }\n            if (done) {\n                if (config.total) {\n                    config.total(total);\n                }\n                return value;\n            }\n            yield value;\n        }\n    }\n    function* _syncTime(config, iterable) {\n        const itr = iterable[Symbol.iterator]();\n        let total = [0, 0];\n        while (true) {\n            const start = process.hrtime();\n            const { value, done } = itr.next();\n            const delta = process.hrtime(start);\n            total = addTime(total, delta);\n            if (config.progress) {\n                config.progress(delta, total);\n            }\n            if (done) {\n                if (config.total) {\n                    config.total(total);\n                }\n                return value;\n            }\n            yield value;\n        }\n    }\n    function time(config = {}, iterable) {\n        if (iterable === undefined) {\n            return curriedIterable => time(config, curriedIterable);\n        }\n        if (iterable[Symbol.asyncIterator] !== undefined) {\n            return _asyncTime(config, iterable);\n        }\n        else {\n            return _syncTime(config, iterable);\n        }\n    }\n\n    function _transform(concurrency, func, iterable) {\n        const iterator = getIterator(iterable);\n        const resultQueue = [];\n        const readQueue = [];\n        let ended = false;\n        let reading = false;\n        let inflightCount = 0;\n        let lastError = null;\n        function fulfillReadQueue() {\n            while (readQueue.length > 0 && resultQueue.length > 0) {\n                const { resolve } = readQueue.shift();\n                const value = resultQueue.shift();\n                resolve({ done: false, value });\n            }\n            while (readQueue.length > 0 && inflightCount === 0 && ended) {\n                const { resolve, reject } = readQueue.shift();\n                if (lastError) {\n                    reject(lastError);\n                    lastError = null;\n                }\n                else {\n                    resolve({ done: true, value: undefined });\n                }\n            }\n        }\n        async function fillQueue() {\n            if (ended) {\n                fulfillReadQueue();\n                return;\n            }\n            if (reading) {\n                return;\n            }\n            if (inflightCount + resultQueue.length >= concurrency) {\n                return;\n            }\n            reading = true;\n            inflightCount++;\n            try {\n                const { done, value } = await iterator.next();\n                if (done) {\n                    ended = true;\n                    inflightCount--;\n                    fulfillReadQueue();\n                }\n                else {\n                    mapAndQueue(value);\n                }\n            }\n            catch (error) {\n                ended = true;\n                inflightCount--;\n                lastError = error;\n                fulfillReadQueue();\n            }\n            reading = false;\n            fillQueue();\n        }\n        async function mapAndQueue(itrValue) {\n            try {\n                const value = await func(itrValue);\n                resultQueue.push(value);\n            }\n            catch (error) {\n                ended = true;\n                lastError = error;\n            }\n            inflightCount--;\n            fulfillReadQueue();\n            fillQueue();\n        }\n        async function next() {\n            if (resultQueue.length === 0) {\n                const deferred = defer();\n                readQueue.push(deferred);\n                fillQueue();\n                return deferred.promise;\n            }\n            const value = resultQueue.shift();\n            fillQueue();\n            return { done: false, value };\n        }\n        const asyncIterableIterator = {\n            next,\n            [Symbol.asyncIterator]: () => asyncIterableIterator,\n        };\n        return asyncIterableIterator;\n    }\n    function transform(concurrency, func, iterable) {\n        if (func === undefined) {\n            return (curriedFunc, curriedIterable) => curriedIterable\n                ? transform(concurrency, curriedFunc, curriedIterable)\n                : transform(concurrency, curriedFunc);\n        }\n        if (iterable === undefined) {\n            return (curriedIterable) => transform(concurrency, func, curriedIterable);\n        }\n        return _transform(concurrency, func, iterable);\n    }\n\n    async function _writeToStream(stream, iterable) {\n        let lastError = null;\n        let errCb = null;\n        let drainCb = null;\n        const notifyError = err => {\n            lastError = err;\n            if (errCb) {\n                errCb(err);\n            }\n        };\n        const notifyDrain = () => {\n            if (drainCb) {\n                drainCb();\n            }\n        };\n        const cleanup = () => {\n            stream.removeListener('error', notifyError);\n            stream.removeListener('drain', notifyDrain);\n        };\n        stream.once('error', notifyError);\n        const waitForDrain = () => new Promise((resolve, reject) => {\n            if (lastError) {\n                return reject(lastError);\n            }\n            stream.once('drain', notifyDrain);\n            drainCb = resolve;\n            errCb = reject;\n        });\n        for await (const value of iterable) {\n            if (stream.write(value) === false) {\n                await waitForDrain();\n            }\n            if (lastError) {\n                break;\n            }\n        }\n        cleanup();\n        if (lastError) {\n            throw lastError;\n        }\n    }\n    function writeToStream(stream, iterable) {\n        if (iterable === undefined) {\n            return (curriedIterable) => _writeToStream(stream, curriedIterable);\n        }\n        return _writeToStream(stream, iterable);\n    }\n\n    exports.batch = batch;\n    exports.batchWithTimeout = batchWithTimeout;\n    exports.buffer = buffer;\n    exports.collect = collect;\n    exports.concat = concat;\n    exports.consume = consume;\n    exports.filter = filter;\n    exports.flatMap = flatMap;\n    exports.flatTransform = flatTransform;\n    exports.flatten = flatten;\n    exports.fromStream = fromStream;\n    exports.getIterator = getIterator;\n    exports.map = map;\n    exports.merge = merge;\n    exports.parallelFlatMap = parallelFlatMap;\n    exports.parallelMap = parallelMap;\n    exports.parallelMerge = parallelMerge;\n    exports.pipeline = pipeline;\n    exports.reduce = reduce;\n    exports.take = take;\n    exports.tap = tap;\n    exports.throttle = throttle;\n    exports.time = time;\n    exports.transform = transform;\n    exports.writeToStream = writeToStream;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}