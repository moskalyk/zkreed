{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst all = require('it-all');\n\nconst filter = require('it-filter');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n});\n\nconst errCode = require('err-code');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  TimeoutController\n} = require('timeout-abort-controller');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst {\n  anySignal\n} = require('any-signal'); // @ts-expect-error setMaxListeners is missing from the types\n\n\nconst {\n  setMaxListeners\n} = require('events');\n\nconst DialRequest = require('./dial-request');\n\nconst {\n  publicAddressesFirst\n} = require('libp2p-utils/src/address-sort');\n\nconst getPeer = require('../get-peer');\n\nconst trackedMap = require('../metrics/tracked-map');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants');\n\nconst METRICS_COMPONENT = 'dialler';\nconst METRICS_PENDING_DIALS = 'pending-dials';\nconst METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets';\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store/types').PeerStore} PeerStore\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n * @typedef {import('../types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n * @property {ConnectionGater} connectionGater\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n * @property {import('../metrics')} [metrics]\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {import('./dial-request')} dialRequest\n * @property {import('timeout-abort-controller').TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor(_ref) {\n    let {\n      transportManager,\n      peerStore,\n      connectionGater,\n      addressSorter = publicAddressesFirst,\n      maxParallelDials = MAX_PARALLEL_DIALS,\n      maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n      dialTimeout = DIAL_TIMEOUT,\n      maxDialsPerPeer = MAX_PER_PEER_DIALS,\n      resolvers = {},\n      metrics\n    } = _ref;\n    this.connectionGater = connectionGater;\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.addressSorter = addressSorter;\n    this.maxParallelDials = maxParallelDials;\n    this.maxAddrsToDial = maxAddrsToDial;\n    this.timeout = dialTimeout;\n    this.maxDialsPerPeer = maxDialsPerPeer;\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);\n    /** @type {Map<string, PendingDial>} */\n\n    this._pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics\n    });\n    /** @type {Map<string, { resolve: (value: any) => void, reject: (err: Error) => void}>} */\n\n    this._pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics\n    });\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value);\n    }\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (\n      /** @type {any} */\n      err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'));\n    }\n\n    this._pendingDialTargets.clear();\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      id\n    } = getPeer(peer);\n\n    if (await this.connectionGater.denyDialPeer(id)) {\n      throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED);\n    }\n\n    const dialTarget = await this._createCancellableDialTarget(peer);\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (\n    /** @type {any} */\n    err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createCancellableDialTarget(peer) {\n    // Make dial target promise cancellable\n    const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, {\n        resolve,\n        reject\n      });\n    });\n\n    try {\n      const dialTarget = await Promise.race([this._createDialTarget(peer), cancellablePromise]);\n      return dialTarget;\n    } finally {\n      this._pendingDialTargets.delete(id);\n    }\n  }\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n\n\n  async _createDialTarget(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    let knownAddrs = await pipe(await this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter), source => filter(source, async multiaddr => {\n      return !(await this.connectionGater.denyDialMultiaddr(id, multiaddr));\n    }), source => all(source)); // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter(addr => !peer.equals(addr));\n      knownAddrs.unshift(peer);\n    }\n    /** @type {Multiaddr[]} */\n\n\n    const addrs = [];\n\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a);\n      resolvedAddrs.forEach(ra => addrs.push(ra));\n    } // Multiaddrs not supported by the available transports will be filtered out.\n\n\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a));\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      await this.peerStore.delete(id);\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES);\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    };\n  }\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals); // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n\n    try {\n      // fails on node < 15.4\n      setMaxListeners && setMaxListeners(Infinity, signal);\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n  /**\n   * @param {number} num\n   */\n\n\n  getTokens(num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n  /**\n   * @param {number} token\n   */\n\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolve(ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr'); // Multiaddr is not resolvable? End recursion!\n\n    if (!resolvableProto) {\n      return [ma];\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma);\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map(nm => {\n      return this._resolve(nm);\n    }));\n    const addrs = recursiveMultiaddrs.flat();\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM);\n      }\n\n      return array;\n    },\n    /** @type  {Multiaddr[]} */\n    []);\n  }\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n\n\n  async _resolveRecord(ma) {\n    try {\n      ma = new Multiaddr(ma.toString()); // Use current multiaddr module\n\n      const multiaddrs = await ma.resolve();\n      return multiaddrs;\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`);\n      return [];\n    }\n  }\n\n}\n\nmodule.exports = Dialer;","map":{"version":3,"names":["debug","require","all","filter","pipe","log","Object","assign","error","errCode","Multiaddr","TimeoutController","AbortError","anySignal","setMaxListeners","DialRequest","publicAddressesFirst","getPeer","trackedMap","codes","DIAL_TIMEOUT","MAX_PARALLEL_DIALS","MAX_PER_PEER_DIALS","MAX_ADDRS_TO_DIAL","METRICS_COMPONENT","METRICS_PENDING_DIALS","METRICS_PENDING_DIAL_TARGETS","Dialer","constructor","transportManager","peerStore","connectionGater","addressSorter","maxParallelDials","maxAddrsToDial","dialTimeout","maxDialsPerPeer","resolvers","metrics","timeout","tokens","Array","map","_","index","_pendingDials","component","metric","_pendingDialTargets","key","value","entries","set","destroy","dial","values","controller","abort","err","clear","pendingTarget","reject","connectToPeer","peer","options","id","denyDialPeer","Error","ERR_PEER_DIAL_INTERCEPTED","dialTarget","_createCancellableDialTarget","addrs","length","ERR_NO_VALID_ADDRESSES","pendingDial","get","_createPendingDial","connection","promise","signal","aborted","code","ERR_TIMEOUT","parseInt","String","Math","random","toString","Date","now","cancellablePromise","Promise","resolve","race","_createDialTarget","delete","multiaddrs","addressBook","add","knownAddrs","getMultiaddrsForPeer","source","multiaddr","denyDialMultiaddr","isMultiaddr","addr","equals","unshift","a","resolvedAddrs","_resolve","forEach","ra","push","supportedAddrs","transportForMultiaddr","ERR_TOO_MANY_ADDRESSES","toB58String","dialAction","ERR_ALREADY_ABORTED","dialRequest","dialer","timeoutController","signals","Infinity","run","getTokens","num","total","min","splice","releaseToken","token","indexOf","ma","resolvableProto","protoNames","includes","resolvedMultiaddrs","_resolveRecord","recursiveMultiaddrs","nm","flat","reduce","array","newM","find","m","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/dialer/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst all = require('it-all')\nconst filter = require('it-filter')\nconst { pipe } = require('it-pipe')\nconst log = Object.assign(debug('libp2p:dialer'), {\n  error: debug('libp2p:dialer:err')\n})\nconst errCode = require('err-code')\nconst { Multiaddr } = require('multiaddr')\nconst { TimeoutController } = require('timeout-abort-controller')\nconst { AbortError } = require('abortable-iterator')\nconst { anySignal } = require('any-signal')\n// @ts-expect-error setMaxListeners is missing from the types\nconst { setMaxListeners } = require('events')\nconst DialRequest = require('./dial-request')\nconst { publicAddressesFirst } = require('libp2p-utils/src/address-sort')\nconst getPeer = require('../get-peer')\nconst trackedMap = require('../metrics/tracked-map')\nconst { codes } = require('../errors')\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS,\n  MAX_ADDRS_TO_DIAL\n} = require('../constants')\n\nconst METRICS_COMPONENT = 'dialler'\nconst METRICS_PENDING_DIALS = 'pending-dials'\nconst METRICS_PENDING_DIAL_TARGETS = 'pending-dial-targets'\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('../peer-store/types').PeerStore} PeerStore\n * @typedef {import('../peer-store/types').Address} Address\n * @typedef {import('../transport-manager')} TransportManager\n * @typedef {import('../types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef {Object} DialerProperties\n * @property {PeerStore} peerStore\n * @property {TransportManager} transportManager\n * @property {ConnectionGater} connectionGater\n *\n * @typedef {(addr:Multiaddr) => Promise<string[]>} Resolver\n *\n * @typedef {Object} DialerOptions\n * @property {(addresses: Address[]) => Address[]} [options.addressSorter = publicAddressesFirst] - Sort the known addresses of a peer before trying to dial.\n * @property {number} [maxParallelDials = MAX_PARALLEL_DIALS] - Number of max concurrent dials.\n * @property {number} [maxAddrsToDial = MAX_ADDRS_TO_DIAL] - Number of max addresses to dial for a given peer.\n * @property {number} [maxDialsPerPeer = MAX_PER_PEER_DIALS] - Number of max concurrent dials per peer.\n * @property {number} [dialTimeout = DIAL_TIMEOUT] - How long a dial attempt is allowed to take.\n * @property {Record<string, Resolver>} [resolvers = {}] - multiaddr resolvers to use when dialing\n * @property {import('../metrics')} [metrics]\n *\n * @typedef DialTarget\n * @property {string} id\n * @property {Multiaddr[]} addrs\n *\n * @typedef PendingDial\n * @property {import('./dial-request')} dialRequest\n * @property {import('timeout-abort-controller').TimeoutController} controller\n * @property {Promise<Connection>} promise\n * @property {function():void} destroy\n */\n\nclass Dialer {\n  /**\n   * @class\n   * @param {DialerProperties & DialerOptions} options\n   */\n  constructor ({\n    transportManager,\n    peerStore,\n    connectionGater,\n    addressSorter = publicAddressesFirst,\n    maxParallelDials = MAX_PARALLEL_DIALS,\n    maxAddrsToDial = MAX_ADDRS_TO_DIAL,\n    dialTimeout = DIAL_TIMEOUT,\n    maxDialsPerPeer = MAX_PER_PEER_DIALS,\n    resolvers = {},\n    metrics\n  }) {\n    this.connectionGater = connectionGater\n    this.transportManager = transportManager\n    this.peerStore = peerStore\n    this.addressSorter = addressSorter\n    this.maxParallelDials = maxParallelDials\n    this.maxAddrsToDial = maxAddrsToDial\n    this.timeout = dialTimeout\n    this.maxDialsPerPeer = maxDialsPerPeer\n    this.tokens = [...new Array(maxParallelDials)].map((_, index) => index)\n\n    /** @type {Map<string, PendingDial>} */\n    this._pendingDials = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIALS,\n      metrics\n    })\n\n    /** @type {Map<string, { resolve: (value: any) => void, reject: (err: Error) => void}>} */\n    this._pendingDialTargets = trackedMap({\n      component: METRICS_COMPONENT,\n      metric: METRICS_PENDING_DIAL_TARGETS,\n      metrics\n    })\n\n    for (const [key, value] of Object.entries(resolvers)) {\n      Multiaddr.resolvers.set(key, value)\n    }\n  }\n\n  /**\n   * Clears any pending dials\n   */\n  destroy () {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort()\n      } catch (/** @type {any} */ err) {\n        log.error(err)\n      }\n    }\n    this._pendingDials.clear()\n\n    for (const pendingTarget of this._pendingDialTargets.values()) {\n      pendingTarget.reject(new AbortError('Dialer was destroyed'))\n    }\n    this._pendingDialTargets.clear()\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n  async connectToPeer (peer, options = {}) {\n    const { id } = getPeer(peer)\n\n    if (await this.connectionGater.denyDialPeer(id)) {\n      throw errCode(new Error('The dial request is blocked by gater.allowDialPeer'), codes.ERR_PEER_DIAL_INTERCEPTED)\n    }\n\n    const dialTarget = await this._createCancellableDialTarget(peer)\n\n    if (!dialTarget.addrs.length) {\n      throw errCode(new Error('The dial request has no valid addresses'), codes.ERR_NO_VALID_ADDRESSES)\n    }\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options)\n\n    try {\n      const connection = await pendingDial.promise\n      log('dial succeeded to %s', dialTarget.id)\n      return connection\n    } catch (/** @type {any} */ err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT\n      }\n      log.error(err)\n      throw err\n    } finally {\n      pendingDial.destroy()\n    }\n  }\n\n  /**\n   * Connects to a given `peer` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @returns {Promise<DialTarget>}\n   */\n  async _createCancellableDialTarget (peer) {\n    // Make dial target promise cancellable\n    const id = `${(parseInt(String(Math.random() * 1e9), 10)).toString() + Date.now()}`\n    const cancellablePromise = new Promise((resolve, reject) => {\n      this._pendingDialTargets.set(id, { resolve, reject })\n    })\n\n    try {\n      const dialTarget = await Promise.race([\n        this._createDialTarget(peer),\n        cancellablePromise\n      ])\n\n      return dialTarget\n    } finally {\n      this._pendingDialTargets.delete(id)\n    }\n  }\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * If a multiaddr is received it should be the first address attempted.\n   * Multiaddrs not supported by the available transports will be filtered out.\n   *\n   * @private\n   * @param {PeerId|Multiaddr|string} peer - A PeerId or Multiaddr\n   * @returns {Promise<DialTarget>}\n   */\n  async _createDialTarget (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    let knownAddrs = await pipe(\n      await this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter),\n      (source) => filter(source, async (multiaddr) => {\n        return !(await this.connectionGater.denyDialMultiaddr(id, multiaddr))\n      }),\n      (source) => all(source)\n    )\n\n    // If received a multiaddr to dial, it should be the first to use\n    // But, if we know other multiaddrs for the peer, we should try them too.\n    if (Multiaddr.isMultiaddr(peer)) {\n      knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr))\n      knownAddrs.unshift(peer)\n    }\n\n    /** @type {Multiaddr[]} */\n    const addrs = []\n    for (const a of knownAddrs) {\n      const resolvedAddrs = await this._resolve(a)\n      resolvedAddrs.forEach(ra => addrs.push(ra))\n    }\n\n    // Multiaddrs not supported by the available transports will be filtered out.\n    const supportedAddrs = addrs.filter(a => this.transportManager.transportForMultiaddr(a))\n\n    if (supportedAddrs.length > this.maxAddrsToDial) {\n      await this.peerStore.delete(id)\n      throw errCode(new Error('dial with more addresses than allowed'), codes.ERR_TOO_MANY_ADDRESSES)\n    }\n\n    return {\n      id: id.toB58String(),\n      addrs: supportedAddrs\n    }\n  }\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   *\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] - An AbortController signal\n   * @returns {PendingDial}\n   */\n  _createPendingDial (dialTarget, options = {}) {\n    /**\n     * @param {Multiaddr} addr\n     * @param {{ signal: { aborted: any; }; }} options\n     */\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED)\n      return this.transportManager.dial(addr, options)\n    }\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    })\n\n    // Combine the timeout signal and options.signal, if provided\n    const timeoutController = new TimeoutController(this.timeout)\n\n    const signals = [timeoutController.signal]\n    options.signal && signals.push(options.signal)\n    const signal = anySignal(signals)\n\n    // this signal will potentially be used while dialing lots of\n    // peers so prevent MaxListenersExceededWarning appearing in the console\n    try {\n      // fails on node < 15.4\n      setMaxListeners && setMaxListeners(Infinity, signal)\n    } catch {}\n\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options, signal }),\n      destroy: () => {\n        timeoutController.clear()\n        this._pendingDials.delete(dialTarget.id)\n      }\n    }\n    this._pendingDials.set(dialTarget.id, pendingDial)\n\n    return pendingDial\n  }\n\n  /**\n   * @param {number} num\n   */\n  getTokens (num) {\n    const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length)\n    const tokens = this.tokens.splice(0, total)\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length)\n    return tokens\n  }\n\n  /**\n   * @param {number} token\n   */\n  releaseToken (token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return\n    log('token %d released', token)\n    this.tokens.push(token)\n  }\n\n  /**\n   * Resolve multiaddr recursively.\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolve (ma) {\n    // TODO: recursive logic should live in multiaddr once dns4/dns6 support is in place\n    // Now only supporting resolve for dnsaddr\n    const resolvableProto = ma.protoNames().includes('dnsaddr')\n\n    // Multiaddr is not resolvable? End recursion!\n    if (!resolvableProto) {\n      return [ma]\n    }\n\n    const resolvedMultiaddrs = await this._resolveRecord(ma)\n    const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {\n      return this._resolve(nm)\n    }))\n\n    const addrs = recursiveMultiaddrs.flat()\n    return addrs.reduce((array, newM) => {\n      if (!array.find(m => m.equals(newM))) {\n        array.push(newM)\n      }\n      return array\n    }, /** @type  {Multiaddr[]} */([]))\n  }\n\n  /**\n   * Resolve a given multiaddr. If this fails, an empty array will be returned\n   *\n   * @param {Multiaddr} ma\n   * @returns {Promise<Multiaddr[]>}\n   */\n  async _resolveRecord (ma) {\n    try {\n      ma = new Multiaddr(ma.toString()) // Use current multiaddr module\n      const multiaddrs = await ma.resolve()\n      return multiaddrs\n    } catch (_) {\n      log.error(`multiaddr ${ma} could not be resolved`)\n      return []\n    }\n  }\n}\n\nmodule.exports = Dialer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}