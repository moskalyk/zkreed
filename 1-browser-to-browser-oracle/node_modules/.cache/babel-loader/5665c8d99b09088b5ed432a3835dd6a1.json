{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __asyncValues = this && this.__asyncValues || function (o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator],\n      i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () {\n    return this;\n  }, i);\n\n  function verb(n) {\n    i[n] = o[n] && function (v) {\n      return new Promise(function (resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function (v) {\n      resolve({\n        value: v,\n        done: d\n      });\n    }, reject);\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FluenceConnection = exports.PROTOCOL_NAME = void 0;\n/*\n * Copyright 2020 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// @ts-ignore\n\nvar libp2p_websockets_1 = __importDefault(require(\"libp2p-websockets\")); // @ts-ignore\n\n\nvar libp2p_mplex_1 = __importDefault(require(\"libp2p-mplex\"));\n\nvar libp2p_1 = __importDefault(require(\"libp2p\"));\n\nvar it_length_prefixed_1 = require(\"it-length-prefixed\");\n\nvar it_pipe_1 = require(\"it-pipe\");\n\nvar log = __importStar(require(\"loglevel\"));\n\nvar libp2p_noise_1 = require(\"@chainsafe/libp2p-noise\");\n\nvar Particle_1 = require(\"./Particle\"); // @ts-ignore\n\n\nvar filters_1 = require(\"libp2p-websockets/src/filters\");\n\nvar Buffer_1 = __importDefault(require(\"./Buffer\"));\n\nexports.PROTOCOL_NAME = '/fluence/particle/2.0.0';\n\nvar FluenceConnection =\n/** @class */\nfunction () {\n  function FluenceConnection(_lib2p2Peer, _relayAddress) {\n    this._lib2p2Peer = _lib2p2Peer;\n    this._relayAddress = _relayAddress;\n  }\n\n  FluenceConnection.createConnection = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var transportKey, lib2p2Peer, relayAddress;\n\n      var _a;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            transportKey = libp2p_websockets_1.default.prototype[Symbol.toStringTag];\n            return [4\n            /*yield*/\n            , libp2p_1.default.create({\n              peerId: options.peerId,\n              modules: {\n                transport: [libp2p_websockets_1.default],\n                streamMuxer: [libp2p_mplex_1.default],\n                connEncryption: [new libp2p_noise_1.Noise()]\n              },\n              config: {\n                transport: (_a = {}, _a[transportKey] = {\n                  filter: filters_1.all\n                }, _a)\n              },\n              dialer: {\n                dialTimeout: options === null || options === void 0 ? void 0 : options.dialTimeoutMs\n              }\n            })];\n\n          case 1:\n            lib2p2Peer = _b.sent();\n            lib2p2Peer.handle([exports.PROTOCOL_NAME], function (_a) {\n              var connection = _a.connection,\n                  stream = _a.stream;\n              return __awaiter(_this, void 0, void 0, function () {\n                var _this = this;\n\n                return __generator(this, function (_b) {\n                  (0, it_pipe_1.pipe)(stream.source, // @ts-ignore\n                  (0, it_length_prefixed_1.decode)(), function (source) {\n                    var source_1, source_1_1;\n                    return __awaiter(_this, void 0, void 0, function () {\n                      var msg, particle, e_1_1, e_2;\n\n                      var e_1, _a;\n\n                      return __generator(this, function (_b) {\n                        switch (_b.label) {\n                          case 0:\n                            _b.trys.push([0, 13,, 14]);\n\n                            _b.label = 1;\n\n                          case 1:\n                            _b.trys.push([1, 6, 7, 12]);\n\n                            source_1 = __asyncValues(source);\n                            _b.label = 2;\n\n                          case 2:\n                            return [4\n                            /*yield*/\n                            , source_1.next()];\n\n                          case 3:\n                            if (!(source_1_1 = _b.sent(), !source_1_1.done)) return [3\n                            /*break*/\n                            , 5];\n                            msg = source_1_1.value;\n\n                            try {\n                              particle = Particle_1.Particle.fromString(msg);\n                              options.onIncomingParticle(particle);\n                            } catch (e) {\n                              log.error('error on handling a new incoming message: ' + e);\n                            }\n\n                            _b.label = 4;\n\n                          case 4:\n                            return [3\n                            /*break*/\n                            , 2];\n\n                          case 5:\n                            return [3\n                            /*break*/\n                            , 12];\n\n                          case 6:\n                            e_1_1 = _b.sent();\n                            e_1 = {\n                              error: e_1_1\n                            };\n                            return [3\n                            /*break*/\n                            , 12];\n\n                          case 7:\n                            _b.trys.push([7,, 10, 11]);\n\n                            if (!(source_1_1 && !source_1_1.done && (_a = source_1.return))) return [3\n                            /*break*/\n                            , 9];\n                            return [4\n                            /*yield*/\n                            , _a.call(source_1)];\n\n                          case 8:\n                            _b.sent();\n\n                            _b.label = 9;\n\n                          case 9:\n                            return [3\n                            /*break*/\n                            , 11];\n\n                          case 10:\n                            if (e_1) throw e_1.error;\n                            return [7\n                            /*endfinally*/\n                            ];\n\n                          case 11:\n                            return [7\n                            /*endfinally*/\n                            ];\n\n                          case 12:\n                            return [3\n                            /*break*/\n                            , 14];\n\n                          case 13:\n                            e_2 = _b.sent();\n                            log.debug('connection closed: ' + e_2);\n                            return [3\n                            /*break*/\n                            , 14];\n\n                          case 14:\n                            return [2\n                            /*return*/\n                            ];\n                        }\n                      });\n                    });\n                  });\n                  return [2\n                  /*return*/\n                  ];\n                });\n              });\n            });\n            relayAddress = options.relayAddress;\n            return [2\n            /*return*/\n            , new FluenceConnection(lib2p2Peer, relayAddress)];\n        }\n      });\n    });\n  };\n\n  FluenceConnection.prototype.disconnect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._lib2p2Peer.stop()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  FluenceConnection.prototype.sendParticle = function (particle) {\n    return __awaiter(this, void 0, void 0, function () {\n      var conn, sink;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            particle.logTo('debug', 'sending particle:');\n            return [4\n            /*yield*/\n            , this._lib2p2Peer.dialProtocol(this._relayAddress, exports.PROTOCOL_NAME)];\n\n          case 1:\n            conn = _a.sent();\n            sink = conn.stream.sink;\n            (0, it_pipe_1.pipe)( // force new line\n            [Buffer_1.default.from(particle.toString(), 'utf8')], (0, it_length_prefixed_1.encode)(), sink);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  FluenceConnection.prototype.connect = function () {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var _b, e_3, error;\n\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._lib2p2Peer.start()];\n\n          case 1:\n            _c.sent();\n\n            log.debug(\"dialing to the node with client's address: \" + this._lib2p2Peer.peerId.toB58String());\n            _c.label = 2;\n\n          case 2:\n            _c.trys.push([2, 4,, 5]);\n\n            _b = this;\n            return [4\n            /*yield*/\n            , this._lib2p2Peer.dial(this._relayAddress)];\n\n          case 3:\n            _b._connection = _c.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_3 = _c.sent();\n\n            if (e_3.name === 'AggregateError' && ((_a = e_3._errors) === null || _a === void 0 ? void 0 : _a.length) === 1) {\n              error = e_3._errors[0];\n              throw new Error(\"Error dialing node \".concat(this._relayAddress, \":\\n\").concat(error.code, \"\\n\").concat(error.message));\n            } else {\n              throw e_3;\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return FluenceConnection;\n}();\n\nexports.FluenceConnection = FluenceConnection;","map":{"version":3,"mappings":"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","names":["exports","_lib2p2Peer","_relayAddress","FluenceConnection","options","transportKey","libp2p_websockets_1","prototype","Symbol","toStringTag","libp2p_1","create","peerId","modules","transport","streamMuxer","libp2p_mplex_1","connEncryption","libp2p_noise_1","config","_a","filter","filters_1","dialer","dialTimeout","dialTimeoutMs","lib2p2Peer","_b","handle","connection","stream","source","source_1","msg","particle","Particle_1","fromString","onIncomingParticle","e","log","error","debug","e_2","relayAddress","stop","logTo","dialProtocol","conn","sink","Buffer_1","from","toString","start","_c","toB58String","dial","_connection","e_3","name","_errors","length","Error","concat","code","message"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/FluenceConnection.ts"],"sourcesContent":["/*\n * Copyright 2020 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// @ts-ignore\nimport Websockets from 'libp2p-websockets';\n// @ts-ignore\nimport Mplex from 'libp2p-mplex';\nimport Lib2p2Peer from 'libp2p';\nimport { decode, encode } from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport * as log from 'loglevel';\nimport { Noise } from '@chainsafe/libp2p-noise';\nimport { Particle } from './Particle';\nimport PeerId from 'peer-id';\nimport { Multiaddr } from 'multiaddr';\n// @ts-ignore\nimport { all as allow_all } from 'libp2p-websockets/src/filters';\nimport { Connection } from 'libp2p-interfaces/src/topology';\nimport Buffer from './Buffer';\n\nexport const PROTOCOL_NAME = '/fluence/particle/2.0.0';\n\n/**\n * Options to configure fluence connection\n */\nexport interface FluenceConnectionOptions {\n    /**\n     * Peer id of the Fluence Peer\n     */\n    peerId: PeerId;\n\n    /**\n     * Multiaddress of the relay to make connection to\n     */\n    relayAddress: Multiaddr;\n\n    /**\n     * The dialing timeout in milliseconds\n     */\n    dialTimeoutMs?: number;\n\n    /**\n     * Handler for incoming particles from the connection\n     */\n    onIncomingParticle: (p: Particle) => void;\n}\n\nexport class FluenceConnection {\n    constructor(private _lib2p2Peer: Lib2p2Peer, private _relayAddress: Multiaddr) {}\n\n    private _connection?: Connection;\n\n    static async createConnection(options: FluenceConnectionOptions): Promise<FluenceConnection> {\n        const transportKey = Websockets.prototype[Symbol.toStringTag];\n        const lib2p2Peer = await Lib2p2Peer.create({\n            peerId: options.peerId,\n            modules: {\n                transport: [Websockets],\n                streamMuxer: [Mplex],\n                connEncryption: [new Noise()],\n            },\n            config: {\n                transport: {\n                    [transportKey]: {\n                        filter: allow_all,\n                    },\n                },\n            },\n            dialer: {\n                dialTimeout: options?.dialTimeoutMs,\n            },\n        });\n\n        lib2p2Peer.handle([PROTOCOL_NAME], async ({ connection, stream }) => {\n            pipe(\n                stream.source,\n                // @ts-ignore\n                decode(),\n                async (source: AsyncIterable<string>) => {\n                    try {\n                        for await (const msg of source) {\n                            try {\n                                const particle = Particle.fromString(msg);\n                                options.onIncomingParticle(particle);\n                            } catch (e) {\n                                log.error('error on handling a new incoming message: ' + e);\n                            }\n                        }\n                    } catch (e) {\n                        log.debug('connection closed: ' + e);\n                    }\n                },\n            );\n        });\n\n        const relayAddress = options.relayAddress;\n\n        return new FluenceConnection(lib2p2Peer, relayAddress);\n    }\n\n    async disconnect() {\n        await this._lib2p2Peer.stop();\n    }\n\n    async sendParticle(particle: Particle): Promise<void> {\n        particle.logTo('debug', 'sending particle:');\n\n        /*\n        TODO:: find out why this doesn't work and a new connection has to be established each time\n        if (this._connection.streams.length !== 1) {\n            throw new Error('Incorrect number of streams in FluenceConnection');\n        }\n\n        const sink = this._connection.streams[0].sink;\n        */\n\n        const conn = await this._lib2p2Peer.dialProtocol(this._relayAddress, PROTOCOL_NAME);\n        const sink = conn.stream.sink;\n\n        pipe(\n            // force new line\n            [Buffer.from(particle.toString(), 'utf8')],\n            encode(),\n            sink,\n        );\n    }\n\n    async connect() {\n        await this._lib2p2Peer.start();\n\n        log.debug(`dialing to the node with client's address: ` + this._lib2p2Peer.peerId.toB58String());\n\n        try {\n            this._connection = await this._lib2p2Peer.dial(this._relayAddress);\n        } catch (e: any) {\n            if (e.name === 'AggregateError' && e._errors?.length === 1) {\n                const error = e._errors[0];\n                throw new Error(`Error dialing node ${this._relayAddress}:\\n${error.code}\\n${error.message}`);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}