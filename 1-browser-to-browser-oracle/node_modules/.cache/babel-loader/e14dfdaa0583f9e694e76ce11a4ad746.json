{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = exports.Thread = exports.PoolEventType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst observable_fns_1 = require(\"observable-fns\");\n\nconst ponyfills_1 = require(\"../ponyfills\");\n\nconst implementation_1 = require(\"./implementation\");\n\nconst pool_types_1 = require(\"./pool-types\");\n\nObject.defineProperty(exports, \"PoolEventType\", {\n  enumerable: true,\n  get: function () {\n    return pool_types_1.PoolEventType;\n  }\n});\n\nconst thread_1 = require(\"./thread\");\n\nObject.defineProperty(exports, \"Thread\", {\n  enumerable: true,\n  get: function () {\n    return thread_1.Thread;\n  }\n});\nlet nextPoolID = 1;\n\nfunction createArray(size) {\n  const array = [];\n\n  for (let index = 0; index < size; index++) {\n    array.push(index);\n  }\n\n  return array;\n}\n\nfunction delay(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction flatMap(array, mapper) {\n  return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\n\nfunction slugify(text) {\n  return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\n\nfunction spawnWorkers(spawnWorker, count) {\n  return createArray(count).map(() => ({\n    init: spawnWorker(),\n    runningTasks: []\n  }));\n}\n\nclass WorkerPool {\n  constructor(spawnWorker, optionsOrSize) {\n    this.eventSubject = new observable_fns_1.Subject();\n    this.initErrors = [];\n    this.isClosing = false;\n    this.nextTaskID = 1;\n    this.taskQueue = [];\n    const options = typeof optionsOrSize === \"number\" ? {\n      size: optionsOrSize\n    } : optionsOrSize || {};\n    const {\n      size = implementation_1.defaultPoolSize\n    } = options;\n    this.debug = debug_1.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n    this.options = options;\n    this.workers = spawnWorkers(spawnWorker, size);\n    this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));\n    Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n      type: pool_types_1.PoolEventType.initialized,\n      size: this.workers.length\n    }), error => {\n      this.debug(\"Error while initializing pool worker:\", error);\n      this.eventSubject.error(error);\n      this.initErrors.push(error);\n    });\n  }\n\n  findIdlingWorker() {\n    const {\n      concurrency = 1\n    } = this.options;\n    return this.workers.find(worker => worker.runningTasks.length < concurrency);\n  }\n\n  runPoolTask(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const workerID = this.workers.indexOf(worker) + 1;\n      this.debug(`Running task #${task.id} on worker #${workerID}...`);\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.taskStart,\n        taskID: task.id,\n        workerID\n      });\n\n      try {\n        const returnValue = yield task.run(yield worker.init);\n        this.debug(`Task #${task.id} completed successfully`);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskCompleted,\n          returnValue,\n          taskID: task.id,\n          workerID\n        });\n      } catch (error) {\n        this.debug(`Task #${task.id} failed`);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskFailed,\n          taskID: task.id,\n          error,\n          workerID\n        });\n      }\n    });\n  }\n\n  run(worker, task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n        const removeTaskFromWorkersRunningTasks = () => {\n          worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n        }; // Defer task execution by one tick to give handlers time to subscribe\n\n\n        yield delay(0);\n\n        try {\n          yield this.runPoolTask(worker, task);\n        } finally {\n          removeTaskFromWorkersRunningTasks();\n\n          if (!this.isClosing) {\n            this.scheduleWork();\n          }\n        }\n      }))();\n\n      worker.runningTasks.push(runPromise);\n    });\n  }\n\n  scheduleWork() {\n    this.debug(`Attempt de-queueing a task in order to run it...`);\n    const availableWorker = this.findIdlingWorker();\n    if (!availableWorker) return;\n    const nextTask = this.taskQueue.shift();\n\n    if (!nextTask) {\n      this.debug(`Task queue is empty`);\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.taskQueueDrained\n      });\n      return;\n    }\n\n    this.run(availableWorker, nextTask);\n  }\n\n  taskCompletion(taskID) {\n    return new Promise((resolve, reject) => {\n      const eventSubscription = this.events().subscribe(event => {\n        if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          resolve(event.returnValue);\n        } else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {\n          eventSubscription.unsubscribe();\n          reject(event.error);\n        } else if (event.type === pool_types_1.PoolEventType.terminated) {\n          eventSubscription.unsubscribe();\n          reject(Error(\"Pool has been terminated before task was run.\"));\n        }\n      });\n    });\n  }\n\n  settled() {\n    let allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n\n      const taskFailures = [];\n      const failureSubscription = this.eventObservable.subscribe(event => {\n        if (event.type === pool_types_1.PoolEventType.taskFailed) {\n          taskFailures.push(event.error);\n        }\n      });\n\n      if (this.initErrors.length > 0) {\n        return Promise.reject(this.initErrors[0]);\n      }\n\n      if (allowResolvingImmediately && this.taskQueue.length === 0) {\n        yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n        return taskFailures;\n      }\n\n      yield new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(void 0);\n            }\n          },\n\n          error: reject // make a pool-wide error reject the completed() result promise\n\n        });\n      });\n      yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n      failureSubscription.unsubscribe();\n      return taskFailures;\n    });\n  }\n\n  completed() {\n    let allowResolvingImmediately = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      const settlementPromise = this.settled(allowResolvingImmediately);\n      const earlyExitPromise = new Promise((resolve, reject) => {\n        const subscription = this.eventObservable.subscribe({\n          next(event) {\n            if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n              subscription.unsubscribe();\n              resolve(settlementPromise);\n            } else if (event.type === pool_types_1.PoolEventType.taskFailed) {\n              subscription.unsubscribe();\n              reject(event.error);\n            }\n          },\n\n          error: reject // make a pool-wide error reject the completed() result promise\n\n        });\n      });\n      const errors = yield Promise.race([settlementPromise, earlyExitPromise]);\n\n      if (errors.length > 0) {\n        throw errors[0];\n      }\n    });\n  }\n\n  events() {\n    return this.eventObservable;\n  }\n\n  queue(taskFunction) {\n    const {\n      maxQueuedJobs = Infinity\n    } = this.options;\n\n    if (this.isClosing) {\n      throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n    }\n\n    if (this.initErrors.length > 0) {\n      throw this.initErrors[0];\n    }\n\n    const taskID = this.nextTaskID++;\n    const taskCompletion = this.taskCompletion(taskID);\n    taskCompletion.catch(error => {\n      // Prevent unhandled rejections here as we assume the user will use\n      // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n      this.debug(`Task #${taskID} errored:`, error);\n    });\n    const task = {\n      id: taskID,\n      run: taskFunction,\n      cancel: () => {\n        if (this.taskQueue.indexOf(task) === -1) return;\n        this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n        this.eventSubject.next({\n          type: pool_types_1.PoolEventType.taskCanceled,\n          taskID: task.id\n        });\n      },\n      then: taskCompletion.then.bind(taskCompletion)\n    };\n\n    if (this.taskQueue.length >= maxQueuedJobs) {\n      throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" + \"This usually happens for one of two reasons: We are either at peak \" + \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n    }\n\n    this.debug(`Queueing task #${task.id}...`);\n    this.taskQueue.push(task);\n    this.eventSubject.next({\n      type: pool_types_1.PoolEventType.taskQueued,\n      taskID: task.id\n    });\n    this.scheduleWork();\n    return task;\n  }\n\n  terminate(force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.isClosing = true;\n\n      if (!force) {\n        yield this.completed(true);\n      }\n\n      this.eventSubject.next({\n        type: pool_types_1.PoolEventType.terminated,\n        remainingQueue: [...this.taskQueue]\n      });\n      this.eventSubject.complete();\n      yield Promise.all(this.workers.map(worker => __awaiter(this, void 0, void 0, function* () {\n        return thread_1.Thread.terminate(yield worker.init);\n      })));\n    });\n  }\n\n}\n\nWorkerPool.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n  // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n  // If the Pool is a class or not is an implementation detail that should not concern the user.\n  return new WorkerPool(spawnWorker, optionsOrSize);\n}\n\nPoolConstructor.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\n\nexports.Pool = PoolConstructor;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","Pool","Thread","PoolEventType","debug_1","require","observable_fns_1","ponyfills_1","implementation_1","pool_types_1","enumerable","get","thread_1","nextPoolID","createArray","size","array","index","push","delay","ms","setTimeout","flatMap","mapper","reduce","flattened","element","slugify","text","replace","trim","spawnWorkers","spawnWorker","count","map","init","runningTasks","WorkerPool","constructor","optionsOrSize","eventSubject","Subject","initErrors","isClosing","nextTaskID","taskQueue","options","defaultPoolSize","debug","default","name","String","workers","eventObservable","multicast","Observable","from","all","worker","type","initialized","length","error","findIdlingWorker","concurrency","find","runPoolTask","task","workerID","indexOf","id","taskStart","taskID","returnValue","run","taskCompleted","taskFailed","runPromise","removeTaskFromWorkersRunningTasks","filter","someRunPromise","scheduleWork","availableWorker","nextTask","shift","taskQueueDrained","taskCompletion","eventSubscription","events","subscribe","event","unsubscribe","terminated","Error","settled","allowResolvingImmediately","getCurrentlyRunningTasks","taskFailures","failureSubscription","allSettled","subscription","completed","settlementPromise","earlyExitPromise","errors","race","queue","taskFunction","maxQueuedJobs","Infinity","catch","cancel","someTask","taskCanceled","bind","taskQueued","terminate","force","remainingQueue","complete","EventType","PoolConstructor"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/threads/dist/master/pool.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pool = exports.Thread = exports.PoolEventType = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst observable_fns_1 = require(\"observable-fns\");\nconst ponyfills_1 = require(\"../ponyfills\");\nconst implementation_1 = require(\"./implementation\");\nconst pool_types_1 = require(\"./pool-types\");\nObject.defineProperty(exports, \"PoolEventType\", { enumerable: true, get: function () { return pool_types_1.PoolEventType; } });\nconst thread_1 = require(\"./thread\");\nObject.defineProperty(exports, \"Thread\", { enumerable: true, get: function () { return thread_1.Thread; } });\nlet nextPoolID = 1;\nfunction createArray(size) {\n    const array = [];\n    for (let index = 0; index < size; index++) {\n        array.push(index);\n    }\n    return array;\n}\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\nfunction flatMap(array, mapper) {\n    return array.reduce((flattened, element) => [...flattened, ...mapper(element)], []);\n}\nfunction slugify(text) {\n    return text.replace(/\\W/g, \" \").trim().replace(/\\s+/g, \"-\");\n}\nfunction spawnWorkers(spawnWorker, count) {\n    return createArray(count).map(() => ({\n        init: spawnWorker(),\n        runningTasks: []\n    }));\n}\nclass WorkerPool {\n    constructor(spawnWorker, optionsOrSize) {\n        this.eventSubject = new observable_fns_1.Subject();\n        this.initErrors = [];\n        this.isClosing = false;\n        this.nextTaskID = 1;\n        this.taskQueue = [];\n        const options = typeof optionsOrSize === \"number\"\n            ? { size: optionsOrSize }\n            : optionsOrSize || {};\n        const { size = implementation_1.defaultPoolSize } = options;\n        this.debug = debug_1.default(`threads:pool:${slugify(options.name || String(nextPoolID++))}`);\n        this.options = options;\n        this.workers = spawnWorkers(spawnWorker, size);\n        this.eventObservable = observable_fns_1.multicast(observable_fns_1.Observable.from(this.eventSubject));\n        Promise.all(this.workers.map(worker => worker.init)).then(() => this.eventSubject.next({\n            type: pool_types_1.PoolEventType.initialized,\n            size: this.workers.length\n        }), error => {\n            this.debug(\"Error while initializing pool worker:\", error);\n            this.eventSubject.error(error);\n            this.initErrors.push(error);\n        });\n    }\n    findIdlingWorker() {\n        const { concurrency = 1 } = this.options;\n        return this.workers.find(worker => worker.runningTasks.length < concurrency);\n    }\n    runPoolTask(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const workerID = this.workers.indexOf(worker) + 1;\n            this.debug(`Running task #${task.id} on worker #${workerID}...`);\n            this.eventSubject.next({\n                type: pool_types_1.PoolEventType.taskStart,\n                taskID: task.id,\n                workerID\n            });\n            try {\n                const returnValue = yield task.run(yield worker.init);\n                this.debug(`Task #${task.id} completed successfully`);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskCompleted,\n                    returnValue,\n                    taskID: task.id,\n                    workerID\n                });\n            }\n            catch (error) {\n                this.debug(`Task #${task.id} failed`);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskFailed,\n                    taskID: task.id,\n                    error,\n                    workerID\n                });\n            }\n        });\n    }\n    run(worker, task) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const runPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                const removeTaskFromWorkersRunningTasks = () => {\n                    worker.runningTasks = worker.runningTasks.filter(someRunPromise => someRunPromise !== runPromise);\n                };\n                // Defer task execution by one tick to give handlers time to subscribe\n                yield delay(0);\n                try {\n                    yield this.runPoolTask(worker, task);\n                }\n                finally {\n                    removeTaskFromWorkersRunningTasks();\n                    if (!this.isClosing) {\n                        this.scheduleWork();\n                    }\n                }\n            }))();\n            worker.runningTasks.push(runPromise);\n        });\n    }\n    scheduleWork() {\n        this.debug(`Attempt de-queueing a task in order to run it...`);\n        const availableWorker = this.findIdlingWorker();\n        if (!availableWorker)\n            return;\n        const nextTask = this.taskQueue.shift();\n        if (!nextTask) {\n            this.debug(`Task queue is empty`);\n            this.eventSubject.next({ type: pool_types_1.PoolEventType.taskQueueDrained });\n            return;\n        }\n        this.run(availableWorker, nextTask);\n    }\n    taskCompletion(taskID) {\n        return new Promise((resolve, reject) => {\n            const eventSubscription = this.events().subscribe(event => {\n                if (event.type === pool_types_1.PoolEventType.taskCompleted && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    resolve(event.returnValue);\n                }\n                else if (event.type === pool_types_1.PoolEventType.taskFailed && event.taskID === taskID) {\n                    eventSubscription.unsubscribe();\n                    reject(event.error);\n                }\n                else if (event.type === pool_types_1.PoolEventType.terminated) {\n                    eventSubscription.unsubscribe();\n                    reject(Error(\"Pool has been terminated before task was run.\"));\n                }\n            });\n        });\n    }\n    settled(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const getCurrentlyRunningTasks = () => flatMap(this.workers, worker => worker.runningTasks);\n            const taskFailures = [];\n            const failureSubscription = this.eventObservable.subscribe(event => {\n                if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                    taskFailures.push(event.error);\n                }\n            });\n            if (this.initErrors.length > 0) {\n                return Promise.reject(this.initErrors[0]);\n            }\n            if (allowResolvingImmediately && this.taskQueue.length === 0) {\n                yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n                return taskFailures;\n            }\n            yield new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(void 0);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            yield ponyfills_1.allSettled(getCurrentlyRunningTasks());\n            failureSubscription.unsubscribe();\n            return taskFailures;\n        });\n    }\n    completed(allowResolvingImmediately = false) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const settlementPromise = this.settled(allowResolvingImmediately);\n            const earlyExitPromise = new Promise((resolve, reject) => {\n                const subscription = this.eventObservable.subscribe({\n                    next(event) {\n                        if (event.type === pool_types_1.PoolEventType.taskQueueDrained) {\n                            subscription.unsubscribe();\n                            resolve(settlementPromise);\n                        }\n                        else if (event.type === pool_types_1.PoolEventType.taskFailed) {\n                            subscription.unsubscribe();\n                            reject(event.error);\n                        }\n                    },\n                    error: reject // make a pool-wide error reject the completed() result promise\n                });\n            });\n            const errors = yield Promise.race([\n                settlementPromise,\n                earlyExitPromise\n            ]);\n            if (errors.length > 0) {\n                throw errors[0];\n            }\n        });\n    }\n    events() {\n        return this.eventObservable;\n    }\n    queue(taskFunction) {\n        const { maxQueuedJobs = Infinity } = this.options;\n        if (this.isClosing) {\n            throw Error(`Cannot schedule pool tasks after terminate() has been called.`);\n        }\n        if (this.initErrors.length > 0) {\n            throw this.initErrors[0];\n        }\n        const taskID = this.nextTaskID++;\n        const taskCompletion = this.taskCompletion(taskID);\n        taskCompletion.catch((error) => {\n            // Prevent unhandled rejections here as we assume the user will use\n            // `pool.completed()`, `pool.settled()` or `task.catch()` to handle errors\n            this.debug(`Task #${taskID} errored:`, error);\n        });\n        const task = {\n            id: taskID,\n            run: taskFunction,\n            cancel: () => {\n                if (this.taskQueue.indexOf(task) === -1)\n                    return;\n                this.taskQueue = this.taskQueue.filter(someTask => someTask !== task);\n                this.eventSubject.next({\n                    type: pool_types_1.PoolEventType.taskCanceled,\n                    taskID: task.id\n                });\n            },\n            then: taskCompletion.then.bind(taskCompletion)\n        };\n        if (this.taskQueue.length >= maxQueuedJobs) {\n            throw Error(\"Maximum number of pool tasks queued. Refusing to queue another one.\\n\" +\n                \"This usually happens for one of two reasons: We are either at peak \" +\n                \"workload right now or some tasks just won't finish, thus blocking the pool.\");\n        }\n        this.debug(`Queueing task #${task.id}...`);\n        this.taskQueue.push(task);\n        this.eventSubject.next({\n            type: pool_types_1.PoolEventType.taskQueued,\n            taskID: task.id\n        });\n        this.scheduleWork();\n        return task;\n    }\n    terminate(force) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.isClosing = true;\n            if (!force) {\n                yield this.completed(true);\n            }\n            this.eventSubject.next({\n                type: pool_types_1.PoolEventType.terminated,\n                remainingQueue: [...this.taskQueue]\n            });\n            this.eventSubject.complete();\n            yield Promise.all(this.workers.map((worker) => __awaiter(this, void 0, void 0, function* () { return thread_1.Thread.terminate(yield worker.init); })));\n        });\n    }\n}\nWorkerPool.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nfunction PoolConstructor(spawnWorker, optionsOrSize) {\n    // The function exists only so we don't need to use `new` to create a pool (we still can, though).\n    // If the Pool is a class or not is an implementation detail that should not concern the user.\n    return new WorkerPool(spawnWorker, optionsOrSize);\n}\nPoolConstructor.EventType = pool_types_1.PoolEventType;\n/**\n * Thread pool constructor. Creates a new pool and spawns its worker threads.\n */\nexports.Pool = PoolConstructor;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}