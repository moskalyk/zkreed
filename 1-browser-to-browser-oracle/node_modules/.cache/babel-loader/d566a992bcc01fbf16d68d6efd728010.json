{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst AddressBook = require('./address-book');\n\nconst KeyBook = require('./key-book');\n\nconst MetadataBook = require('./metadata-book');\n\nconst ProtoBook = require('./proto-book');\n\nconst Store = require('./store');\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Peer} Peer\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\n\nconst log = Object.assign(debug('libp2p:peer-store'), {\n  error: debug('libp2p:peer-store:err')\n});\n/**\n * An implementation of PeerStore that stores data in a Datastore\n *\n * @implements {PeerStore}\n */\n\nclass DefaultPeerStore extends EventEmitter {\n  /**\n   * @param {object} properties\n   * @param {PeerId} properties.peerId\n   * @param {import('interface-datastore').Datastore} properties.datastore\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} properties.addressFilter\n   */\n  constructor(_ref) {\n    let {\n      peerId,\n      datastore,\n      addressFilter\n    } = _ref;\n    super();\n    this._peerId = peerId;\n    this._store = new Store(datastore);\n    this.addressBook = new AddressBook(this.emit.bind(this), this._store, addressFilter);\n    this.keyBook = new KeyBook(this.emit.bind(this), this._store);\n    this.metadataBook = new MetadataBook(this.emit.bind(this), this._store);\n    this.protoBook = new ProtoBook(this.emit.bind(this), this._store);\n  }\n\n  async *getPeers() {\n    log('getPeers await read lock');\n    const release = await this._store.lock.readLock();\n    log('getPeers got read lock');\n\n    try {\n      for await (const peer of this._store.all()) {\n        if (peer.id.toB58String() === this._peerId.toB58String()) {\n          // Remove self peer if present\n          continue;\n        }\n\n        yield peer;\n      }\n    } finally {\n      log('getPeers release read lock');\n      release();\n    }\n  }\n  /**\n   * Delete the information of the given peer in every book\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    log('delete await write lock');\n    const release = await this._store.lock.writeLock();\n    log('delete got write lock');\n\n    try {\n      await this._store.delete(peerId);\n    } finally {\n      log('delete release write lock');\n      release();\n    }\n  }\n  /**\n   * Get the stored information of a given peer\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async get(peerId) {\n    log('get await read lock');\n    const release = await this._store.lock.readLock();\n    log('get got read lock');\n\n    try {\n      return this._store.load(peerId);\n    } finally {\n      log('get release read lock');\n      release();\n    }\n  }\n  /**\n   * Returns true if we have a record of the peer\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  async has(peerId) {\n    log('has await read lock');\n    const release = await this._store.lock.readLock();\n    log('has got read lock');\n\n    try {\n      return this._store.has(peerId);\n    } finally {\n      log('has release read lock');\n      release();\n    }\n  }\n\n}\n\nmodule.exports = DefaultPeerStore;","map":{"version":3,"names":["debug","require","EventEmitter","AddressBook","KeyBook","MetadataBook","ProtoBook","Store","log","Object","assign","error","DefaultPeerStore","constructor","peerId","datastore","addressFilter","_peerId","_store","addressBook","emit","bind","keyBook","metadataBook","protoBook","getPeers","release","lock","readLock","peer","all","id","toB58String","delete","writeLock","get","load","has","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/peer-store/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst { EventEmitter } = require('events')\nconst AddressBook = require('./address-book')\nconst KeyBook = require('./key-book')\nconst MetadataBook = require('./metadata-book')\nconst ProtoBook = require('./proto-book')\nconst Store = require('./store')\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').Peer} Peer\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n */\n\nconst log = Object.assign(debug('libp2p:peer-store'), {\n  error: debug('libp2p:peer-store:err')\n})\n\n/**\n * An implementation of PeerStore that stores data in a Datastore\n *\n * @implements {PeerStore}\n */\nclass DefaultPeerStore extends EventEmitter {\n  /**\n   * @param {object} properties\n   * @param {PeerId} properties.peerId\n   * @param {import('interface-datastore').Datastore} properties.datastore\n   * @param {(peerId: PeerId, multiaddr: Multiaddr) => Promise<boolean>} properties.addressFilter\n   */\n  constructor ({ peerId, datastore, addressFilter }) {\n    super()\n\n    this._peerId = peerId\n    this._store = new Store(datastore)\n\n    this.addressBook = new AddressBook(this.emit.bind(this), this._store, addressFilter)\n    this.keyBook = new KeyBook(this.emit.bind(this), this._store)\n    this.metadataBook = new MetadataBook(this.emit.bind(this), this._store)\n    this.protoBook = new ProtoBook(this.emit.bind(this), this._store)\n  }\n\n  async * getPeers () {\n    log('getPeers await read lock')\n    const release = await this._store.lock.readLock()\n    log('getPeers got read lock')\n\n    try {\n      for await (const peer of this._store.all()) {\n        if (peer.id.toB58String() === this._peerId.toB58String()) {\n          // Remove self peer if present\n          continue\n        }\n\n        yield peer\n      }\n    } finally {\n      log('getPeers release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Delete the information of the given peer in every book\n   *\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    log('delete await write lock')\n    const release = await this._store.lock.writeLock()\n    log('delete got write lock')\n\n    try {\n      await this._store.delete(peerId)\n    } finally {\n      log('delete release write lock')\n      release()\n    }\n  }\n\n  /**\n   * Get the stored information of a given peer\n   *\n   * @param {PeerId} peerId\n   */\n  async get (peerId) {\n    log('get await read lock')\n    const release = await this._store.lock.readLock()\n    log('get got read lock')\n\n    try {\n      return this._store.load(peerId)\n    } finally {\n      log('get release read lock')\n      release()\n    }\n  }\n\n  /**\n   * Returns true if we have a record of the peer\n   *\n   * @param {PeerId} peerId\n   */\n  async has (peerId) {\n    log('has await read lock')\n    const release = await this._store.lock.readLock()\n    log('has got read lock')\n\n    try {\n      return this._store.has(peerId)\n    } finally {\n      log('has release read lock')\n      release()\n    }\n  }\n}\n\nmodule.exports = DefaultPeerStore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}