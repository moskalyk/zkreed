{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n});\n\nconst errCode = require('err-code');\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst {\n  pipe\n} = require('it-pipe'); // @ts-ignore mutable-proxy does not export types\n\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {ConnectionGater} options.connectionGater\n   *\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor(_ref) {\n    let {\n      localPeer,\n      metrics,\n      connectionGater,\n      cryptos = new Map(),\n      muxers = new Map(),\n      onConnectionEnd = () => {},\n      onConnection = () => {}\n    } = _ref;\n    this.connectionGater = connectionGater;\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos;\n    this.muxers = muxers;\n    /** @type {import(\"./pnet\") | null} */\n\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeInbound(maConn) {\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let Muxer;\n    let cryptoProtocol;\n    let setPeer;\n    let proxyPeer;\n\n    if (await this.connectionGater.denyInboundConnection(maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the inbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));\n\n      if (await this.connectionGater.denyInboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      } // Multiplex the connection\n\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexInbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('Failed to upgrade inbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (await this.connectionGater.denyInboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded inbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeOutbound(maConn) {\n    const idStr = maConn.remoteAddr.getPeerId();\n\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR);\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr);\n\n    if (await this.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let Muxer;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = (Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the outbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));\n\n      if (await this.connectionGater.denyOutboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n      } // Multiplex the connection\n\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexOutbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (\n    /** @type {any} */\n    err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (await this.connectionGater.denyOutboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED);\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection(_ref2) {\n    var _this = this;\n\n    let {\n      cryptoProtocol,\n      direction,\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    } = _ref2;\n\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer;\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n\n    let newStream;\n    /** @type {Connection} */\n\n    let connection; // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return;\n          const mss = new Multistream.Listener(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = await mss.handle(Array.from(this.protocols.keys()));\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (this.metrics) this.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            connection.addStream(muxedStream, {\n              protocol\n            });\n\n            this._onStream({\n              connection,\n              stream: { ...muxedStream,\n                ...stream\n              },\n              protocol\n            });\n          } catch (\n          /** @type {any} */\n          err) {\n            log.error(err);\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = muxer.newStream();\n        const mss = new Multistream.Dialer(muxedStream);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = await mss.select(protocols);\n          if (this.metrics) this.metrics.trackStream({\n            stream,\n            remotePeer,\n            protocol\n          });\n          return {\n            stream: { ...muxedStream,\n              ...stream\n            },\n            protocol\n          };\n        } catch (\n        /** @type {any} */\n        err) {\n          log.error('could not create new stream', err);\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        }\n      }; // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: function () {\n        if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close();\n              }\n            } catch (\n            /** @type {any} */\n            err) {\n              log.error(err);\n            } finally {\n              _this.onConnectionEnd(connection);\n            }\n          })().catch(err => {\n            log.error(err);\n          });\n        }\n\n        return Reflect.set(...arguments);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED);\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close(); // Ensure remaining streams are aborted\n\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort());\n        }\n      }\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream(_ref3) {\n    let {\n      connection,\n      stream,\n      protocol\n    } = _ref3;\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptInbound(localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting inbound connection...');\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureInbound(localPeer, stream)),\n        protocol\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting outbound connection to %j', remotePeerId);\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`);\n      }\n\n      return { ...(await crypto.secureOutbound(localPeer, stream, remotePeerId)),\n        protocol\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const dialer = new Multistream.Dialer(connection);\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await dialer.select(protocols);\n      log('%s selected as muxer protocol', protocol);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const listener = new Multistream.Listener(connection);\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await listener.handle(protocols);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (\n    /** @type {any} */\n    err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}\n\nmodule.exports = Upgrader;","map":{"version":3,"names":["debug","require","log","Object","assign","error","errCode","Multistream","Connection","PeerId","pipe","mutableProxy","codes","Upgrader","constructor","localPeer","metrics","connectionGater","cryptos","Map","muxers","onConnectionEnd","onConnection","protector","protocols","upgradeInbound","maConn","encryptedConn","remotePeer","upgradedConn","Muxer","cryptoProtocol","setPeer","proxyPeer","denyInboundConnection","Error","ERR_CONNECTION_INTERCEPTED","setTarget","proxy","idString","Math","random","toString","Date","now","toB58String","trackStream","stream","protectedConn","protect","conn","protocol","_encryptInbound","denyInboundEncryptedConnection","size","_multiplexInbound","err","close","denyInboundUpgradedConnection","updatePlaceholder","_createConnection","direction","upgradeOutbound","idStr","remoteAddr","getPeerId","ERR_INVALID_MULTIADDR","remotePeerId","createFromB58String","denyOutboundConnection","_encryptOutbound","denyOutboundEncryptedConnection","_multiplexOutbound","denyOutboundUpgradedConnection","muxer","newStream","connection","onStream","muxedStream","mss","Listener","handle","Array","from","keys","addStream","_onStream","onStreamEnd","removeStream","id","Dialer","select","ERR_UNSUPPORTED_PROTOCOL","catch","_timeline","timeline","Proxy","set","stat","status","Reflect","upgraded","errConnectionNotMultiplexed","ERR_CONNECTION_NOT_MULTIPLEXED","localAddr","multiplexer","multicodec","encryption","getStreams","streams","map","abort","handler","get","crypto","secureInbound","ERR_ENCRYPTION_FAILED","secureOutbound","dialer","ERR_MUXER_UNAVAILABLE","listener","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/upgrader.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p:upgrader'), {\n  error: debug('libp2p:upgrader:err')\n})\nconst errCode = require('err-code')\nconst Multistream = require('multistream-select')\nconst { Connection } = require('libp2p-interfaces/src/connection')\nconst PeerId = require('peer-id')\nconst { pipe } = require('it-pipe')\n// @ts-ignore mutable-proxy does not export types\nconst mutableProxy = require('mutable-proxy')\n\nconst { codes } = require('./errors')\n\n/**\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').Muxer} Muxer\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('multiaddr').Multiaddr} Multiaddr\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n */\n\n/**\n * @typedef CryptoResult\n * @property {MultiaddrConnection} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {ConnectionGater} options.connectionGater\n   *\n   * @param {import('./metrics')} [options.metrics]\n   * @param {Map<string, Crypto>} [options.cryptos]\n   * @param {Map<string, MuxerFactory>} [options.muxers]\n   * @param {(connection: Connection) => void} options.onConnection - Called when a connection is upgraded\n   * @param {(connection: Connection) => void} options.onConnectionEnd\n   */\n  constructor ({\n    localPeer,\n    metrics,\n    connectionGater,\n    cryptos = new Map(),\n    muxers = new Map(),\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.connectionGater = connectionGater\n    this.localPeer = localPeer\n    this.metrics = metrics\n    this.cryptos = cryptos\n    this.muxers = muxers\n    /** @type {import(\"./pnet\") | null} */\n    this.protector = null\n    this.protocols = new Map()\n    this.onConnection = onConnection\n    this.onConnectionEnd = onConnectionEnd\n  }\n\n  /**\n   * Upgrades an inbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeInbound (maConn) {\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let Muxer\n    let cryptoProtocol\n    let setPeer\n    let proxyPeer\n\n    if (await this.connectionGater.denyInboundConnection(maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the inbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos))\n\n      if (await this.connectionGater.denyInboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (/** @type {any} */ err) {\n      log.error('Failed to upgrade inbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.connectionGater.denyInboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded inbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * Upgrades an outbound connection\n   *\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n  async upgradeOutbound (maConn) {\n    const idStr = maConn.remoteAddr.getPeerId()\n    if (!idStr) {\n      throw errCode(new Error('outbound connection must have a peer id'), codes.ERR_INVALID_MULTIADDR)\n    }\n\n    const remotePeerId = PeerId.createFromB58String(idStr)\n\n    if (await this.connectionGater.denyOutboundConnection(remotePeerId, maConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by connectionGater.denyOutboundConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    let encryptedConn\n    let remotePeer\n    let upgradedConn\n    let cryptoProtocol\n    let Muxer\n    let setPeer\n    let proxyPeer\n\n    if (this.metrics) {\n      ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy())\n      const idString = (Math.random() * 1e9).toString(36) + Date.now()\n      setPeer({ toB58String: () => idString })\n      maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer })\n    }\n\n    log('Starting the outbound connection upgrade')\n\n    // Protect\n    let protectedConn = maConn\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn)\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos))\n\n      if (await this.connectionGater.denyOutboundEncryptedConnection(remotePeer, encryptedConn)) {\n        throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n      }\n\n      // Multiplex the connection\n      if (this.muxers.size) {\n        ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers))\n      } else {\n        upgradedConn = encryptedConn\n      }\n    } catch (/** @type {any} */ err) {\n      log.error('Failed to upgrade outbound connection', err)\n      await maConn.close(err)\n      throw err\n    }\n\n    if (await this.connectionGater.denyOutboundUpgradedConnection(remotePeer, encryptedConn)) {\n      throw errCode(new Error('The multiaddr connection is blocked by gater.acceptEncryptedConnection'), codes.ERR_CONNECTION_INTERCEPTED)\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer)\n      setPeer(remotePeer)\n    }\n\n    log('Successfully upgraded outbound connection')\n\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    })\n  }\n\n  /**\n   * A convenience method for generating a new `Connection`\n   *\n   * @private\n   * @param {object} options\n   * @param {string} options.cryptoProtocol - The crypto protocol that was negotiated\n   * @param {'inbound' | 'outbound'} options.direction - One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} options.maConn - The transport layer connection\n   * @param {MuxedStream | MultiaddrConnection} options.upgradedConn - A duplex connection returned from multiplexer and/or crypto selection\n   * @param {MuxerFactory} [options.Muxer] - The muxer to be used for muxing\n   * @param {PeerId} options.remotePeer - The peer the connection is with\n   * @returns {Connection}\n   */\n  _createConnection ({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    /** @type {import(\"libp2p-interfaces/src/stream-muxer/types\").Muxer} */\n    let muxer\n    /** @type {import(\"libp2p-interfaces/src/connection/connection\").CreatedMuxedStream | undefined} */\n    let newStream\n    /** @type {Connection} */\n    let connection // eslint-disable-line prefer-const\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          if (!connection) return\n          const mss = new Multistream.Listener(muxedStream)\n          try {\n            const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()))\n            log('%s: incoming stream opened on %s', direction, protocol)\n            if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n            connection.addStream(muxedStream, { protocol })\n            this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol })\n          } catch (/** @type {any} */ err) {\n            log.error(err)\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id)\n        }\n      })\n\n      newStream = async (protocols) => {\n        log('%s: starting new stream on %s', direction, protocols)\n        const muxedStream = muxer.newStream()\n        const mss = new Multistream.Dialer(muxedStream)\n        try {\n          const { stream, protocol } = await mss.select(protocols)\n          if (this.metrics) this.metrics.trackStream({ stream, remotePeer, protocol })\n          return { stream: { ...muxedStream, ...stream }, protocol }\n        } catch (/** @type {any} */ err) {\n          log.error('could not create new stream', err)\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL)\n        }\n      }\n\n      // Pipe all data through the muxer\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error)\n    }\n\n    const _timeline = maConn.timeline\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          // Wait for close to finish before notifying of the closure\n          (async () => {\n            try {\n              if (connection.stat.status === 'open') {\n                await connection.close()\n              }\n            } catch (/** @type {any} */ err) {\n              log.error(err)\n            } finally {\n              this.onConnectionEnd(connection)\n            }\n          })().catch(err => {\n            log.error(err)\n          })\n        }\n\n        return Reflect.set(...args)\n      }\n    })\n    maConn.timeline.upgraded = Date.now()\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), codes.ERR_CONNECTION_NOT_MULTIPLEXED)\n    }\n\n    // Create the connection\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        // @ts-ignore\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),\n      close: async () => {\n        await maConn.close()\n        // Ensure remaining streams are aborted\n        if (muxer) {\n          muxer.streams.map(stream => stream.abort())\n        }\n      }\n    })\n\n    this.onConnection(connection)\n\n    return connection\n  }\n\n  /**\n   * Routes incoming streams to the correct handler\n   *\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection - The connection the stream belongs to\n   * @param {MuxedStream} options.stream\n   * @param {string} options.protocol\n   */\n  _onStream ({ connection, stream, protocol }) {\n    const handler = this.protocols.get(protocol)\n    handler({ connection, stream, protocol })\n  }\n\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptInbound (localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('handling inbound crypto protocol selection', protocols)\n\n    try {\n      const { stream, protocol } = await mss.handle(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting inbound connection...')\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureInbound(localPeer, stream),\n        protocol\n      }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   *\n   * @private\n   * @async\n   * @param {PeerId} localPeer - The initiators PeerId\n   * @param {MultiaddrConnection} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {Promise<CryptoResult>} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n  async _encryptOutbound (localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection)\n    const protocols = Array.from(cryptos.keys())\n    log('selecting outbound crypto protocol', protocols)\n\n    try {\n      const { stream, protocol } = await mss.select(protocols)\n      const crypto = cryptos.get(protocol)\n      log('encrypting outbound connection to %j', remotePeerId)\n\n      if (!crypto) {\n        throw new Error(`no crypto module found for ${protocol}`)\n      }\n\n      return {\n        ...await crypto.secureOutbound(localPeer, stream, remotePeerId),\n        protocol\n      }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED)\n    }\n  }\n\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexOutbound (connection, muxers) {\n    const dialer = new Multistream.Dialer(connection)\n    const protocols = Array.from(muxers.keys())\n    log('outbound selecting muxer %s', protocols)\n    try {\n      const { stream, protocol } = await dialer.select(protocols)\n      log('%s selected as muxer protocol', protocol)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   *\n   * @private\n   * @async\n   * @param {MultiaddrConnection} connection - A basic duplex connection to multiplex\n   * @param {Map<string, MuxerFactory>} muxers - The muxers to attempt multiplexing with\n   * @returns {Promise<{ stream: MuxedStream, Muxer?: MuxerFactory}>} A muxed connection\n   */\n  async _multiplexInbound (connection, muxers) {\n    const listener = new Multistream.Listener(connection)\n    const protocols = Array.from(muxers.keys())\n    log('inbound handling muxers %s', protocols)\n    try {\n      const { stream, protocol } = await listener.handle(protocols)\n      const Muxer = muxers.get(protocol)\n      return { stream, Muxer }\n    } catch (/** @type {any} */ err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE)\n    }\n  }\n}\n\nmodule.exports = Upgrader\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}