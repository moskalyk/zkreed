{"ast":null,"code":"\"use strict\";\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.utils = exports.curve25519 = exports.getSharedSecret = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;\n\nconst crypto_1 = __importDefault(require(\"crypto\"));\n\nconst _0n = BigInt(0);\n\nconst _1n = BigInt(1);\n\nconst _2n = BigInt(2);\n\nconst _255n = BigInt(255);\n\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = {\n  a: BigInt(-1),\n  d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n  P: _2n ** _255n - BigInt(19),\n  l: CURVE_ORDER,\n  n: CURVE_ORDER,\n  h: BigInt(8),\n  Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n  Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')\n};\nexports.CURVE = CURVE;\n\nconst MAX_256B = _2n ** BigInt(256);\n\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n\nclass ExtendedPoint {\n  constructor(x, y, z, t) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.t = t;\n  }\n\n  static fromAffine(p) {\n    if (!(p instanceof Point)) {\n      throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n    }\n\n    if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;\n    return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n  }\n\n  static toAffineBatch(points) {\n    const toInv = invertBatch(points.map(p => p.z));\n    return points.map((p, i) => p.toAffine(toInv[i]));\n  }\n\n  static normalizeZ(points) {\n    return this.toAffineBatch(points).map(this.fromAffine);\n  }\n\n  equals(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2\n    } = other;\n    const X1Z2 = mod(X1 * Z2);\n    const X2Z1 = mod(X2 * Z1);\n    const Y1Z2 = mod(Y1 * Z2);\n    const Y2Z1 = mod(Y2 * Z1);\n    return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n  }\n\n  negate() {\n    return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n  }\n\n  double() {\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1\n    } = this;\n    const {\n      a\n    } = CURVE;\n    const A = mod(X1 ** _2n);\n    const B = mod(Y1 ** _2n);\n    const C = mod(_2n * mod(Z1 ** _2n));\n    const D = mod(a * A);\n    const E = mod(mod((X1 + Y1) ** _2n) - A - B);\n    const G = D + B;\n    const F = G - C;\n    const H = D - B;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  add(other) {\n    assertExtPoint(other);\n    const {\n      x: X1,\n      y: Y1,\n      z: Z1,\n      t: T1\n    } = this;\n    const {\n      x: X2,\n      y: Y2,\n      z: Z2,\n      t: T2\n    } = other;\n    const A = mod((Y1 - X1) * (Y2 + X2));\n    const B = mod((Y1 + X1) * (Y2 - X2));\n    const F = mod(B - A);\n    if (F === _0n) return this.double();\n    const C = mod(Z1 * _2n * T2);\n    const D = mod(T1 * _2n * Z2);\n    const E = D + C;\n    const G = B + A;\n    const H = D - C;\n    const X3 = mod(E * F);\n    const Y3 = mod(G * H);\n    const T3 = mod(E * H);\n    const Z3 = mod(F * G);\n    return new ExtendedPoint(X3, Y3, Z3, T3);\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  precomputeWindow(W) {\n    const windows = 1 + 256 / W;\n    const points = [];\n    let p = this;\n    let base = p;\n\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n\n      for (let i = 1; i < 2 ** (W - 1); i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n\n      p = base.double();\n    }\n\n    return points;\n  }\n\n  wNAF(n, affinePoint) {\n    if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;\n    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;\n\n    if (256 % W) {\n      throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n    }\n\n    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n\n    if (!precomputes) {\n      precomputes = this.precomputeWindow(W);\n\n      if (affinePoint && W !== 1) {\n        precomputes = ExtendedPoint.normalizeZ(precomputes);\n        pointPrecomputes.set(affinePoint, precomputes);\n      }\n    }\n\n    let p = ExtendedPoint.ZERO;\n    let f = ExtendedPoint.ZERO;\n    const windows = 1 + 256 / W;\n    const windowSize = 2 ** (W - 1);\n    const mask = BigInt(2 ** W - 1);\n    const maxNumber = 2 ** W;\n    const shiftBy = BigInt(W);\n\n    for (let window = 0; window < windows; window++) {\n      const offset = window * windowSize;\n      let wbits = Number(n & mask);\n      n >>= shiftBy;\n\n      if (wbits > windowSize) {\n        wbits -= maxNumber;\n        n += _1n;\n      }\n\n      if (wbits === 0) {\n        let pr = precomputes[offset];\n        if (window % 2) pr = pr.negate();\n        f = f.add(pr);\n      } else {\n        let cached = precomputes[offset + Math.abs(wbits) - 1];\n        if (wbits < 0) cached = cached.negate();\n        p = p.add(cached);\n      }\n    }\n\n    return ExtendedPoint.normalizeZ([p, f])[0];\n  }\n\n  multiply(scalar, affinePoint) {\n    return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n  }\n\n  multiplyUnsafe(scalar) {\n    let n = normalizeScalar(scalar, CURVE.l, false);\n    const G = ExtendedPoint.BASE;\n    const P0 = ExtendedPoint.ZERO;\n    if (n === _0n) return P0;\n    if (this.equals(P0) || n === _1n) return this;\n    if (this.equals(G)) return this.wNAF(n);\n    let p = P0;\n    let d = this;\n\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n\n    return p;\n  }\n\n  isSmallOrder() {\n    return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n  }\n\n  isTorsionFree() {\n    return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n  }\n\n  toAffine() {\n    let invZ = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : invert(this.z);\n    const {\n      x,\n      y,\n      z\n    } = this;\n    const ax = mod(x * invZ);\n    const ay = mod(y * invZ);\n    const zz = mod(z * invZ);\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return new Point(ax, ay);\n  }\n\n  fromRistrettoBytes() {\n    legacyRist();\n  }\n\n  toRistrettoBytes() {\n    legacyRist();\n  }\n\n  fromRistrettoHash() {\n    legacyRist();\n  }\n\n}\n\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\n\nfunction assertExtPoint(other) {\n  if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');\n}\n\nfunction assertRstPoint(other) {\n  if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');\n}\n\nfunction legacyRist() {\n  throw new Error('Legacy method: switch to RistrettoPoint');\n}\n\nclass RistrettoPoint {\n  constructor(ep) {\n    this.ep = ep;\n  }\n\n  static calcElligatorRistrettoMap(r0) {\n    const {\n      d\n    } = CURVE;\n    const r = mod(SQRT_M1 * r0 * r0);\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n    let c = BigInt(-1);\n    const D = mod((c - d * r) * mod(r + d));\n    let {\n      isValid: Ns_D_is_sq,\n      value: s\n    } = uvRatio(Ns, D);\n    let s_ = mod(s * r0);\n    if (!edIsNegative(s_)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_;\n    if (!Ns_D_is_sq) c = r;\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n    const s2 = s * s;\n    const W0 = mod((s + s) * D);\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n    const W2 = mod(_1n - s2);\n    const W3 = mod(_1n + s2);\n    return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n  }\n\n  static hashToCurve(hex) {\n    hex = ensureBytes(hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = this.calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = this.calcElligatorRistrettoMap(r2);\n    return new RistrettoPoint(R1.add(R2));\n  }\n\n  static fromHex(hex) {\n    hex = ensureBytes(hex, 32);\n    const {\n      a,\n      d\n    } = CURVE;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2);\n    const u2 = mod(_1n - a * s2);\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2);\n    const {\n      isValid,\n      value: I\n    } = invertSqrt(mod(v * u2_2));\n    const Dx = mod(I * u2);\n    const Dy = mod(I * Dx * v);\n    let x = mod((s + s) * Dx);\n    if (edIsNegative(x)) x = mod(-x);\n    const y = mod(u1 * Dy);\n    const t = mod(x * y);\n    if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);\n    return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n  }\n\n  toRawBytes() {\n    let {\n      x,\n      y,\n      z,\n      t\n    } = this.ep;\n    const u1 = mod(mod(z + y) * mod(z - y));\n    const u2 = mod(x * y);\n    const {\n      value: invsqrt\n    } = invertSqrt(mod(u1 * u2 ** _2n));\n    const D1 = mod(invsqrt * u1);\n    const D2 = mod(invsqrt * u2);\n    const zInv = mod(D1 * D2 * t);\n    let D;\n\n    if (edIsNegative(t * zInv)) {\n      let _x = mod(y * SQRT_M1);\n\n      let _y = mod(x * SQRT_M1);\n\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2;\n    }\n\n    if (edIsNegative(x * zInv)) y = mod(-y);\n    let s = mod((z - y) * D);\n    if (edIsNegative(s)) s = mod(-s);\n    return numberTo32BytesLE(s);\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString() {\n    return this.toHex();\n  }\n\n  equals(other) {\n    assertRstPoint(other);\n    const a = this.ep;\n    const b = other.ep;\n    const one = mod(a.x * b.y) === mod(a.y * b.x);\n    const two = mod(a.y * b.y) === mod(a.x * b.x);\n    return one || two;\n  }\n\n  add(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other) {\n    assertRstPoint(other);\n    return new RistrettoPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar) {\n    return new RistrettoPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar) {\n    return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n}\n\nexports.RistrettoPoint = RistrettoPoint;\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\n\nclass Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  _setWindowSize(windowSize) {\n    this._WINDOW_SIZE = windowSize;\n    pointPrecomputes.delete(this);\n  }\n\n  static fromHex(hex) {\n    let strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const {\n      d,\n      P\n    } = CURVE;\n    hex = ensureBytes(hex, 32);\n    const normed = hex.slice();\n    normed[31] = hex[31] & ~0x80;\n    const y = bytesToNumberLE(normed);\n    if (strict && y >= P) throw new Error('Expected 0 < hex < P');\n    if (!strict && y >= MAX_256B) throw new Error('Expected 0 < hex < 2**256');\n    const y2 = mod(y * y);\n    const u = mod(y2 - _1n);\n    const v = mod(d * y2 + _1n);\n    let {\n      isValid,\n      value: x\n    } = uvRatio(u, v);\n    if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n    const isXOdd = (x & _1n) === _1n;\n    const isLastByteOdd = (hex[31] & 0x80) !== 0;\n\n    if (isLastByteOdd !== isXOdd) {\n      x = mod(-x);\n    }\n\n    return new Point(x, y);\n  }\n\n  static async fromPrivateKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).point;\n  }\n\n  toRawBytes() {\n    const bytes = numberTo32BytesLE(this.y);\n    bytes[31] |= this.x & _1n ? 0x80 : 0;\n    return bytes;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toX25519() {\n    const {\n      y\n    } = this;\n    const u = mod((_1n + y) * invert(_1n - y));\n    return numberTo32BytesLE(u);\n  }\n\n  isTorsionFree() {\n    return ExtendedPoint.fromAffine(this).isTorsionFree();\n  }\n\n  equals(other) {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  negate() {\n    return new Point(mod(-this.x), this.y);\n  }\n\n  add(other) {\n    return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n  }\n\n  subtract(other) {\n    return this.add(other.negate());\n  }\n\n  multiply(scalar) {\n    return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n  }\n\n}\n\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\n\nclass Signature {\n  constructor(r, s) {\n    this.r = r;\n    this.s = s;\n    this.assertValidity();\n  }\n\n  static fromHex(hex) {\n    const bytes = ensureBytes(hex, 64);\n    const r = Point.fromHex(bytes.slice(0, 32), false);\n    const s = bytesToNumberLE(bytes.slice(32, 64));\n    return new Signature(r, s);\n  }\n\n  assertValidity() {\n    const {\n      r,\n      s\n    } = this;\n    if (!(r instanceof Point)) throw new Error('Expected Point instance');\n    normalizeScalar(s, CURVE.l, false);\n    return this;\n  }\n\n  toRawBytes() {\n    const u8 = new Uint8Array(64);\n    u8.set(this.r.toRawBytes());\n    u8.set(numberTo32BytesLE(this.s), 32);\n    return u8;\n  }\n\n  toHex() {\n    return bytesToHex(this.toRawBytes());\n  }\n\n}\n\nexports.Signature = Signature;\n\nfunction concatBytes() {\n  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {\n    arrays[_key] = arguments[_key];\n  }\n\n  if (!arrays.every(a => a instanceof Uint8Array)) throw new Error('Expected Uint8Array list');\n  if (arrays.length === 1) return arrays[0];\n  const length = arrays.reduce((a, arr) => a + arr.length, 0);\n  const result = new Uint8Array(length);\n\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const arr = arrays[i];\n    result.set(arr, pad);\n    pad += arr.length;\n  }\n\n  return result;\n}\n\nconst hexes = Array.from({\n  length: 256\n}, (v, i) => i.toString(16).padStart(2, '0'));\n\nfunction bytesToHex(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');\n  let hex = '';\n\n  for (let i = 0; i < uint8a.length; i++) {\n    hex += hexes[uint8a[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') {\n    throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n  }\n\n  if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');\n  const array = new Uint8Array(hex.length / 2);\n\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2;\n    const hexByte = hex.slice(j, j + 2);\n    const byte = Number.parseInt(hexByte, 16);\n    if (Number.isNaN(byte) || byte < 0) throw new Error('Invalid byte sequence');\n    array[i] = byte;\n  }\n\n  return array;\n}\n\nfunction numberTo32BytesBE(num) {\n  const length = 32;\n  const hex = num.toString(16).padStart(length * 2, '0');\n  return hexToBytes(hex);\n}\n\nfunction numberTo32BytesLE(num) {\n  return numberTo32BytesBE(num).reverse();\n}\n\nfunction edIsNegative(num) {\n  return (mod(num) & _1n) === _1n;\n}\n\nfunction bytesToNumberLE(uint8a) {\n  if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');\n  return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\n\nfunction bytes255ToNumberLE(bytes) {\n  return mod(bytesToNumberLE(bytes) & _2n ** _255n - _1n);\n}\n\nfunction mod(a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const res = a % b;\n  return res >= _0n ? res : b + res;\n}\n\nfunction invert(number) {\n  let modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n\n  if (number === _0n || modulo <= _0n) {\n    throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n  }\n\n  let a = mod(number, modulo);\n  let b = modulo;\n  let x = _0n,\n      y = _1n,\n      u = _1n,\n      v = _0n;\n\n  while (a !== _0n) {\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction invertBatch(nums) {\n  let p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;\n  const tmp = new Array(nums.length);\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = acc;\n    return mod(acc * num, p);\n  }, _1n);\n  const inverted = invert(lastMultiplied, p);\n  nums.reduceRight((acc, num, i) => {\n    if (num === _0n) return acc;\n    tmp[i] = mod(acc * tmp[i], p);\n    return mod(acc * num, p);\n  }, inverted);\n  return tmp;\n}\n\nfunction pow2(x, power) {\n  const {\n    P\n  } = CURVE;\n  let res = x;\n\n  while (power-- > _0n) {\n    res *= res;\n    res %= P;\n  }\n\n  return res;\n}\n\nfunction pow_2_252_3(x) {\n  const {\n    P\n  } = CURVE;\n\n  const _5n = BigInt(5);\n\n  const _10n = BigInt(10);\n\n  const _20n = BigInt(20);\n\n  const _40n = BigInt(40);\n\n  const _80n = BigInt(80);\n\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, _2n) * b2 % P;\n  const b5 = pow2(b4, _1n) * x % P;\n  const b10 = pow2(b5, _5n) * b5 % P;\n  const b20 = pow2(b10, _10n) * b10 % P;\n  const b40 = pow2(b20, _20n) * b20 % P;\n  const b80 = pow2(b40, _40n) * b40 % P;\n  const b160 = pow2(b80, _80n) * b80 % P;\n  const b240 = pow2(b160, _80n) * b80 % P;\n  const b250 = pow2(b240, _10n) * b10 % P;\n  const pow_p_5_8 = pow2(b250, _2n) * x % P;\n  return {\n    pow_p_5_8,\n    b2\n  };\n}\n\nfunction uvRatio(u, v) {\n  const v3 = mod(v * v * v);\n  const v7 = mod(v3 * v3 * v);\n  const pow = pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow);\n  const vx2 = mod(v * x * x);\n  const root1 = x;\n  const root2 = mod(x * SQRT_M1);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u);\n  const noRoot = vx2 === mod(-u * SQRT_M1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if (edIsNegative(x)) x = mod(-x);\n  return {\n    isValid: useRoot1 || useRoot2,\n    value: x\n  };\n}\n\nfunction invertSqrt(number) {\n  return uvRatio(_1n, number);\n}\n\nasync function sha512ModqLE() {\n  const hash = await exports.utils.sha512(concatBytes(...arguments));\n  const value = bytesToNumberLE(hash);\n  return mod(value, CURVE.l);\n}\n\nfunction equalBytes(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] !== b2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction ensureBytes(hex, expectedLength) {\n  const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n  if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);\n  return bytes;\n}\n\nfunction normalizeScalar(num, max) {\n  let strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!max) throw new TypeError('Specify max value');\n  if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);\n\n  if (typeof num === 'bigint' && num < max) {\n    if (strict) {\n      if (_0n < num) return num;\n    } else {\n      if (_0n <= num) return num;\n    }\n  }\n\n  throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\n\nfunction adjustBytes25519(bytes) {\n  bytes[0] &= 248;\n  bytes[31] &= 127;\n  bytes[31] |= 64;\n  return bytes;\n}\n\nfunction decodeScalar25519(n) {\n  return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\n\nasync function getExtendedPublicKey(key) {\n  key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, MAX_256B)) : ensureBytes(key);\n  if (key.length !== 32) throw new Error(`Expected 32 bytes`);\n  const hashed = await exports.utils.sha512(key);\n  const head = adjustBytes25519(hashed.slice(0, 32));\n  const prefix = hashed.slice(32, 64);\n  const scalar = mod(bytesToNumberLE(head), CURVE.l);\n  const point = Point.BASE.multiply(scalar);\n  const pointBytes = point.toRawBytes();\n  return {\n    head,\n    prefix,\n    scalar,\n    point,\n    pointBytes\n  };\n}\n\nasync function getPublicKey(privateKey) {\n  return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\n\nexports.getPublicKey = getPublicKey;\n\nasync function sign(message, privateKey) {\n  message = ensureBytes(message);\n  const {\n    prefix,\n    scalar,\n    pointBytes\n  } = await getExtendedPublicKey(privateKey);\n  const r = await sha512ModqLE(prefix, message);\n  const R = Point.BASE.multiply(r);\n  const k = await sha512ModqLE(R.toRawBytes(), pointBytes, message);\n  const s = mod(r + k * scalar, CURVE.l);\n  return new Signature(R, s).toRawBytes();\n}\n\nexports.sign = sign;\n\nasync function verify(sig, message, publicKey) {\n  message = ensureBytes(message);\n  if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);\n  const {\n    r,\n    s\n  } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n  const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n  const k = await sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);\n  const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n  const RkA = ExtendedPoint.fromAffine(r).add(kA);\n  return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\n\nexports.verify = verify;\n\nasync function getSharedSecret(privateKey, publicKey) {\n  const {\n    head\n  } = await getExtendedPublicKey(privateKey);\n  const u = Point.fromHex(publicKey).toX25519();\n  return exports.curve25519.scalarMult(head, u);\n}\n\nexports.getSharedSecret = getSharedSecret;\n\nPoint.BASE._setWindowSize(8);\n\nfunction cswap(swap, x_2, x_3) {\n  const dummy = mod(swap * (x_2 - x_3));\n  x_2 = mod(x_2 - dummy);\n  x_3 = mod(x_3 + dummy);\n  return [x_2, x_3];\n}\n\nfunction montgomeryLadder(pointU, scalar) {\n  const {\n    P\n  } = CURVE;\n  const u = normalizeScalar(pointU, P);\n  const k = normalizeScalar(scalar, P);\n  const a24 = BigInt(121665);\n  const x_1 = u;\n  let x_2 = _1n;\n  let z_2 = _0n;\n  let x_3 = u;\n  let z_3 = _1n;\n  let swap = _0n;\n  let sw;\n\n  for (let t = BigInt(255 - 1); t >= _0n; t--) {\n    const k_t = k >> t & _1n;\n    swap ^= k_t;\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    swap = k_t;\n    const A = x_2 + z_2;\n    const AA = mod(A * A);\n    const B = x_2 - z_2;\n    const BB = mod(B * B);\n    const E = AA - BB;\n    const C = x_3 + z_3;\n    const D = x_3 - z_3;\n    const DA = mod(D * A);\n    const CB = mod(C * B);\n    x_3 = mod((DA + CB) ** _2n);\n    z_3 = mod(x_1 * (DA - CB) ** _2n);\n    x_2 = mod(AA * BB);\n    z_2 = mod(E * (AA + mod(a24 * E)));\n  }\n\n  sw = cswap(swap, x_2, x_3);\n  x_2 = sw[0];\n  x_3 = sw[1];\n  sw = cswap(swap, z_2, z_3);\n  z_2 = sw[0];\n  z_3 = sw[1];\n  const {\n    pow_p_5_8,\n    b2\n  } = pow_2_252_3(z_2);\n  const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n  return mod(x_2 * xp2);\n}\n\nfunction encodeUCoordinate(u) {\n  return numberTo32BytesLE(mod(u, CURVE.P));\n}\n\nfunction decodeUCoordinate(uEnc) {\n  const u = ensureBytes(uEnc, 32);\n  u[31] &= 127;\n  return bytesToNumberLE(u);\n}\n\nexports.curve25519 = {\n  BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n\n  scalarMult(privateKey, publicKey) {\n    const u = decodeUCoordinate(publicKey);\n    const p = decodeScalar25519(privateKey);\n    const pu = montgomeryLadder(u, p);\n    if (pu === _0n) throw new Error('Invalid private or public key received');\n    return encodeUCoordinate(pu);\n  },\n\n  scalarMultBase(privateKey) {\n    return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);\n  }\n\n};\nconst crypto = {\n  node: crypto_1.default,\n  web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined\n};\nexports.utils = {\n  TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],\n  bytesToHex,\n  getExtendedPublicKey,\n  mod,\n  invert,\n  hashToPrivateScalar: hash => {\n    hash = ensureBytes(hash);\n    if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n    const num = mod(bytesToNumberLE(hash), CURVE.l);\n    if (num === _0n || num === _1n) throw new Error('Invalid private key');\n    return num;\n  },\n  randomBytes: function () {\n    let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n\n    if (crypto.web) {\n      return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n    } else if (crypto.node) {\n      const {\n        randomBytes\n      } = crypto.node;\n      return new Uint8Array(randomBytes(bytesLength).buffer);\n    } else {\n      throw new Error(\"The environment doesn't have randomBytes function\");\n    }\n  },\n  randomPrivateKey: () => {\n    return exports.utils.randomBytes(32);\n  },\n  sha512: async message => {\n    if (crypto.web) {\n      const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n      return new Uint8Array(buffer);\n    } else if (crypto.node) {\n      return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n    } else {\n      throw new Error(\"The environment doesn't have sha512 function\");\n    }\n  },\n\n  precompute() {\n    let windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n    let point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;\n    const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n\n    cached._setWindowSize(windowSize);\n\n    cached.multiply(_2n);\n    return cached;\n  }\n\n};","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","utils","curve25519","getSharedSecret","verify","sign","getPublicKey","Signature","Point","RistrettoPoint","ExtendedPoint","CURVE","crypto_1","require","_0n","BigInt","_1n","_2n","_255n","CURVE_ORDER","a","d","P","l","n","h","Gx","Gy","MAX_256B","SQRT_M1","SQRT_D","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","constructor","x","y","z","t","fromAffine","p","TypeError","equals","ZERO","toAffineBatch","points","toInv","invertBatch","map","i","toAffine","normalizeZ","other","assertExtPoint","X1","Y1","Z1","X2","Y2","Z2","X1Z2","X2Z1","Y1Z2","Y2Z1","negate","double","A","B","C","D","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","precomputeWindow","W","windows","base","window","push","wNAF","affinePoint","BASE","_WINDOW_SIZE","Error","precomputes","pointPrecomputes","get","set","f","windowSize","mask","maxNumber","shiftBy","offset","wbits","Number","pr","cached","Math","abs","multiply","scalar","normalizeScalar","multiplyUnsafe","P0","isSmallOrder","isTorsionFree","invZ","invert","ax","ay","zz","fromRistrettoBytes","legacyRist","toRistrettoBytes","fromRistrettoHash","assertRstPoint","ep","calcElligatorRistrettoMap","r0","r","Ns","c","isValid","Ns_D_is_sq","s","uvRatio","s_","edIsNegative","Nt","s2","W0","W1","W2","W3","hashToCurve","hex","ensureBytes","r1","bytes255ToNumberLE","slice","R1","r2","R2","fromHex","emsg","equalBytes","numberTo32BytesLE","u1","u2","u1_2","u2_2","v","I","invertSqrt","Dx","Dy","toRawBytes","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","toString","b","one","two","WeakMap","_setWindowSize","delete","strict","normed","bytesToNumberLE","y2","u","isXOdd","isLastByteOdd","fromPrivateKey","privateKey","getExtendedPublicKey","point","bytes","toX25519","assertValidity","u8","Uint8Array","concatBytes","arrays","every","length","reduce","arr","result","pad","hexes","Array","from","padStart","uint8a","hexToBytes","array","j","hexByte","byte","parseInt","isNaN","numberTo32BytesBE","num","reverse","res","number","modulo","q","m","gcd","nums","tmp","lastMultiplied","acc","inverted","reduceRight","pow2","power","pow_2_252_3","_5n","_10n","_20n","_40n","_80n","x2","b2","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","v3","v7","pow","vx2","root1","root2","useRoot1","useRoot2","noRoot","sha512ModqLE","hash","sha512","b1","expectedLength","max","isSafeInteger","adjustBytes25519","decodeScalar25519","key","hashed","head","prefix","pointBytes","message","R","k","sig","publicKey","SB","kA","RkA","scalarMult","cswap","swap","x_2","x_3","dummy","montgomeryLadder","pointU","a24","x_1","z_2","z_3","sw","k_t","AA","BB","DA","CB","xp2","encodeUCoordinate","decodeUCoordinate","uEnc","BASE_POINT_U","pu","scalarMultBase","crypto","node","default","web","self","undefined","TORSION_SUBGROUP","hashToPrivateScalar","randomBytes","bytesLength","getRandomValues","buffer","randomPrivateKey","subtle","digest","createHash","update","precompute"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@noble/ed25519/lib/index.js"],"sourcesContent":["\"use strict\";\n/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.utils = exports.curve25519 = exports.getSharedSecret = exports.verify = exports.sign = exports.getPublicKey = exports.Signature = exports.Point = exports.RistrettoPoint = exports.ExtendedPoint = exports.CURVE = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _255n = BigInt(255);\nconst CURVE_ORDER = _2n ** BigInt(252) + BigInt('27742317777372353535851937790883648493');\nconst CURVE = {\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: _2n ** _255n - BigInt(19),\n    l: CURVE_ORDER,\n    n: CURVE_ORDER,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n};\nexports.CURVE = CURVE;\nconst MAX_256B = _2n ** BigInt(256);\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const A = mod(X1 ** _2n);\n        const B = mod(Y1 ** _2n);\n        const C = mod(_2n * mod(Z1 ** _2n));\n        const D = mod(a * A);\n        const E = mod(mod((X1 + Y1) ** _2n) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const A = mod((Y1 - X1) * (Y2 + X2));\n        const B = mod((Y1 + X1) * (Y2 - X2));\n        const F = mod(B - A);\n        if (F === _0n)\n            return this.double();\n        const C = mod(Z1 * _2n * T2);\n        const D = mod(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = mod(E * F);\n        const Y3 = mod(G * H);\n        const T3 = mod(E * H);\n        const Z3 = mod(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.ZERO;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            if (wbits === 0) {\n                let pr = precomputes[offset];\n                if (window % 2)\n                    pr = pr.negate();\n                f = f.add(pr);\n            }\n            else {\n                let cached = precomputes[offset + Math.abs(wbits) - 1];\n                if (wbits < 0)\n                    cached = cached.negate();\n                p = p.add(cached);\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        return this.multiplyUnsafe(CURVE.l).equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ = invert(this.z)) {\n        const { x, y, z } = this;\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nexports.ExtendedPoint = ExtendedPoint;\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2 ** _2n));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nexports.RistrettoPoint = RistrettoPoint;\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= MAX_256B)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nexports.Point = Point;\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexports.Signature = Signature;\nfunction concatBytes(...arrays) {\n    if (!arrays.every((a) => a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array list');\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\nfunction bytesToHex(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n    let hex = '';\n    for (let i = 0; i < uint8a.length; i++) {\n        hex += hexes[uint8a[i]];\n    }\n    return hex;\n}\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string') {\n        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);\n    }\n    if (hex.length % 2)\n        throw new Error('hexToBytes: received invalid unpadded hex');\n    const array = new Uint8Array(hex.length / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    if (!(uint8a instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & (_2n ** _255n - _1n));\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nasync function sha512ModqLE(...args) {\n    const hash = await exports.utils.sha512(concatBytes(...args));\n    const value = bytesToNumberLE(hash);\n    return mod(value, CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nasync function getExtendedPublicKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, MAX_256B))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    const hashed = await exports.utils.sha512(key);\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = mod(bytesToNumberLE(head), CURVE.l);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nasync function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nexports.getPublicKey = getPublicKey;\nasync function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = await sha512ModqLE(prefix, message);\n    const R = Point.BASE.multiply(r);\n    const k = await sha512ModqLE(R.toRawBytes(), pointBytes, message);\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nexports.sign = sign;\nasync function verify(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    const k = await sha512ModqLE(r.toRawBytes(), publicKey.toRawBytes(), message);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexports.verify = verify;\nasync function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return exports.curve25519.scalarMult(head, u);\n}\nexports.getSharedSecret = getSharedSecret;\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        x_3 = mod((DA + CB) ** _2n);\n        z_3 = mod(x_1 * (DA - CB) ** _2n);\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexports.curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return exports.curve25519.scalarMult(privateKey, exports.curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: crypto_1.default,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexports.utils = {\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    bytesToHex,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        const num = mod(bytesToNumberLE(hash), CURVE.l);\n        if (num === _0n || num === _1n)\n            throw new Error('Invalid private key');\n        return num;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return exports.utils.randomBytes(32);\n    },\n    sha512: async (message) => {\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}