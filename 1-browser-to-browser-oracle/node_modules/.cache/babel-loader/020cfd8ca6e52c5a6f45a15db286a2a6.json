{"ast":null,"code":"\"use strict\";\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callFunction = void 0;\n\nvar FluencePeer_1 = require(\"../../FluencePeer\");\n\nvar index_1 = require(\"../../../index\");\n\nvar services_1 = require(\"./services\");\n/**\n * Convenience function to support Aqua `func` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param rawFnArgs - raw arguments passed by user to the generated function\n * @param def - function definition generated by the Aqua compiler\n * @param script - air script with function execution logic generated by the Aqua compiler\n */\n\n\nfunction callFunction(rawFnArgs, def, script) {\n  if (def.arrow.domain.tag !== 'labeledProduct') {\n    throw new Error('Should be impossible');\n  }\n\n  var argumentTypes = Object.entries(def.arrow.domain.fields);\n  var expectedNumberOfArguments = argumentTypes.length;\n\n  var _a = extractArgs(rawFnArgs, expectedNumberOfArguments),\n      args = _a.args,\n      peer = _a.peer,\n      config = _a.config;\n\n  if (args.length !== expectedNumberOfArguments) {\n    throw new Error('Incorrect number of arguments. Expecting ${def.argDefs.length}');\n  }\n\n  var promise = new Promise(function (resolve, reject) {\n    var particle = peer.internals.createNewParticle(script, config === null || config === void 0 ? void 0 : config.ttl);\n\n    if (particle instanceof Error) {\n      return reject(particle.message);\n    }\n\n    for (var i = 0; i < expectedNumberOfArguments; i++) {\n      var _a = __read(argumentTypes[i], 2),\n          name_1 = _a[0],\n          type = _a[1];\n\n      var service = void 0;\n\n      if (type.tag === 'arrow') {\n        service = (0, services_1.userHandlerService)(def.names.callbackSrv, [name_1, type], args[i]);\n      } else {\n        service = (0, services_1.injectValueService)(def.names.getDataSrv, name_1, type, args[i]);\n      }\n\n      (0, services_1.registerParticleScopeService)(peer, particle, service);\n    }\n\n    (0, services_1.registerParticleScopeService)(peer, particle, (0, services_1.responseService)(def, resolve));\n    (0, services_1.registerParticleScopeService)(peer, particle, (0, services_1.injectRelayService)(def, peer));\n    (0, services_1.registerParticleScopeService)(peer, particle, (0, services_1.errorHandlingService)(def, reject));\n    peer.internals.initiateParticle(particle, function (stage) {\n      // If function is void, then it's completed when one of the two conditions is met:\n      //  1. The particle is sent to the network (state 'sent')\n      //  2. All CallRequests are executed, e.g., all variable loading and local function calls are completed (state 'localWorkDone')\n      if (isReturnTypeVoid(def) && (stage.stage === 'sent' || stage.stage === 'localWorkDone')) {\n        resolve(undefined);\n      }\n\n      if (stage.stage === 'sendingError') {\n        reject(\"Could not send particle for \".concat(def.functionName, \": not connected  (particle id: \").concat(particle.id, \")\"));\n      }\n\n      if (stage.stage === 'expired') {\n        reject(\"Request timed out after \".concat(particle.ttl, \" for \").concat(def.functionName, \" (particle id: \").concat(particle.id, \")\"));\n      }\n\n      if (stage.stage === 'interpreterError') {\n        reject(\"Script interpretation failed for \".concat(def.functionName, \": \").concat(stage.errorMessage, \"  (particle id: \").concat(particle.id, \")\"));\n      }\n    });\n  });\n  return promise;\n}\n\nexports.callFunction = callFunction;\n\nvar isReturnTypeVoid = function (def) {\n  if (def.arrow.codomain.tag === 'nil') {\n    return true;\n  }\n\n  return def.arrow.codomain.items.length == 0;\n};\n/**\n * Arguments could be passed in one these configurations:\n * [...actualArgs]\n * [peer, ...actualArgs]\n * [...actualArgs, config]\n * [peer, ...actualArgs, config]\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, config, args }\n */\n\n\nvar extractArgs = function (args, numberOfExpectedArgs) {\n  var peer;\n  var structuredArgs;\n  var config;\n\n  if (FluencePeer_1.FluencePeer.isInstance(args[0])) {\n    peer = args[0];\n    structuredArgs = args.slice(1, numberOfExpectedArgs + 1);\n    config = args[numberOfExpectedArgs + 1];\n  } else {\n    peer = index_1.Fluence.getPeer();\n    structuredArgs = args.slice(0, numberOfExpectedArgs);\n    config = args[numberOfExpectedArgs];\n  }\n\n  return {\n    peer: peer,\n    config: config,\n    args: structuredArgs\n  };\n};","map":{"version":3,"mappings":"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","names":["callFunction","rawFnArgs","def","script","arrow","domain","tag","Error","argumentTypes","Object","entries","fields","expectedNumberOfArguments","length","extractArgs","args","peer","config","promise","Promise","resolve","reject","particle","internals","createNewParticle","ttl","message","i","name_1","type","service","names","callbackSrv","getDataSrv","initiateParticle","stage","isReturnTypeVoid","undefined","functionName","concat","id","errorMessage","exports","codomain","items","numberOfExpectedArgs","structuredArgs","FluencePeer_1","isInstance","slice","index_1","getPeer"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/compilerSupport/v3impl/callFunction.ts"],"sourcesContent":["import { FnConfig, FunctionCallDef } from './interface';\nimport { FluencePeer } from '../../FluencePeer';\nimport { Fluence } from '../../../index';\nimport { Particle } from '../../Particle';\nimport {\n    injectRelayService,\n    argToServiceDef,\n    registerParticleScopeService,\n    responseService,\n    errorHandlingService,\n    ServiceDescription,\n    userHandlerService,\n    injectValueService,\n} from './services';\n\n/**\n * Convenience function to support Aqua `func` generation backend\n * The compiler only need to generate a call the function and provide the corresponding definitions and the air script\n *\n * @param rawFnArgs - raw arguments passed by user to the generated function\n * @param def - function definition generated by the Aqua compiler\n * @param script - air script with function execution logic generated by the Aqua compiler\n */\nexport function callFunction(rawFnArgs: Array<any>, def: FunctionCallDef, script: string) {\n    if (def.arrow.domain.tag !== 'labeledProduct') {\n        throw new Error('Should be impossible');\n    }\n\n    const argumentTypes = Object.entries(def.arrow.domain.fields);\n    const expectedNumberOfArguments = argumentTypes.length;\n    const { args, peer, config } = extractArgs(rawFnArgs, expectedNumberOfArguments);\n\n    if (args.length !== expectedNumberOfArguments) {\n        throw new Error('Incorrect number of arguments. Expecting ${def.argDefs.length}');\n    }\n\n    const promise = new Promise((resolve, reject) => {\n        const particle = peer.internals.createNewParticle(script, config?.ttl);\n\n        if (particle instanceof Error) {\n            return reject(particle.message);\n        }\n\n        for (let i = 0; i < expectedNumberOfArguments; i++) {\n            const [name, type] = argumentTypes[i];\n            let service: ServiceDescription;\n            if (type.tag === 'arrow') {\n                service = userHandlerService(def.names.callbackSrv, [name, type], args[i]);\n            } else {\n                service = injectValueService(def.names.getDataSrv, name, type, args[i]);\n            }\n            registerParticleScopeService(peer, particle, service);\n        }\n\n        registerParticleScopeService(peer, particle, responseService(def, resolve));\n\n        registerParticleScopeService(peer, particle, injectRelayService(def, peer));\n\n        registerParticleScopeService(peer, particle, errorHandlingService(def, reject));\n\n        peer.internals.initiateParticle(particle, (stage) => {\n            // If function is void, then it's completed when one of the two conditions is met:\n            //  1. The particle is sent to the network (state 'sent')\n            //  2. All CallRequests are executed, e.g., all variable loading and local function calls are completed (state 'localWorkDone')\n            if (isReturnTypeVoid(def) && (stage.stage === 'sent' || stage.stage === 'localWorkDone')) {\n                resolve(undefined);\n            }\n\n            if (stage.stage === 'sendingError') {\n                reject(`Could not send particle for ${def.functionName}: not connected  (particle id: ${particle.id})`);\n            }\n\n            if (stage.stage === 'expired') {\n                reject(`Request timed out after ${particle.ttl} for ${def.functionName} (particle id: ${particle.id})`);\n            }\n\n            if (stage.stage === 'interpreterError') {\n                reject(\n                    `Script interpretation failed for ${def.functionName}: ${stage.errorMessage}  (particle id: ${particle.id})`,\n                );\n            }\n        });\n    });\n\n    return promise;\n}\n\nconst isReturnTypeVoid = (def: FunctionCallDef) => {\n    if (def.arrow.codomain.tag === 'nil') {\n        return true;\n    }\n\n    return def.arrow.codomain.items.length == 0;\n};\n\n/**\n * Arguments could be passed in one these configurations:\n * [...actualArgs]\n * [peer, ...actualArgs]\n * [...actualArgs, config]\n * [peer, ...actualArgs, config]\n *\n * This function select the appropriate configuration and returns\n * arguments in a structured way of: { peer, config, args }\n */\nconst extractArgs = (\n    args: any[],\n    numberOfExpectedArgs: number,\n): {\n    peer: FluencePeer;\n    config?: FnConfig;\n    args: any[];\n} => {\n    let peer: FluencePeer;\n    let structuredArgs: any[];\n    let config: any;\n    if (FluencePeer.isInstance(args[0])) {\n        peer = args[0];\n        structuredArgs = args.slice(1, numberOfExpectedArgs + 1);\n        config = args[numberOfExpectedArgs + 1];\n    } else {\n        peer = Fluence.getPeer();\n        structuredArgs = args.slice(0, numberOfExpectedArgs);\n        config = args[numberOfExpectedArgs];\n    }\n\n    return {\n        peer: peer,\n        config: config,\n        args: structuredArgs,\n    };\n};\n"]},"metadata":{},"sourceType":"script"}