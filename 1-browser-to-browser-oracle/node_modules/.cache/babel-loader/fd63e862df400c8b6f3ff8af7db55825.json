{"ast":null,"code":"// @ts-nocheck\n'use strict';\n\nconst mergeOptions = require('merge-options');\n\nconst {\n  pipe\n} = require('it-pipe');\n\nconst {\n  tap\n} = require('streaming-iterables');\n\nconst oldPeerLRU = require('./old-peers');\n\nconst {\n  METRICS: defaultOptions\n} = require('../constants');\n\nconst Stats = require('./stats');\n\nconst initialCounters = ['dataReceived', 'dataSent'];\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsOptions} options\n   */\n  constructor(options) {\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n    this._systems = new Map();\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  start() {\n    this._running = true;\n  }\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n\n\n  stop() {\n    this._running = false;\n\n    this._globalStats.stop();\n\n    for (const stats of this._peerStats.values()) {\n      stats.stop();\n    }\n\n    for (const stats of this._protocolStats.values()) {\n      stats.stop();\n    }\n  }\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n\n\n  get global() {\n    return this._globalStats;\n  }\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n\n\n  get peers() {\n    return Array.from(this._peerStats.keys());\n  }\n  /**\n   * @returns {Map<string, Map<string, Map<string, any>>>}\n   */\n\n\n  getComponentMetrics() {\n    return this._systems;\n  }\n\n  updateComponentMetric(_ref) {\n    let {\n      system = 'libp2p',\n      component,\n      metric,\n      value\n    } = _ref;\n\n    if (!this._systems.has(system)) {\n      this._systems.set(system, new Map());\n    }\n\n    const systemMetrics = this._systems.get(system);\n\n    if (!systemMetrics.has(component)) {\n      systemMetrics.set(component, new Map());\n    }\n\n    const componentMetrics = systemMetrics.get(component);\n    componentMetrics.set(metric, value);\n  }\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n\n\n  forPeer(peerId) {\n    const idString = peerId.toB58String();\n    return this._peerStats.get(idString) || this._oldPeers.get(idString);\n  }\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n\n\n  get protocols() {\n    return Array.from(this._protocolStats.keys());\n  }\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n\n\n  forProtocol(protocol) {\n    return this._protocolStats.get(protocol);\n  }\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n\n\n  onPeerDisconnected(peerId) {\n    const idString = peerId.toB58String();\n\n    const peerStats = this._peerStats.get(idString);\n\n    if (peerStats) {\n      peerStats.stop();\n\n      this._peerStats.delete(idString);\n\n      this._oldPeers.set(idString, peerStats);\n    }\n  }\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n\n\n  _onMessage(_ref2) {\n    let {\n      remotePeer,\n      protocol,\n      direction,\n      dataLength\n    } = _ref2;\n    if (!this._running) return;\n    const key = directionToEvent[direction];\n    let peerStats = this.forPeer(remotePeer);\n\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options);\n\n      this._peerStats.set(remotePeer.toB58String(), peerStats);\n    } // Peer and global stats\n\n\n    peerStats.push(key, dataLength);\n\n    this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol);\n\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options);\n\n        this._protocolStats.set(protocol, protocolStats);\n      }\n\n      protocolStats.push(key, dataLength);\n    }\n  }\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n\n\n  updatePlaceholder(placeholder, peerId) {\n    if (!this._running) return;\n    const placeholderStats = this.forPeer(placeholder);\n    const peerIdString = peerId.toB58String();\n    const existingStats = this.forPeer(peerId);\n    let mergedStats = placeholderStats; // If we already have stats, merge the two\n\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n      this._oldPeers.delete(peerIdString);\n    }\n\n    this._peerStats.delete(placeholder.toB58String());\n\n    this._peerStats.set(peerIdString, mergedStats);\n\n    mergedStats.start();\n  }\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n\n\n  trackStream(_ref3) {\n    let {\n      stream,\n      remotePeer,\n      protocol\n    } = _ref3;\n    const metrics = this;\n    const _source = stream.source;\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source);\n    const _sink = stream.sink;\n\n    stream.sink = source => {\n      return pipe(source, tap(chunk => metrics._onMessage({\n        remotePeer,\n        protocol,\n        direction: 'out',\n        dataLength: chunk.length\n      })), _sink);\n    };\n\n    return stream;\n  }\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n\n\n  static mergeStats(target, other) {\n    target.stop();\n    other.stop(); // Merge queues\n\n    target._queue = [...target._queue, ...other._queue]; // TODO: how to merge moving averages?\n\n    return target;\n  }\n\n}\n\nmodule.exports = Metrics;","map":{"version":3,"names":["mergeOptions","require","pipe","tap","oldPeerLRU","METRICS","defaultOptions","Stats","initialCounters","directionToEvent","in","out","Metrics","constructor","options","_options","_globalStats","_peerStats","Map","_protocolStats","_oldPeers","maxOldPeersRetention","_running","_onMessage","bind","_systems","start","stop","stats","values","global","peers","Array","from","keys","getComponentMetrics","updateComponentMetric","system","component","metric","value","has","set","systemMetrics","get","componentMetrics","forPeer","peerId","idString","toB58String","protocols","forProtocol","protocol","onPeerDisconnected","peerStats","delete","remotePeer","direction","dataLength","key","push","protocolStats","updatePlaceholder","placeholder","placeholderStats","peerIdString","existingStats","mergedStats","mergeStats","trackStream","stream","metrics","_source","source","chunk","length","_sink","sink","target","other","_queue","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/metrics/index.js"],"sourcesContent":["// @ts-nocheck\n'use strict'\n\nconst mergeOptions = require('merge-options')\nconst { pipe } = require('it-pipe')\nconst { tap } = require('streaming-iterables')\nconst oldPeerLRU = require('./old-peers')\nconst { METRICS: defaultOptions } = require('../constants')\nconst Stats = require('./stats')\n\nconst initialCounters = [\n  'dataReceived',\n  'dataSent'\n]\n\nconst directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n}\n\n/**\n * @typedef {import('peer-id')} PeerId\n * @typedef {import('libp2p-interfaces/src/transport/types').MultiaddrConnection} MultiaddrConnection\n */\n\n/**\n * @typedef MetricsOptions\n * @property {number} [computeThrottleMaxQueueSize = defaultOptions.computeThrottleMaxQueueSize]\n * @property {number} [computeThrottleTimeout = defaultOptions.computeThrottleTimeout]\n * @property {number[]} [movingAverageIntervals = defaultOptions.movingAverageIntervals]\n * @property {number} [maxOldPeersRetention = defaultOptions.maxOldPeersRetention]\n */\n\nclass Metrics {\n  /**\n   * @class\n   * @param {MetricsOptions} options\n   */\n  constructor (options) {\n    this._options = mergeOptions(defaultOptions, options)\n    this._globalStats = new Stats(initialCounters, this._options)\n    this._peerStats = new Map()\n    this._protocolStats = new Map()\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention)\n    this._running = false\n    this._onMessage = this._onMessage.bind(this)\n    this._systems = new Map()\n  }\n\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n  start () {\n    this._running = true\n  }\n\n  /**\n   * Stops all averages timers and prevents new data from being tracked.\n   * Once `stop` is called, `start` must be called to resume stats tracking.\n   */\n  stop () {\n    this._running = false\n    this._globalStats.stop()\n    for (const stats of this._peerStats.values()) {\n      stats.stop()\n    }\n    for (const stats of this._protocolStats.values()) {\n      stats.stop()\n    }\n  }\n\n  /**\n   * Gets the global `Stats` object\n   *\n   * @returns {Stats}\n   */\n  get global () {\n    return this._globalStats\n  }\n\n  /**\n   * Returns a list of `PeerId` strings currently being tracked\n   *\n   * @returns {string[]}\n   */\n  get peers () {\n    return Array.from(this._peerStats.keys())\n  }\n\n  /**\n   * @returns {Map<string, Map<string, Map<string, any>>>}\n   */\n  getComponentMetrics () {\n    return this._systems\n  }\n\n  updateComponentMetric ({ system = 'libp2p', component, metric, value }) {\n    if (!this._systems.has(system)) {\n      this._systems.set(system, new Map())\n    }\n\n    const systemMetrics = this._systems.get(system)\n\n    if (!systemMetrics.has(component)) {\n      systemMetrics.set(component, new Map())\n    }\n\n    const componentMetrics = systemMetrics.get(component)\n\n    componentMetrics.set(metric, value)\n  }\n\n  /**\n   * Returns the `Stats` object for the given `PeerId` whether it\n   * is a live peer, or in the disconnected peer LRU cache.\n   *\n   * @param {PeerId} peerId\n   * @returns {Stats}\n   */\n  forPeer (peerId) {\n    const idString = peerId.toB58String()\n    return this._peerStats.get(idString) || this._oldPeers.get(idString)\n  }\n\n  /**\n   * Returns a list of all protocol strings currently being tracked.\n   *\n   * @returns {string[]}\n   */\n  get protocols () {\n    return Array.from(this._protocolStats.keys())\n  }\n\n  /**\n   * Returns the `Stats` object for the given `protocol`.\n   *\n   * @param {string} protocol\n   * @returns {Stats}\n   */\n  forProtocol (protocol) {\n    return this._protocolStats.get(protocol)\n  }\n\n  /**\n   * Should be called when all connections to a given peer\n   * have closed. The `Stats` collection for the peer will\n   * be stopped and moved to an LRU for temporary retention.\n   *\n   * @param {PeerId} peerId\n   */\n  onPeerDisconnected (peerId) {\n    const idString = peerId.toB58String()\n    const peerStats = this._peerStats.get(idString)\n    if (peerStats) {\n      peerStats.stop()\n      this._peerStats.delete(idString)\n      this._oldPeers.set(idString, peerStats)\n    }\n  }\n\n  /**\n   * Takes the metadata for a message and tracks it in the\n   * appropriate categories. If the protocol is present, protocol\n   * stats will also be tracked.\n   *\n   * @private\n   * @param {object} params\n   * @param {PeerId} params.remotePeer - Remote peer\n   * @param {string} [params.protocol] - Protocol string the stream is running\n   * @param {string} params.direction - One of ['in','out']\n   * @param {number} params.dataLength - Size of the message\n   * @returns {void}\n   */\n  _onMessage ({ remotePeer, protocol, direction, dataLength }) {\n    if (!this._running) return\n\n    const key = directionToEvent[direction]\n\n    let peerStats = this.forPeer(remotePeer)\n    if (!peerStats) {\n      peerStats = new Stats(initialCounters, this._options)\n      this._peerStats.set(remotePeer.toB58String(), peerStats)\n    }\n\n    // Peer and global stats\n    peerStats.push(key, dataLength)\n    this._globalStats.push(key, dataLength)\n\n    // Protocol specific stats\n    if (protocol) {\n      let protocolStats = this.forProtocol(protocol)\n      if (!protocolStats) {\n        protocolStats = new Stats(initialCounters, this._options)\n        this._protocolStats.set(protocol, protocolStats)\n      }\n      protocolStats.push(key, dataLength)\n    }\n  }\n\n  /**\n   * Replaces the `PeerId` string with the given `peerId`.\n   * If stats are already being tracked for the given `peerId`, the\n   * placeholder stats will be merged with the existing stats.\n   *\n   * @param {PeerId} placeholder - A peerId string\n   * @param {PeerId} peerId\n   * @returns {void}\n   */\n  updatePlaceholder (placeholder, peerId) {\n    if (!this._running) return\n    const placeholderStats = this.forPeer(placeholder)\n    const peerIdString = peerId.toB58String()\n    const existingStats = this.forPeer(peerId)\n    let mergedStats = placeholderStats\n\n    // If we already have stats, merge the two\n    if (existingStats) {\n      // If existing, merge\n      mergedStats = Metrics.mergeStats(existingStats, mergedStats)\n      // Attempt to delete from the old peers list just in case it was tracked there\n      this._oldPeers.delete(peerIdString)\n    }\n\n    this._peerStats.delete(placeholder.toB58String())\n    this._peerStats.set(peerIdString, mergedStats)\n    mergedStats.start()\n  }\n\n  /**\n   * Tracks data running through a given Duplex Iterable `stream`. If\n   * the `peerId` is not provided, a placeholder string will be created and\n   * returned. This allows lazy tracking of a peer when the peer is not yet known.\n   * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n   * with the placeholder string returned from here, and the known `PeerId`.\n   *\n   * @param {Object} options\n   * @param {MultiaddrConnection} options.stream - A duplex iterable stream\n   * @param {PeerId} [options.remotePeer] - The id of the remote peer that's connected\n   * @param {string} [options.protocol] - The protocol the stream is running\n   * @returns {MultiaddrConnection} The peerId string or placeholder string\n   */\n  trackStream ({ stream, remotePeer, protocol }) {\n    const metrics = this\n    const _source = stream.source\n    stream.source = tap(chunk => metrics._onMessage({\n      remotePeer,\n      protocol,\n      direction: 'in',\n      dataLength: chunk.length\n    }))(_source)\n\n    const _sink = stream.sink\n    stream.sink = source => {\n      return pipe(\n        source,\n        tap(chunk => metrics._onMessage({\n          remotePeer,\n          protocol,\n          direction: 'out',\n          dataLength: chunk.length\n        })),\n        _sink\n      )\n    }\n\n    return stream\n  }\n\n  /**\n   * Merges `other` into `target`. `target` will be modified\n   * and returned.\n   *\n   * @param {Stats} target\n   * @param {Stats} other\n   * @returns {Stats}\n   */\n  static mergeStats (target, other) {\n    target.stop()\n    other.stop()\n\n    // Merge queues\n    target._queue = [...target._queue, ...other._queue]\n\n    // TODO: how to merge moving averages?\n    return target\n  }\n}\n\nmodule.exports = Metrics\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}