{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n});\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst errCode = require('err-code');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  MemoryDatastore\n} = require('datastore-core/memory');\n\nconst PeerRouting = require('./peer-routing');\n\nconst ContentRouting = require('./content-routing');\n\nconst getPeer = require('./get-peer');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes,\n  messages\n} = require('./errors');\n\nconst AddressManager = require('./address-manager');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst AutoDialler = require('./connection-manager/auto-dialler');\n\nconst Circuit = require('./circuit/transport');\n\nconst Relay = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Keychain = require('./keychain');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst PubsubAdapter = require('./pubsub-adapter');\n\nconst Registrar = require('./registrar');\n\nconst IdentifyService = require('./identify');\n\nconst FetchService = require('./fetch');\n\nconst PingService = require('./ping');\n\nconst NatManager = require('./nat-manager');\n\nconst {\n  updateSelfPeerRecord\n} = require('./record/utils');\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold]\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Partial<import('./types').ConnectionGater>} [connectionGater]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create(options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options);\n    }\n\n    const peerId = await PeerId.create();\n    options.peerId = peerId; // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n\n    return new Libp2p(options);\n  }\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n\n\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    /** @type {PeerId} */\n\n    this.peerId = this._options.peerId;\n    this.datastore = this._options.datastore; // Create Metrics\n\n    if (this._options.metrics.enabled) {\n      const metrics = new Metrics({ ...this._options.metrics\n      });\n      this.metrics = metrics;\n    }\n    /** @type {ConnectionGater} */\n\n\n    this.connectionGater = {\n      denyDialPeer: async () => Promise.resolve(false),\n      denyDialMultiaddr: async () => Promise.resolve(false),\n      denyInboundConnection: async () => Promise.resolve(false),\n      denyOutboundConnection: async () => Promise.resolve(false),\n      denyInboundEncryptedConnection: async () => Promise.resolve(false),\n      denyOutboundEncryptedConnection: async () => Promise.resolve(false),\n      denyInboundUpgradedConnection: async () => Promise.resolve(false),\n      denyOutboundUpgradedConnection: async () => Promise.resolve(false),\n      filterMultiaddrForPeer: async () => Promise.resolve(true),\n      ...this._options.connectionGater\n    };\n    /** @type {import('./peer-store/types').PeerStore} */\n\n    this.peerStore = new PeerStore({\n      peerId: this.peerId,\n      datastore: this.datastore && this._options.peerStore.persistence ? this.datastore : new MemoryDatastore(),\n      addressFilter: this.connectionGater.filterMultiaddrForPeer\n    }); // Addresses {listen, announce, noAnnounce}\n\n    this.addresses = this._options.addresses;\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses); // when addresses change, update our peer record\n\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err);\n      });\n    });\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n    // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, { ...this._options.connectionManager\n    });\n    this._autodialler = new AutoDialler(this, {\n      enabled: this._config.peerDiscovery.autoDial,\n      minConnections: this._options.connectionManager.minConnections,\n      autoDialInterval: this._options.connectionManager.autoDialInterval\n    }); // Create keychain\n\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain');\n      const keychainOpts = Keychain.generateOptions();\n      this.keychain = new Keychain(this._options.keychain.datastore, { ...keychainOpts,\n        ...this._options.keychain\n      });\n      log('keychain constructed');\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      connectionGater: this.connectionGater,\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: connection => this.connectionManager.onConnect(connection),\n      onConnectionEnd: connection => this.connectionManager.onDisconnect(connection)\n    }); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    }); // Create the Nat Manager\n\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Attach crypto channels\n\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);\n    }\n\n    const cryptos = this._modules.connEncryption;\n    cryptos.forEach(crypto => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto);\n    });\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      connectionGater: this.connectionGater,\n      peerStore: this.peerStore,\n      metrics: this.metrics,\n      ...this._options.dialer\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n      this.relay = new Relay(this);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        libp2p: this\n      });\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht; // @ts-ignore TODO: types need fixing - DHT is an `object` which has no `create` method\n\n      this._dht = DHT.create({\n        libp2p: this,\n        ...this._config.dht\n      });\n    } // Create pubsub if provided\n\n\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub; // using pubsub adapter with *DEPRECATED* handlers functionality\n\n      /** @type {Pubsub} */\n\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = new PeerRouting(this);\n    this.contentRouting = new ContentRouting(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n    this.fetchService = new FetchService(this);\n    this.pingService = new PingService(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n\n\n  emit(eventName) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args);\n      return false;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('libp2p is starting');\n\n    if (this.identifyService) {\n      await this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);\n    }\n\n    if (this.fetchService) {\n      await this.handle(FetchService.PROTOCOL, this.fetchService.handleMessage);\n    }\n\n    if (this.pingService) {\n      await this.handle(PingService.getProtocolStr(this), this.pingService.handleMessage);\n    }\n\n    try {\n      await this._onStarting();\n      await this._onDidStart();\n      log('libp2p has started');\n    } catch (\n    /** @type {any} */\n    err) {\n      this.emit('error', err);\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    log('libp2p is stopping');\n\n    try {\n      this._isStarted = false;\n\n      if (this.identifyService) {\n        await this.identifyService.stop();\n      }\n\n      this.relay && this.relay.stop();\n      this.peerRouting.stop();\n      await this._autodialler.stop();\n      await (this._dht && this._dht.stop());\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer);\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()));\n      this._discovery = new Map();\n      await this.connectionManager.stop();\n      await Promise.all([this.pubsub && this.pubsub.stop(), this.metrics && this.metrics.stop()]);\n      await this.natManager.stop();\n      await this.transportManager.close();\n      await this.unhandle(FetchService.PROTOCOL);\n      await this.unhandle(PingService.getProtocolStr(this));\n      this.dialer.destroy();\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n    }\n\n    log('libp2p has stopped');\n  }\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n\n\n  async loadKeychain() {\n    if (!this.keychain) {\n      return;\n    }\n\n    try {\n      await this.keychain.findKeyByName('self');\n    } catch (\n    /** @type {any} */\n    err) {\n      await this.keychain.importPeer('self', this.peerId);\n    }\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.connectionManager.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this._dial(peer, options);\n  }\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n\n\n  async dialProtocol(peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);\n    }\n\n    const connection = await this._dial(peer, options);\n    return connection.newStream(protocols);\n  }\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n\n\n  async _dial(peer, options) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer);\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF);\n    }\n\n    let connection = this.connectionManager.get(id);\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options);\n    } else if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs);\n    }\n\n    return connection;\n  }\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n\n\n  get multiaddrs() {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString());\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString());\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()));\n    const announceFilter = this._options.addresses.announceFilter; // dedupe multiaddrs\n\n    const addrSet = new Set(addrs); // Create advertising list\n\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)));\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  async hangUp(peer) {\n    const {\n      id\n    } = getPeer(peer);\n    const connections = this.connectionManager.connections.get(id.toB58String());\n\n    if (!connections) {\n      return;\n    }\n\n    await Promise.all(connections.map(connection => {\n      return connection.close();\n    }));\n  }\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {string} key\n   * @returns {Promise<Uint8Array | null>}\n   */\n\n\n  fetch(peer, key) {\n    return this.fetchService.fetch(peer, key);\n  }\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  ping(peer) {\n    const {\n      id,\n      multiaddrs\n    } = getPeer(peer); // If received multiaddr, ping it\n\n    if (multiaddrs) {\n      return this.pingService.ping(multiaddrs[0]);\n    }\n\n    return this.pingService.ping(id);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n\n\n  async handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Add new protocols to self protocols in the Protobook\n\n    await this.peerStore.protoBook.add(this.peerId, protocols);\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n\n\n  async unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Remove protocols from self protocols in the Protobook\n\n    await this.peerStore.protoBook.remove(this.peerId, protocols);\n  }\n\n  async _onStarting() {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs();\n    await this.transportManager.listen(addrs); // Manage your NATs\n\n    this.natManager.start();\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && (await this.pubsub.start());\n    } // DHT subsystem\n\n\n    if (this._config.dht.enabled) {\n      this._dht && (await this._dht.start()); // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n\n      this._dht.on('peer', this._onDiscoveryPeer);\n    } // Start metrics if present\n\n\n    this.metrics && this.metrics.start();\n\n    if (this.identifyService) {\n      await this.identifyService.start();\n    }\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n\n\n  async _onDidStart() {\n    this._isStarted = true;\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId);\n\n      this._maybeConnect(peerId).catch(err => {\n        log.error(err);\n      });\n    }); // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n\n    for await (const peer of this.peerStore.getPeers()) {\n      this.emit('peer:discovery', peer.id);\n    }\n\n    this.connectionManager.start();\n    await this._autodialler.start(); // Peer discovery\n\n    await this._setupPeerDiscovery(); // Relay\n\n    this.relay && this.relay.start();\n    this.peerRouting.start();\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n\n\n  _onDiscoveryPeer(peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch(err => log.error(err));\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols).catch(err => log.error(err));\n  }\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n\n\n  async _maybeConnect(peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0;\n\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String());\n\n        try {\n          await this.dialer.connectToPeer(peerId);\n        } catch (\n        /** @type {any} */\n        err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);\n        }\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  async _setupPeerDiscovery() {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = DiscoveryService => {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {\n        // not already added\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer);\n\n        this._discovery.set(DiscoveryService.tag, discoveryService);\n      }\n    }; // Discovery modules\n\n\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService);\n    } // Transport modules with discovery\n\n\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery);\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()));\n  }\n\n}\n\nmodule.exports = Libp2p;","map":{"version":3,"names":["debug","require","log","Object","assign","error","EventEmitter","errCode","PeerId","Multiaddr","MemoryDatastore","PeerRouting","ContentRouting","getPeer","validate","validateConfig","codes","messages","AddressManager","ConnectionManager","AutoDialler","Circuit","Relay","Dialer","Keychain","Metrics","TransportManager","Upgrader","PeerStore","PubsubAdapter","Registrar","IdentifyService","FetchService","PingService","NatManager","updateSelfPeerRecord","Libp2p","create","options","peerId","constructor","_options","datastore","metrics","enabled","connectionGater","denyDialPeer","Promise","resolve","denyDialMultiaddr","denyInboundConnection","denyOutboundConnection","denyInboundEncryptedConnection","denyOutboundEncryptedConnection","denyInboundUpgradedConnection","denyOutboundUpgradedConnection","filterMultiaddrForPeer","peerStore","persistence","addressFilter","addresses","addressManager","on","catch","err","_modules","modules","_config","config","_transport","_discovery","Map","connectionManager","_autodialler","peerDiscovery","autoDial","minConnections","autoDialInterval","keychain","keychainOpts","generateOptions","upgrader","localPeer","onConnection","connection","onConnect","onConnectionEnd","onDisconnect","transportManager","libp2p","faultTolerance","natManager","nat","registrar","handle","bind","connEncryption","length","Error","CONN_ENCRYPTION_REQUIRED","cryptos","forEach","crypto","set","protocol","dialer","transport","Transport","key","prototype","Symbol","toStringTag","transportOptions","add","relay","streamMuxer","muxers","muxer","multicodec","identifyService","connProtector","protector","globalThis","process","undefined","env","LIBP2P_FORCE_PNET","dht","DHT","_dht","pubsub","Pubsub","peerRouting","contentRouting","_onDiscoveryPeer","fetchService","pingService","emit","eventName","args","_events","start","values","getProtocolStr","handleMessage","PROTOCOL","_onStarting","_onDidStart","stop","_isStarted","service","removeListener","all","Array","from","s","close","unhandle","destroy","loadKeychain","findKeyByName","importPeer","isStarted","connections","dial","peer","_dial","dialProtocol","protocols","ERR_INVALID_PROTOCOLS_FOR_STREAM","newStream","id","multiaddrs","equals","ERR_DIALED_SELF","get","connectToPeer","addressBook","addrs","getAnnounceAddrs","map","ma","toString","getAddrs","concat","getObservedAddrs","announceFilter","addrSet","Set","str","hangUp","toB58String","fetch","ping","handler","isArray","protoBook","delete","remove","getListenAddrs","listen","_maybeConnect","getPeers","_setupPeerDiscovery","ERR_DISCOVERED_SELF","size","setupService","DiscoveryService","tag","has","discoveryService","getTransports","discovery","d","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/index.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst log = Object.assign(debug('libp2p'), {\n  error: debug('libp2p:err')\n})\nconst { EventEmitter } = require('events')\n\nconst errCode = require('err-code')\nconst PeerId = require('peer-id')\nconst { Multiaddr } = require('multiaddr')\nconst { MemoryDatastore } = require('datastore-core/memory')\nconst PeerRouting = require('./peer-routing')\nconst ContentRouting = require('./content-routing')\nconst getPeer = require('./get-peer')\nconst { validate: validateConfig } = require('./config')\nconst { codes, messages } = require('./errors')\n\nconst AddressManager = require('./address-manager')\nconst ConnectionManager = require('./connection-manager')\nconst AutoDialler = require('./connection-manager/auto-dialler')\nconst Circuit = require('./circuit/transport')\nconst Relay = require('./circuit')\nconst Dialer = require('./dialer')\nconst Keychain = require('./keychain')\nconst Metrics = require('./metrics')\nconst TransportManager = require('./transport-manager')\nconst Upgrader = require('./upgrader')\nconst PeerStore = require('./peer-store')\nconst PubsubAdapter = require('./pubsub-adapter')\nconst Registrar = require('./registrar')\nconst IdentifyService = require('./identify')\nconst FetchService = require('./fetch')\nconst PingService = require('./ping')\nconst NatManager = require('./nat-manager')\nconst { updateSelfPeerRecord } = require('./record/utils')\n\n/**\n * @typedef {import('libp2p-interfaces/src/connection').Connection} Connection\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream\n * @typedef {import('libp2p-interfaces/src/transport/types').TransportFactory<any, any>} TransportFactory\n * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxerFactory} MuxerFactory\n * @typedef {import('libp2p-interfaces/src/content-routing/types').ContentRouting} ContentRoutingModule\n * @typedef {import('libp2p-interfaces/src/peer-discovery/types').PeerDiscoveryFactory} PeerDiscoveryFactory\n * @typedef {import('libp2p-interfaces/src/peer-routing/types').PeerRouting} PeerRoutingModule\n * @typedef {import('libp2p-interfaces/src/crypto/types').Crypto} Crypto\n * @typedef {import('libp2p-interfaces/src/pubsub')} Pubsub\n * @typedef {import('libp2p-interfaces/src/pubsub').PubsubOptions} PubsubOptions\n * @typedef {import('interface-datastore').Datastore} Datastore\n * @typedef {import('./pnet')} Protector\n * @typedef {import('./types').ConnectionGater} ConnectionGater\n * @typedef {Object} PersistentPeerStoreOptions\n * @property {number} [threshold]\n */\n\n/**\n * @typedef {Object} HandlerProps\n * @property {Connection} connection\n * @property {MuxedStream} stream\n * @property {string} protocol\n *\n * @typedef {Object} DhtOptions\n * @property {boolean} [enabled = false]\n * @property {number} [kBucketSize = 20]\n * @property {boolean} [clientMode]\n * @property {import('libp2p-interfaces/src/types').DhtSelectors} [selectors]\n * @property {import('libp2p-interfaces/src/types').DhtValidators} [validators]\n *\n * @typedef {Object} KeychainOptions\n * @property {Datastore} [datastore]\n *\n * @typedef {Object} PeerStoreOptions\n * @property {boolean} persistence\n *\n * @typedef {Object} PubsubLocalOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} MetricsOptions\n * @property {boolean} enabled\n *\n * @typedef {Object} RelayOptions\n * @property {boolean} [enabled = true]\n * @property {import('./circuit').RelayAdvertiseOptions} [advertise]\n * @property {import('./circuit').HopOptions} [hop]\n * @property {import('./circuit').AutoRelayOptions} [autoRelay]\n *\n * @typedef {Object} Libp2pConfig\n * @property {DhtOptions} [dht] dht module options\n * @property {import('./nat-manager').NatManagerOptions} [nat]\n * @property {Record<string, Object|boolean>} [peerDiscovery]\n * @property {PubsubLocalOptions & PubsubOptions} [pubsub] pubsub module options\n * @property {RelayOptions} [relay]\n * @property {Record<string, Object>} [transport] transport options indexed by transport key\n *\n * @typedef {Object} Libp2pModules\n * @property {TransportFactory[]} transport\n * @property {MuxerFactory[]} streamMuxer\n * @property {Crypto[]} connEncryption\n * @property {PeerDiscoveryFactory[]} [peerDiscovery]\n * @property {PeerRoutingModule[]} [peerRouting]\n * @property {ContentRoutingModule[]} [contentRouting]\n * @property {Object} [dht]\n * @property {{new(...args: any[]): Pubsub}} [pubsub]\n * @property {Protector} [connProtector]\n *\n * @typedef {Object} Libp2pOptions\n * @property {Libp2pModules} modules libp2p modules to use\n * @property {import('./address-manager').AddressManagerOptions} [addresses]\n * @property {import('./connection-manager').ConnectionManagerOptions} [connectionManager]\n * @property {Partial<import('./types').ConnectionGater>} [connectionGater]\n * @property {Datastore} [datastore]\n * @property {import('./dialer').DialerOptions} [dialer]\n * @property {import('./identify/index').HostProperties} [host] libp2p host\n * @property {KeychainOptions & import('./keychain/index').KeychainOptions} [keychain]\n * @property {MetricsOptions & import('./metrics').MetricsOptions} [metrics]\n * @property {import('./peer-routing').PeerRoutingOptions} [peerRouting]\n * @property {PeerStoreOptions} [peerStore]\n * @property {import('./transport-manager').TransportManagerOptions} [transportManager]\n * @property {Libp2pConfig} [config]\n *\n * @typedef {Object} constructorOptions\n * @property {PeerId} peerId\n *\n * @typedef {Object} CreateOptions\n * @property {PeerId} [peerId]\n *\n * @extends {EventEmitter}\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\nclass Libp2p extends EventEmitter {\n  /**\n   * Like `new Libp2p(options)` except it will create a `PeerId`\n   * instance if one is not provided in options.\n   *\n   * @param {Libp2pOptions & CreateOptions} options - Libp2p configuration options\n   * @returns {Promise<Libp2p>}\n   */\n  static async create (options) {\n    if (options.peerId) {\n      // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n      return new Libp2p(options)\n    }\n\n    const peerId = await PeerId.create()\n\n    options.peerId = peerId\n    // @ts-ignore 'Libp2pOptions & CreateOptions' is not assignable to 'Libp2pOptions & constructorOptions'\n    return new Libp2p(options)\n  }\n\n  /**\n   * Libp2p node.\n   *\n   * @class\n   * @param {Libp2pOptions & constructorOptions} _options\n   */\n  constructor (_options) {\n    super()\n    // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n    this._options = validateConfig(_options)\n\n    /** @type {PeerId} */\n    this.peerId = this._options.peerId\n    this.datastore = this._options.datastore\n\n    // Create Metrics\n    if (this._options.metrics.enabled) {\n      const metrics = new Metrics({\n        ...this._options.metrics\n      })\n\n      this.metrics = metrics\n    }\n\n    /** @type {ConnectionGater} */\n    this.connectionGater = {\n      denyDialPeer: async () => Promise.resolve(false),\n      denyDialMultiaddr: async () => Promise.resolve(false),\n      denyInboundConnection: async () => Promise.resolve(false),\n      denyOutboundConnection: async () => Promise.resolve(false),\n      denyInboundEncryptedConnection: async () => Promise.resolve(false),\n      denyOutboundEncryptedConnection: async () => Promise.resolve(false),\n      denyInboundUpgradedConnection: async () => Promise.resolve(false),\n      denyOutboundUpgradedConnection: async () => Promise.resolve(false),\n      filterMultiaddrForPeer: async () => Promise.resolve(true),\n      ...this._options.connectionGater\n    }\n\n    /** @type {import('./peer-store/types').PeerStore} */\n    this.peerStore = new PeerStore({\n      peerId: this.peerId,\n      datastore: (this.datastore && this._options.peerStore.persistence) ? this.datastore : new MemoryDatastore(),\n      addressFilter: this.connectionGater.filterMultiaddrForPeer\n    })\n\n    // Addresses {listen, announce, noAnnounce}\n    this.addresses = this._options.addresses\n    this.addressManager = new AddressManager(this.peerId, this._options.addresses)\n\n    // when addresses change, update our peer record\n    this.addressManager.on('change:addresses', () => {\n      updateSelfPeerRecord(this).catch(err => {\n        log.error('Error updating self peer record', err)\n      })\n    })\n\n    this._modules = this._options.modules\n    this._config = this._options.config\n    this._transport = [] // Transport instances/references\n    this._discovery = new Map() // Discovery service instances/references\n\n    // Create the Connection Manager\n    this.connectionManager = new ConnectionManager(this, {\n      ...this._options.connectionManager\n    })\n    this._autodialler = new AutoDialler(this, {\n      enabled: this._config.peerDiscovery.autoDial,\n      minConnections: this._options.connectionManager.minConnections,\n      autoDialInterval: this._options.connectionManager.autoDialInterval\n    })\n\n    // Create keychain\n    if (this._options.keychain && this._options.keychain.datastore) {\n      log('creating keychain')\n\n      const keychainOpts = Keychain.generateOptions()\n\n      this.keychain = new Keychain(this._options.keychain.datastore, {\n        ...keychainOpts,\n        ...this._options.keychain\n      })\n\n      log('keychain constructed')\n    }\n\n    // Setup the Upgrader\n    this.upgrader = new Upgrader({\n      connectionGater: this.connectionGater,\n      localPeer: this.peerId,\n      metrics: this.metrics,\n      onConnection: (connection) => this.connectionManager.onConnect(connection),\n      onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)\n    })\n\n    // Setup the transport manager\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader,\n      faultTolerance: this._options.transportManager.faultTolerance\n    })\n\n    // Create the Nat Manager\n    this.natManager = new NatManager({\n      peerId: this.peerId,\n      addressManager: this.addressManager,\n      transportManager: this.transportManager,\n      // @ts-ignore Nat typedef is not understood as Object\n      ...this._options.config.nat\n    })\n\n    // Create the Registrar\n    this.registrar = new Registrar({\n      peerStore: this.peerStore,\n      connectionManager: this.connectionManager\n    })\n\n    this.handle = this.handle.bind(this)\n    this.registrar.handle = this.handle\n\n    // Attach crypto channels\n    if (!this._modules.connEncryption || !this._modules.connEncryption.length) {\n      throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED)\n    }\n    const cryptos = this._modules.connEncryption\n    cryptos.forEach((crypto) => {\n      this.upgrader.cryptos.set(crypto.protocol, crypto)\n    })\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      connectionGater: this.connectionGater,\n      peerStore: this.peerStore,\n      metrics: this.metrics,\n      ...this._options.dialer\n    })\n\n    this._modules.transport.forEach((Transport) => {\n      const key = Transport.prototype[Symbol.toStringTag]\n      const transportOptions = this._config.transport[key]\n      this.transportManager.add(key, Transport, transportOptions)\n    })\n\n    if (this._config.relay.enabled) {\n      // @ts-ignore Circuit prototype\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit)\n      this.relay = new Relay(this)\n    }\n\n    // Attach stream multiplexers\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer\n      muxers.forEach((muxer) => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer)\n      })\n\n      // Add the identify service since we can multiplex\n      this.identifyService = new IdentifyService({ libp2p: this })\n    }\n\n    // Attach private network protector\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) { // eslint-disable-line no-undef\n      throw new Error('Private network is enforced, but no protector was provided')\n    }\n\n    // dht provided components (peerRouting, contentRouting, dht)\n    if (this._modules.dht) {\n      const DHT = this._modules.dht\n      // @ts-ignore TODO: types need fixing - DHT is an `object` which has no `create` method\n      this._dht = DHT.create({\n        libp2p: this,\n        ...this._config.dht\n      })\n    }\n\n    // Create pubsub if provided\n    if (this._modules.pubsub) {\n      const Pubsub = this._modules.pubsub\n      // using pubsub adapter with *DEPRECATED* handlers functionality\n      /** @type {Pubsub} */\n      this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub)\n    }\n\n    // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n    this.peerRouting = new PeerRouting(this)\n    this.contentRouting = new ContentRouting(this)\n\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this)\n\n    this.fetchService = new FetchService(this)\n    this.pingService = new PingService(this)\n  }\n\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   *\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {boolean}\n   */\n  emit (eventName, ...args) {\n    // TODO: do we still need this?\n    // @ts-ignore _events does not exist in libp2p\n    if (eventName === 'error' && !this._events.error) {\n      log.error(args)\n      return false\n    } else {\n      return super.emit(eventName, ...args)\n    }\n  }\n\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n  async start () {\n    log('libp2p is starting')\n\n    if (this.identifyService) {\n      await this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage)\n    }\n\n    if (this.fetchService) {\n      await this.handle(FetchService.PROTOCOL, this.fetchService.handleMessage)\n    }\n\n    if (this.pingService) {\n      await this.handle(PingService.getProtocolStr(this), this.pingService.handleMessage)\n    }\n\n    try {\n      await this._onStarting()\n      await this._onDidStart()\n      log('libp2p has started')\n    } catch (/** @type {any} */ err) {\n      this.emit('error', err)\n      log.error('An error occurred starting libp2p', err)\n      await this.stop()\n      throw err\n    }\n  }\n\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async stop () {\n    log('libp2p is stopping')\n\n    try {\n      this._isStarted = false\n\n      if (this.identifyService) {\n        await this.identifyService.stop()\n      }\n\n      this.relay && this.relay.stop()\n      this.peerRouting.stop()\n      await this._autodialler.stop()\n      await (this._dht && this._dht.stop())\n\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer)\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()))\n\n      this._discovery = new Map()\n\n      await this.connectionManager.stop()\n\n      await Promise.all([\n        this.pubsub && this.pubsub.stop(),\n        this.metrics && this.metrics.stop()\n      ])\n\n      await this.natManager.stop()\n      await this.transportManager.close()\n\n      await this.unhandle(FetchService.PROTOCOL)\n      await this.unhandle(PingService.getProtocolStr(this))\n\n      this.dialer.destroy()\n    } catch (/** @type {any} */ err) {\n      if (err) {\n        log.error(err)\n        this.emit('error', err)\n      }\n    }\n    log('libp2p has stopped')\n  }\n\n  /**\n   * Load keychain keys from the datastore.\n   * Imports the private key as 'self', if needed.\n   *\n   * @async\n   * @returns {Promise<void>}\n   */\n  async loadKeychain () {\n    if (!this.keychain) {\n      return\n    }\n\n    try {\n      await this.keychain.findKeyByName('self')\n    } catch (/** @type {any} */ err) {\n      await this.keychain.importPeer('self', this.peerId)\n    }\n  }\n\n  isStarted () {\n    return this._isStarted\n  }\n\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   *\n   * @returns {Map<string, Connection[]>}\n   */\n  get connections () {\n    return this.connectionManager.connections\n  }\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n  dial (peer, options) {\n    return this._dial(peer, options)\n  }\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal]\n   */\n  async dialProtocol (peer, protocols, options) {\n    if (!protocols || !protocols.length) {\n      throw errCode(new Error('no protocols were provided to open a stream'), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM)\n    }\n\n    const connection = await this._dial(peer, options)\n    return connection.newStream(protocols)\n  }\n\n  /**\n   * @async\n   * @param {PeerId|Multiaddr|string} peer - The peer to dial\n   * @param {object} [options]\n   * @returns {Promise<Connection>}\n   */\n  async _dial (peer, options) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    if (id.equals(this.peerId)) {\n      throw errCode(new Error('Cannot dial self'), codes.ERR_DIALED_SELF)\n    }\n\n    let connection = this.connectionManager.get(id)\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(peer, options)\n    } else if (multiaddrs) {\n      await this.peerStore.addressBook.add(id, multiaddrs)\n    }\n\n    return connection\n  }\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @returns {Multiaddr[]}\n   */\n  get multiaddrs () {\n    let addrs = this.addressManager.getAnnounceAddrs().map(ma => ma.toString())\n\n    if (!addrs.length) {\n      // no configured announce addrs, add configured listen addresses\n      addrs = this.transportManager.getAddrs().map(ma => ma.toString())\n    }\n\n    addrs = addrs.concat(this.addressManager.getObservedAddrs().map(ma => ma.toString()))\n\n    const announceFilter = this._options.addresses.announceFilter\n\n    // dedupe multiaddrs\n    const addrSet = new Set(addrs)\n\n    // Create advertising list\n    return announceFilter(Array.from(addrSet).map(str => new Multiaddr(str)))\n  }\n\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerId|Multiaddr|string} peer - the peer to close connections to\n   * @returns {Promise<void>}\n   */\n  async hangUp (peer) {\n    const { id } = getPeer(peer)\n\n    const connections = this.connectionManager.connections.get(id.toB58String())\n\n    if (!connections) {\n      return\n    }\n\n    await Promise.all(\n      connections.map(connection => {\n        return connection.close()\n      })\n    )\n  }\n\n  /**\n   * Sends a request to fetch the value associated with the given key from the given peer.\n   *\n   * @param {PeerId|Multiaddr} peer\n   * @param {string} key\n   * @returns {Promise<Uint8Array | null>}\n   */\n  fetch (peer, key) {\n    return this.fetchService.fetch(peer, key)\n  }\n\n  /**\n   * Pings the given peer in order to obtain the operation latency.\n   *\n   * @param {PeerId|Multiaddr|string} peer - The peer to ping\n   * @returns {Promise<number>}\n   */\n  ping (peer) {\n    const { id, multiaddrs } = getPeer(peer)\n\n    // If received multiaddr, ping it\n    if (multiaddrs) {\n      return this.pingService.ping(multiaddrs[0])\n    }\n\n    return this.pingService.ping(id)\n  }\n\n  /**\n   * Registers the `handler` for each protocol\n   *\n   * @param {string[]|string} protocols\n   * @param {(props: HandlerProps) => void} handler\n   */\n  async handle (protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler)\n    })\n\n    // Add new protocols to self protocols in the Protobook\n    await this.peerStore.protoBook.add(this.peerId, protocols)\n  }\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @param {string[]|string} protocols\n   */\n  async unhandle (protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols]\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol)\n    })\n\n    // Remove protocols from self protocols in the Protobook\n    await this.peerStore.protoBook.remove(this.peerId, protocols)\n  }\n\n  async _onStarting () {\n    // Listen on the provided transports for the provided addresses\n    const addrs = this.addressManager.getListenAddrs()\n    await this.transportManager.listen(addrs)\n\n    // Manage your NATs\n    this.natManager.start()\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && await this.pubsub.start()\n    }\n\n    // DHT subsystem\n    if (this._config.dht.enabled) {\n      this._dht && await this._dht.start()\n\n      // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n      this._dht.on('peer', this._onDiscoveryPeer)\n    }\n\n    // Start metrics if present\n    this.metrics && this.metrics.start()\n\n    if (this.identifyService) {\n      await this.identifyService.start()\n    }\n  }\n\n  /**\n   * Called when libp2p has started and before it returns\n   *\n   * @private\n   */\n  async _onDidStart () {\n    this._isStarted = true\n\n    this.peerStore.on('peer', peerId => {\n      this.emit('peer:discovery', peerId)\n      this._maybeConnect(peerId).catch(err => {\n        log.error(err)\n      })\n    })\n\n    // Once we start, emit any peers we may have already discovered\n    // TODO: this should be removed, as we already discovered these peers in the past\n    for await (const peer of this.peerStore.getPeers()) {\n      this.emit('peer:discovery', peer.id)\n    }\n\n    this.connectionManager.start()\n    await this._autodialler.start()\n\n    // Peer discovery\n    await this._setupPeerDiscovery()\n\n    // Relay\n    this.relay && this.relay.start()\n\n    this.peerRouting.start()\n  }\n\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   *\n   * @private\n   * @param {{ id: PeerId, multiaddrs: Multiaddr[], protocols: string[] }} peer\n   */\n  _onDiscoveryPeer (peer) {\n    if (peer.id.toB58String() === this.peerId.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF))\n      return\n    }\n\n    peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs).catch(err => log.error(err))\n    peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols).catch(err => log.error(err))\n  }\n\n  /**\n   * Will dial to the given `peerId` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minConnections.\n   *\n   * @private\n   * @param {PeerId} peerId\n   */\n  async _maybeConnect (peerId) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {\n      const minConnections = this._options.connectionManager.minConnections || 0\n      if (minConnections > this.connectionManager.size) {\n        log('connecting to discovered peer %s', peerId.toB58String())\n        try {\n          await this.dialer.connectToPeer(peerId)\n        } catch (/** @type {any} */ err) {\n          log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`)\n        }\n      }\n    }\n  }\n\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n  async _setupPeerDiscovery () {\n    /**\n     * @param {PeerDiscoveryFactory} DiscoveryService\n     */\n    const setupService = (DiscoveryService) => {\n      let config = {\n        enabled: true // on by default\n      }\n\n      if (DiscoveryService.tag &&\n        this._config.peerDiscovery &&\n        this._config.peerDiscovery[DiscoveryService.tag]) {\n        // @ts-ignore PeerDiscovery not understood as an Object for spread\n        config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] }\n      }\n\n      if (config.enabled &&\n        !this._discovery.has(DiscoveryService.tag)) { // not already added\n        let discoveryService\n\n        if (typeof DiscoveryService === 'function') {\n          // @ts-ignore DiscoveryService has no constructor type inferred\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerId: this.peerId,\n            libp2p: this\n          }))\n        } else {\n          discoveryService = DiscoveryService\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer)\n        this._discovery.set(DiscoveryService.tag, discoveryService)\n      }\n    }\n\n    // Discovery modules\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService)\n    }\n\n    // Transport modules with discovery\n    for (const Transport of this.transportManager.getTransports()) {\n      // @ts-ignore Transport interface does not include discovery\n      if (Transport.discovery) {\n        // @ts-ignore Transport interface does not include discovery\n        setupService(Transport.discovery)\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()))\n  }\n}\n\nmodule.exports = Libp2p\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMC,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAcJ,KAAK,CAAC,QAAD,CAAnB,EAA+B;EACzCK,KAAK,EAAEL,KAAK,CAAC,YAAD;AAD6B,CAA/B,CAAZ;;AAGA,MAAM;EAAEM;AAAF,IAAmBL,OAAO,CAAC,QAAD,CAAhC;;AAEA,MAAMM,OAAO,GAAGN,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAM;EAAEQ;AAAF,IAAgBR,OAAO,CAAC,WAAD,CAA7B;;AACA,MAAM;EAAES;AAAF,IAAsBT,OAAO,CAAC,uBAAD,CAAnC;;AACA,MAAMU,WAAW,GAAGV,OAAO,CAAC,gBAAD,CAA3B;;AACA,MAAMW,cAAc,GAAGX,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMY,OAAO,GAAGZ,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAM;EAAEa,QAAQ,EAAEC;AAAZ,IAA+Bd,OAAO,CAAC,UAAD,CAA5C;;AACA,MAAM;EAAEe,KAAF;EAASC;AAAT,IAAsBhB,OAAO,CAAC,UAAD,CAAnC;;AAEA,MAAMiB,cAAc,GAAGjB,OAAO,CAAC,mBAAD,CAA9B;;AACA,MAAMkB,iBAAiB,GAAGlB,OAAO,CAAC,sBAAD,CAAjC;;AACA,MAAMmB,WAAW,GAAGnB,OAAO,CAAC,mCAAD,CAA3B;;AACA,MAAMoB,OAAO,GAAGpB,OAAO,CAAC,qBAAD,CAAvB;;AACA,MAAMqB,KAAK,GAAGrB,OAAO,CAAC,WAAD,CAArB;;AACA,MAAMsB,MAAM,GAAGtB,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAMuB,QAAQ,GAAGvB,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAMwB,OAAO,GAAGxB,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMyB,gBAAgB,GAAGzB,OAAO,CAAC,qBAAD,CAAhC;;AACA,MAAM0B,QAAQ,GAAG1B,OAAO,CAAC,YAAD,CAAxB;;AACA,MAAM2B,SAAS,GAAG3B,OAAO,CAAC,cAAD,CAAzB;;AACA,MAAM4B,aAAa,GAAG5B,OAAO,CAAC,kBAAD,CAA7B;;AACA,MAAM6B,SAAS,GAAG7B,OAAO,CAAC,aAAD,CAAzB;;AACA,MAAM8B,eAAe,GAAG9B,OAAO,CAAC,YAAD,CAA/B;;AACA,MAAM+B,YAAY,GAAG/B,OAAO,CAAC,SAAD,CAA5B;;AACA,MAAMgC,WAAW,GAAGhC,OAAO,CAAC,QAAD,CAA3B;;AACA,MAAMiC,UAAU,GAAGjC,OAAO,CAAC,eAAD,CAA1B;;AACA,MAAM;EAAEkC;AAAF,IAA2BlC,OAAO,CAAC,gBAAD,CAAxC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMmC,MAAN,SAAqB9B,YAArB,CAAkC;EAChC;AACF;AACA;AACA;AACA;AACA;AACA;EACqB,aAAN+B,MAAM,CAAEC,OAAF,EAAW;IAC5B,IAAIA,OAAO,CAACC,MAAZ,EAAoB;MAClB;MACA,OAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;IACD;;IAED,MAAMC,MAAM,GAAG,MAAM/B,MAAM,CAAC6B,MAAP,EAArB;IAEAC,OAAO,CAACC,MAAR,GAAiBA,MAAjB,CAR4B,CAS5B;;IACA,OAAO,IAAIH,MAAJ,CAAWE,OAAX,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEE,WAAW,CAAEC,QAAF,EAAY;IACrB,QADqB,CAErB;IACA;;IACA,KAAKA,QAAL,GAAgB1B,cAAc,CAAC0B,QAAD,CAA9B;IAEA;;IACA,KAAKF,MAAL,GAAc,KAAKE,QAAL,CAAcF,MAA5B;IACA,KAAKG,SAAL,GAAiB,KAAKD,QAAL,CAAcC,SAA/B,CARqB,CAUrB;;IACA,IAAI,KAAKD,QAAL,CAAcE,OAAd,CAAsBC,OAA1B,EAAmC;MACjC,MAAMD,OAAO,GAAG,IAAIlB,OAAJ,CAAY,EAC1B,GAAG,KAAKgB,QAAL,CAAcE;MADS,CAAZ,CAAhB;MAIA,KAAKA,OAAL,GAAeA,OAAf;IACD;IAED;;;IACA,KAAKE,eAAL,GAAuB;MACrBC,YAAY,EAAE,YAAYC,OAAO,CAACC,OAAR,CAAgB,KAAhB,CADL;MAErBC,iBAAiB,EAAE,YAAYF,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAFV;MAGrBE,qBAAqB,EAAE,YAAYH,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAHd;MAIrBG,sBAAsB,EAAE,YAAYJ,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAJf;MAKrBI,8BAA8B,EAAE,YAAYL,OAAO,CAACC,OAAR,CAAgB,KAAhB,CALvB;MAMrBK,+BAA+B,EAAE,YAAYN,OAAO,CAACC,OAAR,CAAgB,KAAhB,CANxB;MAOrBM,6BAA6B,EAAE,YAAYP,OAAO,CAACC,OAAR,CAAgB,KAAhB,CAPtB;MAQrBO,8BAA8B,EAAE,YAAYR,OAAO,CAACC,OAAR,CAAgB,KAAhB,CARvB;MASrBQ,sBAAsB,EAAE,YAAYT,OAAO,CAACC,OAAR,CAAgB,IAAhB,CATf;MAUrB,GAAG,KAAKP,QAAL,CAAcI;IAVI,CAAvB;IAaA;;IACA,KAAKY,SAAL,GAAiB,IAAI7B,SAAJ,CAAc;MAC7BW,MAAM,EAAE,KAAKA,MADgB;MAE7BG,SAAS,EAAG,KAAKA,SAAL,IAAkB,KAAKD,QAAL,CAAcgB,SAAd,CAAwBC,WAA3C,GAA0D,KAAKhB,SAA/D,GAA2E,IAAIhC,eAAJ,EAFzD;MAG7BiD,aAAa,EAAE,KAAKd,eAAL,CAAqBW;IAHP,CAAd,CAAjB,CAlCqB,CAwCrB;;IACA,KAAKI,SAAL,GAAiB,KAAKnB,QAAL,CAAcmB,SAA/B;IACA,KAAKC,cAAL,GAAsB,IAAI3C,cAAJ,CAAmB,KAAKqB,MAAxB,EAAgC,KAAKE,QAAL,CAAcmB,SAA9C,CAAtB,CA1CqB,CA4CrB;;IACA,KAAKC,cAAL,CAAoBC,EAApB,CAAuB,kBAAvB,EAA2C,MAAM;MAC/C3B,oBAAoB,CAAC,IAAD,CAApB,CAA2B4B,KAA3B,CAAiCC,GAAG,IAAI;QACtC9D,GAAG,CAACG,KAAJ,CAAU,iCAAV,EAA6C2D,GAA7C;MACD,CAFD;IAGD,CAJD;IAMA,KAAKC,QAAL,GAAgB,KAAKxB,QAAL,CAAcyB,OAA9B;IACA,KAAKC,OAAL,GAAe,KAAK1B,QAAL,CAAc2B,MAA7B;IACA,KAAKC,UAAL,GAAkB,EAAlB,CArDqB,CAqDA;;IACrB,KAAKC,UAAL,GAAkB,IAAIC,GAAJ,EAAlB,CAtDqB,CAsDO;IAE5B;;IACA,KAAKC,iBAAL,GAAyB,IAAIrD,iBAAJ,CAAsB,IAAtB,EAA4B,EACnD,GAAG,KAAKsB,QAAL,CAAc+B;IADkC,CAA5B,CAAzB;IAGA,KAAKC,YAAL,GAAoB,IAAIrD,WAAJ,CAAgB,IAAhB,EAAsB;MACxCwB,OAAO,EAAE,KAAKuB,OAAL,CAAaO,aAAb,CAA2BC,QADI;MAExCC,cAAc,EAAE,KAAKnC,QAAL,CAAc+B,iBAAd,CAAgCI,cAFR;MAGxCC,gBAAgB,EAAE,KAAKpC,QAAL,CAAc+B,iBAAd,CAAgCK;IAHV,CAAtB,CAApB,CA5DqB,CAkErB;;IACA,IAAI,KAAKpC,QAAL,CAAcqC,QAAd,IAA0B,KAAKrC,QAAL,CAAcqC,QAAd,CAAuBpC,SAArD,EAAgE;MAC9DxC,GAAG,CAAC,mBAAD,CAAH;MAEA,MAAM6E,YAAY,GAAGvD,QAAQ,CAACwD,eAAT,EAArB;MAEA,KAAKF,QAAL,GAAgB,IAAItD,QAAJ,CAAa,KAAKiB,QAAL,CAAcqC,QAAd,CAAuBpC,SAApC,EAA+C,EAC7D,GAAGqC,YAD0D;QAE7D,GAAG,KAAKtC,QAAL,CAAcqC;MAF4C,CAA/C,CAAhB;MAKA5E,GAAG,CAAC,sBAAD,CAAH;IACD,CA9EoB,CAgFrB;;;IACA,KAAK+E,QAAL,GAAgB,IAAItD,QAAJ,CAAa;MAC3BkB,eAAe,EAAE,KAAKA,eADK;MAE3BqC,SAAS,EAAE,KAAK3C,MAFW;MAG3BI,OAAO,EAAE,KAAKA,OAHa;MAI3BwC,YAAY,EAAGC,UAAD,IAAgB,KAAKZ,iBAAL,CAAuBa,SAAvB,CAAiCD,UAAjC,CAJH;MAK3BE,eAAe,EAAGF,UAAD,IAAgB,KAAKZ,iBAAL,CAAuBe,YAAvB,CAAoCH,UAApC;IALN,CAAb,CAAhB,CAjFqB,CAyFrB;;IACA,KAAKI,gBAAL,GAAwB,IAAI9D,gBAAJ,CAAqB;MAC3C+D,MAAM,EAAE,IADmC;MAE3CR,QAAQ,EAAE,KAAKA,QAF4B;MAG3CS,cAAc,EAAE,KAAKjD,QAAL,CAAc+C,gBAAd,CAA+BE;IAHJ,CAArB,CAAxB,CA1FqB,CAgGrB;;IACA,KAAKC,UAAL,GAAkB,IAAIzD,UAAJ,CAAe;MAC/BK,MAAM,EAAE,KAAKA,MADkB;MAE/BsB,cAAc,EAAE,KAAKA,cAFU;MAG/B2B,gBAAgB,EAAE,KAAKA,gBAHQ;MAI/B;MACA,GAAG,KAAK/C,QAAL,CAAc2B,MAAd,CAAqBwB;IALO,CAAf,CAAlB,CAjGqB,CAyGrB;;IACA,KAAKC,SAAL,GAAiB,IAAI/D,SAAJ,CAAc;MAC7B2B,SAAS,EAAE,KAAKA,SADa;MAE7Be,iBAAiB,EAAE,KAAKA;IAFK,CAAd,CAAjB;IAKA,KAAKsB,MAAL,GAAc,KAAKA,MAAL,CAAYC,IAAZ,CAAiB,IAAjB,CAAd;IACA,KAAKF,SAAL,CAAeC,MAAf,GAAwB,KAAKA,MAA7B,CAhHqB,CAkHrB;;IACA,IAAI,CAAC,KAAK7B,QAAL,CAAc+B,cAAf,IAAiC,CAAC,KAAK/B,QAAL,CAAc+B,cAAd,CAA6BC,MAAnE,EAA2E;MACzE,MAAM1F,OAAO,CAAC,IAAI2F,KAAJ,CAAUjF,QAAQ,CAACkF,wBAAnB,CAAD,EAA+CnF,KAAK,CAACmF,wBAArD,CAAb;IACD;;IACD,MAAMC,OAAO,GAAG,KAAKnC,QAAL,CAAc+B,cAA9B;IACAI,OAAO,CAACC,OAAR,CAAiBC,MAAD,IAAY;MAC1B,KAAKrB,QAAL,CAAcmB,OAAd,CAAsBG,GAAtB,CAA0BD,MAAM,CAACE,QAAjC,EAA2CF,MAA3C;IACD,CAFD;IAIA,KAAKG,MAAL,GAAc,IAAIlF,MAAJ,CAAW;MACvBiE,gBAAgB,EAAE,KAAKA,gBADA;MAEvB3C,eAAe,EAAE,KAAKA,eAFC;MAGvBY,SAAS,EAAE,KAAKA,SAHO;MAIvBd,OAAO,EAAE,KAAKA,OAJS;MAKvB,GAAG,KAAKF,QAAL,CAAcgE;IALM,CAAX,CAAd;;IAQA,KAAKxC,QAAL,CAAcyC,SAAd,CAAwBL,OAAxB,CAAiCM,SAAD,IAAe;MAC7C,MAAMC,GAAG,GAAGD,SAAS,CAACE,SAAV,CAAoBC,MAAM,CAACC,WAA3B,CAAZ;MACA,MAAMC,gBAAgB,GAAG,KAAK7C,OAAL,CAAauC,SAAb,CAAuBE,GAAvB,CAAzB;MACA,KAAKpB,gBAAL,CAAsByB,GAAtB,CAA0BL,GAA1B,EAA+BD,SAA/B,EAA0CK,gBAA1C;IACD,CAJD;;IAMA,IAAI,KAAK7C,OAAL,CAAa+C,KAAb,CAAmBtE,OAAvB,EAAgC;MAC9B;MACA,KAAK4C,gBAAL,CAAsByB,GAAtB,CAA0B5F,OAAO,CAACwF,SAAR,CAAkBC,MAAM,CAACC,WAAzB,CAA1B,EAAiE1F,OAAjE;MACA,KAAK6F,KAAL,GAAa,IAAI5F,KAAJ,CAAU,IAAV,CAAb;IACD,CA7IoB,CA+IrB;;;IACA,IAAI,KAAK2C,QAAL,CAAckD,WAAlB,EAA+B;MAC7B,MAAMC,MAAM,GAAG,KAAKnD,QAAL,CAAckD,WAA7B;MACAC,MAAM,CAACf,OAAP,CAAgBgB,KAAD,IAAW;QACxB,KAAKpC,QAAL,CAAcmC,MAAd,CAAqBb,GAArB,CAAyBc,KAAK,CAACC,UAA/B,EAA2CD,KAA3C;MACD,CAFD,EAF6B,CAM7B;;MACA,KAAKE,eAAL,GAAuB,IAAIxF,eAAJ,CAAoB;QAAE0D,MAAM,EAAE;MAAV,CAApB,CAAvB;IACD,CAxJoB,CA0JrB;;;IACA,IAAI,KAAKxB,QAAL,CAAcuD,aAAlB,EAAiC;MAC/B,KAAKvC,QAAL,CAAcwC,SAAd,GAA0B,KAAKxD,QAAL,CAAcuD,aAAxC;IACD,CAFD,MAEO,IAAIE,UAAU,CAACC,OAAX,KAAuBC,SAAvB,IAAoCF,UAAU,CAACC,OAAX,CAAmBE,GAAvD,IAA8DH,UAAU,CAACC,OAAX,CAAmBE,GAAnB,CAAuBC,iBAAzF,EAA4G;MAAE;MACnH,MAAM,IAAI5B,KAAJ,CAAU,4DAAV,CAAN;IACD,CA/JoB,CAiKrB;;;IACA,IAAI,KAAKjC,QAAL,CAAc8D,GAAlB,EAAuB;MACrB,MAAMC,GAAG,GAAG,KAAK/D,QAAL,CAAc8D,GAA1B,CADqB,CAErB;;MACA,KAAKE,IAAL,GAAYD,GAAG,CAAC3F,MAAJ,CAAW;QACrBoD,MAAM,EAAE,IADa;QAErB,GAAG,KAAKtB,OAAL,CAAa4D;MAFK,CAAX,CAAZ;IAID,CAzKoB,CA2KrB;;;IACA,IAAI,KAAK9D,QAAL,CAAciE,MAAlB,EAA0B;MACxB,MAAMC,MAAM,GAAG,KAAKlE,QAAL,CAAciE,MAA7B,CADwB,CAExB;;MACA;;MACA,KAAKA,MAAL,GAAcrG,aAAa,CAACsG,MAAD,EAAS,IAAT,EAAe,KAAKhE,OAAL,CAAa+D,MAA5B,CAA3B;IACD,CAjLoB,CAmLrB;IACA;;;IACA,KAAKE,WAAL,GAAmB,IAAIzH,WAAJ,CAAgB,IAAhB,CAAnB;IACA,KAAK0H,cAAL,GAAsB,IAAIzH,cAAJ,CAAmB,IAAnB,CAAtB;IAEA,KAAK0H,gBAAL,GAAwB,KAAKA,gBAAL,CAAsBvC,IAAtB,CAA2B,IAA3B,CAAxB;IAEA,KAAKwC,YAAL,GAAoB,IAAIvG,YAAJ,CAAiB,IAAjB,CAApB;IACA,KAAKwG,WAAL,GAAmB,IAAIvG,WAAJ,CAAgB,IAAhB,CAAnB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEwG,IAAI,CAAEC,SAAF,EAAsB;IAAA,kCAANC,IAAM;MAANA,IAAM;IAAA;;IACxB;IACA;IACA,IAAID,SAAS,KAAK,OAAd,IAAyB,CAAC,KAAKE,OAAL,CAAavI,KAA3C,EAAkD;MAChDH,GAAG,CAACG,KAAJ,CAAUsI,IAAV;MACA,OAAO,KAAP;IACD,CAHD,MAGO;MACL,OAAO,MAAMF,IAAN,CAAWC,SAAX,EAAsB,GAAGC,IAAzB,CAAP;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACa,MAALE,KAAK,GAAI;IACb3I,GAAG,CAAC,oBAAD,CAAH;;IAEA,IAAI,KAAKqH,eAAT,EAA0B;MACxB,MAAM,KAAKzB,MAAL,CAAY3F,MAAM,CAAC2I,MAAP,CAAc/G,eAAe,CAACgH,cAAhB,CAA+B,IAA/B,CAAd,CAAZ,EAAiE,KAAKxB,eAAL,CAAqByB,aAAtF,CAAN;IACD;;IAED,IAAI,KAAKT,YAAT,EAAuB;MACrB,MAAM,KAAKzC,MAAL,CAAY9D,YAAY,CAACiH,QAAzB,EAAmC,KAAKV,YAAL,CAAkBS,aAArD,CAAN;IACD;;IAED,IAAI,KAAKR,WAAT,EAAsB;MACpB,MAAM,KAAK1C,MAAL,CAAY7D,WAAW,CAAC8G,cAAZ,CAA2B,IAA3B,CAAZ,EAA8C,KAAKP,WAAL,CAAiBQ,aAA/D,CAAN;IACD;;IAED,IAAI;MACF,MAAM,KAAKE,WAAL,EAAN;MACA,MAAM,KAAKC,WAAL,EAAN;MACAjJ,GAAG,CAAC,oBAAD,CAAH;IACD,CAJD,CAIE;IAAO;IAAmB8D,GAA1B,EAA+B;MAC/B,KAAKyE,IAAL,CAAU,OAAV,EAAmBzE,GAAnB;MACA9D,GAAG,CAACG,KAAJ,CAAU,mCAAV,EAA+C2D,GAA/C;MACA,MAAM,KAAKoF,IAAL,EAAN;MACA,MAAMpF,GAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EACY,MAAJoF,IAAI,GAAI;IACZlJ,GAAG,CAAC,oBAAD,CAAH;;IAEA,IAAI;MACF,KAAKmJ,UAAL,GAAkB,KAAlB;;MAEA,IAAI,KAAK9B,eAAT,EAA0B;QACxB,MAAM,KAAKA,eAAL,CAAqB6B,IAArB,EAAN;MACD;;MAED,KAAKlC,KAAL,IAAc,KAAKA,KAAL,CAAWkC,IAAX,EAAd;MACA,KAAKhB,WAAL,CAAiBgB,IAAjB;MACA,MAAM,KAAK3E,YAAL,CAAkB2E,IAAlB,EAAN;MACA,OAAO,KAAKnB,IAAL,IAAa,KAAKA,IAAL,CAAUmB,IAAV,EAApB;;MAEA,KAAK,MAAME,OAAX,IAAsB,KAAKhF,UAAL,CAAgBwE,MAAhB,EAAtB,EAAgD;QAC9CQ,OAAO,CAACC,cAAR,CAAuB,MAAvB,EAA+B,KAAKjB,gBAApC;MACD;;MAED,MAAMvF,OAAO,CAACyG,GAAR,CAAYC,KAAK,CAACC,IAAN,CAAW,KAAKpF,UAAL,CAAgBwE,MAAhB,EAAX,EAAqCa,CAAC,IAAIA,CAAC,CAACP,IAAF,EAA1C,CAAZ,CAAN;MAEA,KAAK9E,UAAL,GAAkB,IAAIC,GAAJ,EAAlB;MAEA,MAAM,KAAKC,iBAAL,CAAuB4E,IAAvB,EAAN;MAEA,MAAMrG,OAAO,CAACyG,GAAR,CAAY,CAChB,KAAKtB,MAAL,IAAe,KAAKA,MAAL,CAAYkB,IAAZ,EADC,EAEhB,KAAKzG,OAAL,IAAgB,KAAKA,OAAL,CAAayG,IAAb,EAFA,CAAZ,CAAN;MAKA,MAAM,KAAKzD,UAAL,CAAgByD,IAAhB,EAAN;MACA,MAAM,KAAK5D,gBAAL,CAAsBoE,KAAtB,EAAN;MAEA,MAAM,KAAKC,QAAL,CAAc7H,YAAY,CAACiH,QAA3B,CAAN;MACA,MAAM,KAAKY,QAAL,CAAc5H,WAAW,CAAC8G,cAAZ,CAA2B,IAA3B,CAAd,CAAN;MAEA,KAAKtC,MAAL,CAAYqD,OAAZ;IACD,CAlCD,CAkCE;IAAO;IAAmB9F,GAA1B,EAA+B;MAC/B,IAAIA,GAAJ,EAAS;QACP9D,GAAG,CAACG,KAAJ,CAAU2D,GAAV;QACA,KAAKyE,IAAL,CAAU,OAAV,EAAmBzE,GAAnB;MACD;IACF;;IACD9D,GAAG,CAAC,oBAAD,CAAH;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACoB,MAAZ6J,YAAY,GAAI;IACpB,IAAI,CAAC,KAAKjF,QAAV,EAAoB;MAClB;IACD;;IAED,IAAI;MACF,MAAM,KAAKA,QAAL,CAAckF,aAAd,CAA4B,MAA5B,CAAN;IACD,CAFD,CAEE;IAAO;IAAmBhG,GAA1B,EAA+B;MAC/B,MAAM,KAAKc,QAAL,CAAcmF,UAAd,CAAyB,MAAzB,EAAiC,KAAK1H,MAAtC,CAAN;IACD;EACF;;EAED2H,SAAS,GAAI;IACX,OAAO,KAAKb,UAAZ;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACiB,IAAXc,WAAW,GAAI;IACjB,OAAO,KAAK3F,iBAAL,CAAuB2F,WAA9B;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACEC,IAAI,CAAEC,IAAF,EAAQ/H,OAAR,EAAiB;IACnB,OAAO,KAAKgI,KAAL,CAAWD,IAAX,EAAiB/H,OAAjB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACoB,MAAZiI,YAAY,CAAEF,IAAF,EAAQG,SAAR,EAAmBlI,OAAnB,EAA4B;IAC5C,IAAI,CAACkI,SAAD,IAAc,CAACA,SAAS,CAACvE,MAA7B,EAAqC;MACnC,MAAM1F,OAAO,CAAC,IAAI2F,KAAJ,CAAU,6CAAV,CAAD,EAA2DlF,KAAK,CAACyJ,gCAAjE,CAAb;IACD;;IAED,MAAMrF,UAAU,GAAG,MAAM,KAAKkF,KAAL,CAAWD,IAAX,EAAiB/H,OAAjB,CAAzB;IACA,OAAO8C,UAAU,CAACsF,SAAX,CAAqBF,SAArB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACa,MAALF,KAAK,CAAED,IAAF,EAAQ/H,OAAR,EAAiB;IAC1B,MAAM;MAAEqI,EAAF;MAAMC;IAAN,IAAqB/J,OAAO,CAACwJ,IAAD,CAAlC;;IAEA,IAAIM,EAAE,CAACE,MAAH,CAAU,KAAKtI,MAAf,CAAJ,EAA4B;MAC1B,MAAMhC,OAAO,CAAC,IAAI2F,KAAJ,CAAU,kBAAV,CAAD,EAAgClF,KAAK,CAAC8J,eAAtC,CAAb;IACD;;IAED,IAAI1F,UAAU,GAAG,KAAKZ,iBAAL,CAAuBuG,GAAvB,CAA2BJ,EAA3B,CAAjB;;IAEA,IAAI,CAACvF,UAAL,EAAiB;MACfA,UAAU,GAAG,MAAM,KAAKqB,MAAL,CAAYuE,aAAZ,CAA0BX,IAA1B,EAAgC/H,OAAhC,CAAnB;IACD,CAFD,MAEO,IAAIsI,UAAJ,EAAgB;MACrB,MAAM,KAAKnH,SAAL,CAAewH,WAAf,CAA2BhE,GAA3B,CAA+B0D,EAA/B,EAAmCC,UAAnC,CAAN;IACD;;IAED,OAAOxF,UAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACgB,IAAVwF,UAAU,GAAI;IAChB,IAAIM,KAAK,GAAG,KAAKrH,cAAL,CAAoBsH,gBAApB,GAAuCC,GAAvC,CAA2CC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAjD,CAAZ;;IAEA,IAAI,CAACJ,KAAK,CAACjF,MAAX,EAAmB;MACjB;MACAiF,KAAK,GAAG,KAAK1F,gBAAL,CAAsB+F,QAAtB,GAAiCH,GAAjC,CAAqCC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAA3C,CAAR;IACD;;IAEDJ,KAAK,GAAGA,KAAK,CAACM,MAAN,CAAa,KAAK3H,cAAL,CAAoB4H,gBAApB,GAAuCL,GAAvC,CAA2CC,EAAE,IAAIA,EAAE,CAACC,QAAH,EAAjD,CAAb,CAAR;IAEA,MAAMI,cAAc,GAAG,KAAKjJ,QAAL,CAAcmB,SAAd,CAAwB8H,cAA/C,CAVgB,CAYhB;;IACA,MAAMC,OAAO,GAAG,IAAIC,GAAJ,CAAQV,KAAR,CAAhB,CAbgB,CAehB;;IACA,OAAOQ,cAAc,CAACjC,KAAK,CAACC,IAAN,CAAWiC,OAAX,EAAoBP,GAApB,CAAwBS,GAAG,IAAI,IAAIpL,SAAJ,CAAcoL,GAAd,CAA/B,CAAD,CAArB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACc,MAANC,MAAM,CAAEzB,IAAF,EAAQ;IAClB,MAAM;MAAEM;IAAF,IAAS9J,OAAO,CAACwJ,IAAD,CAAtB;IAEA,MAAMF,WAAW,GAAG,KAAK3F,iBAAL,CAAuB2F,WAAvB,CAAmCY,GAAnC,CAAuCJ,EAAE,CAACoB,WAAH,EAAvC,CAApB;;IAEA,IAAI,CAAC5B,WAAL,EAAkB;MAChB;IACD;;IAED,MAAMpH,OAAO,CAACyG,GAAR,CACJW,WAAW,CAACiB,GAAZ,CAAgBhG,UAAU,IAAI;MAC5B,OAAOA,UAAU,CAACwE,KAAX,EAAP;IACD,CAFD,CADI,CAAN;EAKD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEoC,KAAK,CAAE3B,IAAF,EAAQzD,GAAR,EAAa;IAChB,OAAO,KAAK2B,YAAL,CAAkByD,KAAlB,CAAwB3B,IAAxB,EAA8BzD,GAA9B,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACEqF,IAAI,CAAE5B,IAAF,EAAQ;IACV,MAAM;MAAEM,EAAF;MAAMC;IAAN,IAAqB/J,OAAO,CAACwJ,IAAD,CAAlC,CADU,CAGV;;IACA,IAAIO,UAAJ,EAAgB;MACd,OAAO,KAAKpC,WAAL,CAAiByD,IAAjB,CAAsBrB,UAAU,CAAC,CAAD,CAAhC,CAAP;IACD;;IAED,OAAO,KAAKpC,WAAL,CAAiByD,IAAjB,CAAsBtB,EAAtB,CAAP;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACc,MAAN7E,MAAM,CAAE0E,SAAF,EAAa0B,OAAb,EAAsB;IAChC1B,SAAS,GAAGf,KAAK,CAAC0C,OAAN,CAAc3B,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;IACAA,SAAS,CAACnE,OAAV,CAAkBG,QAAQ,IAAI;MAC5B,KAAKvB,QAAL,CAAcuF,SAAd,CAAwBjE,GAAxB,CAA4BC,QAA5B,EAAsC0F,OAAtC;IACD,CAFD,EAFgC,CAMhC;;IACA,MAAM,KAAKzI,SAAL,CAAe2I,SAAf,CAAyBnF,GAAzB,CAA6B,KAAK1E,MAAlC,EAA0CiI,SAA1C,CAAN;EACD;EAED;AACF;AACA;AACA;AACA;AACA;;;EACgB,MAARX,QAAQ,CAAEW,SAAF,EAAa;IACzBA,SAAS,GAAGf,KAAK,CAAC0C,OAAN,CAAc3B,SAAd,IAA2BA,SAA3B,GAAuC,CAACA,SAAD,CAAnD;IACAA,SAAS,CAACnE,OAAV,CAAkBG,QAAQ,IAAI;MAC5B,KAAKvB,QAAL,CAAcuF,SAAd,CAAwB6B,MAAxB,CAA+B7F,QAA/B;IACD,CAFD,EAFyB,CAMzB;;IACA,MAAM,KAAK/C,SAAL,CAAe2I,SAAf,CAAyBE,MAAzB,CAAgC,KAAK/J,MAArC,EAA6CiI,SAA7C,CAAN;EACD;;EAEgB,MAAXtB,WAAW,GAAI;IACnB;IACA,MAAMgC,KAAK,GAAG,KAAKrH,cAAL,CAAoB0I,cAApB,EAAd;IACA,MAAM,KAAK/G,gBAAL,CAAsBgH,MAAtB,CAA6BtB,KAA7B,CAAN,CAHmB,CAKnB;;IACA,KAAKvF,UAAL,CAAgBkD,KAAhB;;IAEA,IAAI,KAAK1E,OAAL,CAAa+D,MAAb,CAAoBtF,OAAxB,EAAiC;MAC/B,KAAKsF,MAAL,KAAe,MAAM,KAAKA,MAAL,CAAYW,KAAZ,EAArB;IACD,CAVkB,CAYnB;;;IACA,IAAI,KAAK1E,OAAL,CAAa4D,GAAb,CAAiBnF,OAArB,EAA8B;MAC5B,KAAKqF,IAAL,KAAa,MAAM,KAAKA,IAAL,CAAUY,KAAV,EAAnB,EAD4B,CAG5B;MACA;;MACA,KAAKZ,IAAL,CAAUnE,EAAV,CAAa,MAAb,EAAqB,KAAKwE,gBAA1B;IACD,CAnBkB,CAqBnB;;;IACA,KAAK3F,OAAL,IAAgB,KAAKA,OAAL,CAAakG,KAAb,EAAhB;;IAEA,IAAI,KAAKtB,eAAT,EAA0B;MACxB,MAAM,KAAKA,eAAL,CAAqBsB,KAArB,EAAN;IACD;EACF;EAED;AACF;AACA;AACA;AACA;;;EACmB,MAAXM,WAAW,GAAI;IACnB,KAAKE,UAAL,GAAkB,IAAlB;IAEA,KAAK5F,SAAL,CAAeK,EAAf,CAAkB,MAAlB,EAA0BvB,MAAM,IAAI;MAClC,KAAKkG,IAAL,CAAU,gBAAV,EAA4BlG,MAA5B;;MACA,KAAKkK,aAAL,CAAmBlK,MAAnB,EAA2BwB,KAA3B,CAAiCC,GAAG,IAAI;QACtC9D,GAAG,CAACG,KAAJ,CAAU2D,GAAV;MACD,CAFD;IAGD,CALD,EAHmB,CAUnB;IACA;;IACA,WAAW,MAAMqG,IAAjB,IAAyB,KAAK5G,SAAL,CAAeiJ,QAAf,EAAzB,EAAoD;MAClD,KAAKjE,IAAL,CAAU,gBAAV,EAA4B4B,IAAI,CAACM,EAAjC;IACD;;IAED,KAAKnG,iBAAL,CAAuBqE,KAAvB;IACA,MAAM,KAAKpE,YAAL,CAAkBoE,KAAlB,EAAN,CAjBmB,CAmBnB;;IACA,MAAM,KAAK8D,mBAAL,EAAN,CApBmB,CAsBnB;;IACA,KAAKzF,KAAL,IAAc,KAAKA,KAAL,CAAW2B,KAAX,EAAd;IAEA,KAAKT,WAAL,CAAiBS,KAAjB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEP,gBAAgB,CAAE+B,IAAF,EAAQ;IACtB,IAAIA,IAAI,CAACM,EAAL,CAAQoB,WAAR,OAA0B,KAAKxJ,MAAL,CAAYwJ,WAAZ,EAA9B,EAAyD;MACvD7L,GAAG,CAACG,KAAJ,CAAU,IAAI6F,KAAJ,CAAUlF,KAAK,CAAC4L,mBAAhB,CAAV;MACA;IACD;;IAEDvC,IAAI,CAACO,UAAL,IAAmB,KAAKnH,SAAL,CAAewH,WAAf,CAA2BhE,GAA3B,CAA+BoD,IAAI,CAACM,EAApC,EAAwCN,IAAI,CAACO,UAA7C,EAAyD7G,KAAzD,CAA+DC,GAAG,IAAI9D,GAAG,CAACG,KAAJ,CAAU2D,GAAV,CAAtE,CAAnB;IACAqG,IAAI,CAACG,SAAL,IAAkB,KAAK/G,SAAL,CAAe2I,SAAf,CAAyB7F,GAAzB,CAA6B8D,IAAI,CAACM,EAAlC,EAAsCN,IAAI,CAACG,SAA3C,EAAsDzG,KAAtD,CAA4DC,GAAG,IAAI9D,GAAG,CAACG,KAAJ,CAAU2D,GAAV,CAAnE,CAAlB;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;EACqB,MAAbyI,aAAa,CAAElK,MAAF,EAAU;IAC3B;IACA,IAAI,KAAK4B,OAAL,CAAaO,aAAb,CAA2BC,QAA3B,KAAwC,IAAxC,IAAgD,CAAC,KAAKH,iBAAL,CAAuBuG,GAAvB,CAA2BxI,MAA3B,CAArD,EAAyF;MACvF,MAAMqC,cAAc,GAAG,KAAKnC,QAAL,CAAc+B,iBAAd,CAAgCI,cAAhC,IAAkD,CAAzE;;MACA,IAAIA,cAAc,GAAG,KAAKJ,iBAAL,CAAuBqI,IAA5C,EAAkD;QAChD3M,GAAG,CAAC,kCAAD,EAAqCqC,MAAM,CAACwJ,WAAP,EAArC,CAAH;;QACA,IAAI;UACF,MAAM,KAAKtF,MAAL,CAAYuE,aAAZ,CAA0BzI,MAA1B,CAAN;QACD,CAFD,CAEE;QAAO;QAAmByB,GAA1B,EAA+B;UAC/B9D,GAAG,CAACG,KAAJ,CAAW,wCAAuCkC,MAAM,CAACwJ,WAAP,EAAqB,SAAQ/H,GAAI,EAAnF;QACD;MACF;IACF;EACF;EAED;AACF;AACA;AACA;AACA;AACA;;;EAC2B,MAAnB2I,mBAAmB,GAAI;IAC3B;AACJ;AACA;IACI,MAAMG,YAAY,GAAIC,gBAAD,IAAsB;MACzC,IAAI3I,MAAM,GAAG;QACXxB,OAAO,EAAE,IADE,CACG;;MADH,CAAb;;MAIA,IAAImK,gBAAgB,CAACC,GAAjB,IACF,KAAK7I,OAAL,CAAaO,aADX,IAEF,KAAKP,OAAL,CAAaO,aAAb,CAA2BqI,gBAAgB,CAACC,GAA5C,CAFF,EAEoD;QAClD;QACA5I,MAAM,GAAG,EAAE,GAAGA,MAAL;UAAa,GAAG,KAAKD,OAAL,CAAaO,aAAb,CAA2BqI,gBAAgB,CAACC,GAA5C;QAAhB,CAAT;MACD;;MAED,IAAI5I,MAAM,CAACxB,OAAP,IACF,CAAC,KAAK0B,UAAL,CAAgB2I,GAAhB,CAAoBF,gBAAgB,CAACC,GAArC,CADH,EAC8C;QAAE;QAC9C,IAAIE,gBAAJ;;QAEA,IAAI,OAAOH,gBAAP,KAA4B,UAAhC,EAA4C;UAC1C;UACAG,gBAAgB,GAAG,IAAIH,gBAAJ,CAAqB5M,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBgE,MAAlB,EAA0B;YAChE7B,MAAM,EAAE,KAAKA,MADmD;YAEhEkD,MAAM,EAAE;UAFwD,CAA1B,CAArB,CAAnB;QAID,CAND,MAMO;UACLyH,gBAAgB,GAAGH,gBAAnB;QACD;;QAEDG,gBAAgB,CAACpJ,EAAjB,CAAoB,MAApB,EAA4B,KAAKwE,gBAAjC;;QACA,KAAKhE,UAAL,CAAgBiC,GAAhB,CAAoBwG,gBAAgB,CAACC,GAArC,EAA0CE,gBAA1C;MACD;IACF,CA7BD,CAJ2B,CAmC3B;;;IACA,KAAK,MAAMH,gBAAX,IAA+B,KAAK9I,QAAL,CAAcS,aAAd,IAA+B,EAA9D,EAAkE;MAChEoI,YAAY,CAACC,gBAAD,CAAZ;IACD,CAtC0B,CAwC3B;;;IACA,KAAK,MAAMpG,SAAX,IAAwB,KAAKnB,gBAAL,CAAsB2H,aAAtB,EAAxB,EAA+D;MAC7D;MACA,IAAIxG,SAAS,CAACyG,SAAd,EAAyB;QACvB;QACAN,YAAY,CAACnG,SAAS,CAACyG,SAAX,CAAZ;MACD;IACF;;IAED,MAAMrK,OAAO,CAACyG,GAAR,CAAYC,KAAK,CAACC,IAAN,CAAW,KAAKpF,UAAL,CAAgBwE,MAAhB,EAAX,EAAqCuE,CAAC,IAAIA,CAAC,CAACxE,KAAF,EAA1C,CAAZ,CAAN;EACD;;AAvqB+B;;AA0qBlCyE,MAAM,CAACC,OAAP,GAAiBnL,MAAjB"},"metadata":{},"sourceType":"script"}