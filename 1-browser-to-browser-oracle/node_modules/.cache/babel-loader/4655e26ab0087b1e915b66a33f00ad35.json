{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callAvm = exports.deserializeAvmResult = exports.serializeAvmArgs = void 0;\nvar decoder = new TextDecoder();\nvar encoder = new TextEncoder();\n/**\n * Serializes AVM arguments in JSON string which can be passed into marine-js\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns AVM call arguments as serialized JSON string\n */\n\nfunction serializeAvmArgs(runParams, air, prevData, data, callResults) {\n  var callResultsToPass = {};\n\n  for (var _i = 0, callResults_1 = callResults; _i < callResults_1.length; _i++) {\n    var _a = callResults_1[_i],\n        key = _a[0],\n        callResult = _a[1];\n    callResultsToPass[key] = {\n      ret_code: callResult.retCode,\n      result: callResult.result\n    };\n  }\n\n  var encoded = encoder.encode(JSON.stringify(callResultsToPass));\n  var avmArg = JSON.stringify([// force new line\n  air, Array.from(prevData), Array.from(data), {\n    init_peer_id: runParams.initPeerId,\n    current_peer_id: runParams.currentPeerId,\n    timestamp: runParams.timestamp,\n    ttl: runParams.ttl\n  }, Array.from(encoded)]);\n  return avmArg;\n}\n\nexports.serializeAvmArgs = serializeAvmArgs;\n/**\n * Deserializes raw result of AVM call obtained from marine-js into structured form\n * @param rawResult - string containing raw result of AVM call\n * @returns structured InterpreterResult\n */\n\nfunction deserializeAvmResult(rawResult) {\n  var result;\n\n  try {\n    result = JSON.parse(rawResult);\n  } catch (ex) {\n    throw 'call_module result parsing error: ' + ex + ', original text: ' + rawResult;\n  }\n\n  if (result.error !== '') {\n    throw 'call_module returned error: ' + result.error;\n  }\n\n  result = result.result;\n  var callRequestsStr = decoder.decode(new Uint8Array(result.call_requests));\n  var parsedCallRequests;\n\n  try {\n    if (callRequestsStr.length === 0) {\n      parsedCallRequests = {};\n    } else {\n      parsedCallRequests = JSON.parse(callRequestsStr);\n    }\n  } catch (e) {\n    throw \"Couldn't parse call requests: \" + e + '. Original string is: ' + callRequestsStr;\n  }\n\n  var resultCallRequests = [];\n\n  for (var key in parsedCallRequests) {\n    var callRequest = parsedCallRequests[key];\n    var arguments_ = void 0;\n    var tetraplets = void 0;\n\n    try {\n      arguments_ = JSON.parse(callRequest.arguments);\n    } catch (e) {\n      throw \"Couldn't parse arguments: \" + e + '. Original string is: ' + arguments_;\n    }\n\n    try {\n      tetraplets = JSON.parse(callRequest.tetraplets);\n    } catch (e) {\n      throw \"Couldn't parse tetraplets: \" + e + '. Original string is: ' + tetraplets;\n    }\n\n    resultCallRequests.push([key, {\n      serviceId: callRequest.service_id,\n      functionName: callRequest.function_name,\n      arguments: arguments_,\n      tetraplets: tetraplets\n    }]);\n  }\n\n  return {\n    retCode: result.ret_code,\n    errorMessage: result.error_message,\n    data: result.data,\n    nextPeerPks: result.next_peer_pks,\n    callRequests: resultCallRequests\n  };\n}\n\nexports.deserializeAvmResult = deserializeAvmResult;\n/**\n * Utility function which serializes AVM args and passed them into AVM returning interpreter result.\n * Call to AVM is delegated to a function which must be provided by user.\n * It might be either synchronous or asynchronous (returning a promise)\n * @param fn - delegated call to AVM\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns structured InterpreterResult\n */\n\nfunction callAvm(fn, runParams, air, prevData, data, callResults) {\n  return __awaiter(this, void 0, void 0, function () {\n    var avmArg, rawResult, e_1;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          _a.trys.push([0, 2,, 3]);\n\n          avmArg = serializeAvmArgs(runParams, air, prevData, data, callResults);\n          return [4\n          /*yield*/\n          , fn(avmArg)];\n\n        case 1:\n          rawResult = _a.sent();\n          return [2\n          /*return*/\n          , deserializeAvmResult(rawResult)];\n\n        case 2:\n          e_1 = _a.sent();\n          return [2\n          /*return*/\n          , {\n            retCode: -1,\n            errorMessage: 'marine-js call failed, ' + e_1\n          }];\n\n        case 3:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  });\n}\n\nexports.callAvm = callAvm;","map":{"version":3,"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA,IAAMA,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AACA,IAAMC,OAAO,GAAG,IAAIC,WAAJ,EAAhB;AAEA;;;;;;;;;;;AAUA,SAAgBC,gBAAhB,CACIC,SADJ,EAEIC,GAFJ,EAGIC,QAHJ,EAIIC,IAJJ,EAKIC,WALJ,EAKiC;EAE7B,IAAMC,iBAAiB,GAAQ,EAA/B;;EACA,KAA8B,uCAA9B,EAA8BC,yBAA9B,EAA8BA,IAA9B,EAA2C;IAAlC;IAAA,IAACC,GAAG,QAAJ;IAAA,IAAMC,UAAU,QAAhB;IACLH,iBAAiB,CAACE,GAAD,CAAjB,GAAyB;MACrBE,QAAQ,EAAED,UAAU,CAACE,OADA;MAErBC,MAAM,EAAEH,UAAU,CAACG;IAFE,CAAzB;EAIH;;EAED,IAAMC,OAAO,GAAGf,OAAO,CAACgB,MAAR,CAAeC,IAAI,CAACC,SAAL,CAAeV,iBAAf,CAAf,CAAhB;EAEA,IAAMW,MAAM,GAAGF,IAAI,CAACC,SAAL,CAAe,CAC1B;EACAd,GAF0B,EAG1BgB,KAAK,CAACC,IAAN,CAAWhB,QAAX,CAH0B,EAI1Be,KAAK,CAACC,IAAN,CAAWf,IAAX,CAJ0B,EAK1B;IACIgB,YAAY,EAAEnB,SAAS,CAACoB,UAD5B;IAEIC,eAAe,EAAErB,SAAS,CAACsB,aAF/B;IAGIC,SAAS,EAAEvB,SAAS,CAACuB,SAHzB;IAIIC,GAAG,EAAExB,SAAS,CAACwB;EAJnB,CAL0B,EAW1BP,KAAK,CAACC,IAAN,CAAWN,OAAX,CAX0B,CAAf,CAAf;EAcA,OAAOI,MAAP;AACH;;AAhCDS;AAkCA;;;;;;AAKA,SAAgBC,oBAAhB,CAAqCC,SAArC,EAAsD;EAClD,IAAIhB,MAAJ;;EACA,IAAI;IACAA,MAAM,GAAGG,IAAI,CAACc,KAAL,CAAWD,SAAX,CAAT;EACH,CAFD,CAEE,OAAOE,EAAP,EAAW;IACT,MAAM,uCAAuCA,EAAvC,GAA4C,mBAA5C,GAAkEF,SAAxE;EACH;;EAED,IAAIhB,MAAM,CAACmB,KAAP,KAAiB,EAArB,EAAyB;IACrB,MAAM,iCAAiCnB,MAAM,CAACmB,KAA9C;EACH;;EAEDnB,MAAM,GAAGA,MAAM,CAACA,MAAhB;EAEA,IAAMoB,eAAe,GAAGpC,OAAO,CAACqC,MAAR,CAAe,IAAIC,UAAJ,CAAetB,MAAM,CAACuB,aAAtB,CAAf,CAAxB;EACA,IAAIC,kBAAJ;;EACA,IAAI;IACA,IAAIJ,eAAe,CAACK,MAAhB,KAA2B,CAA/B,EAAkC;MAC9BD,kBAAkB,GAAG,EAArB;IACH,CAFD,MAEO;MACHA,kBAAkB,GAAGrB,IAAI,CAACc,KAAL,CAAWG,eAAX,CAArB;IACH;EACJ,CAND,CAME,OAAOM,CAAP,EAAU;IACR,MAAM,mCAAmCA,CAAnC,GAAuC,wBAAvC,GAAkEN,eAAxE;EACH;;EAED,IAAIO,kBAAkB,GAAmD,EAAzE;;EACA,KAAK,IAAM/B,GAAX,IAAkB4B,kBAAlB,EAAsC;IAClC,IAAMI,WAAW,GAAGJ,kBAAkB,CAAC5B,GAAD,CAAtC;IAEA,IAAIiC,UAAU,SAAd;IACA,IAAIC,UAAU,SAAd;;IACA,IAAI;MACAD,UAAU,GAAG1B,IAAI,CAACc,KAAL,CAAWW,WAAW,CAACG,SAAvB,CAAb;IACH,CAFD,CAEE,OAAOL,CAAP,EAAU;MACR,MAAM,+BAA+BA,CAA/B,GAAmC,wBAAnC,GAA8DG,UAApE;IACH;;IAED,IAAI;MACAC,UAAU,GAAG3B,IAAI,CAACc,KAAL,CAAWW,WAAW,CAACE,UAAvB,CAAb;IACH,CAFD,CAEE,OAAOJ,CAAP,EAAU;MACR,MAAM,gCAAgCA,CAAhC,GAAoC,wBAApC,GAA+DI,UAArE;IACH;;IAEDH,kBAAkB,CAACK,IAAnB,CAAwB,CACpBpC,GADoB,EAEpB;MACIqC,SAAS,EAAEL,WAAW,CAACM,UAD3B;MAEIC,YAAY,EAAEP,WAAW,CAACQ,aAF9B;MAGIL,SAAS,EAAEF,UAHf;MAIIC,UAAU,EAAEA;IAJhB,CAFoB,CAAxB;EASH;;EACD,OAAO;IACH/B,OAAO,EAAEC,MAAM,CAACF,QADb;IAEHuC,YAAY,EAAErC,MAAM,CAACsC,aAFlB;IAGH9C,IAAI,EAAEQ,MAAM,CAACR,IAHV;IAIH+C,WAAW,EAAEvC,MAAM,CAACwC,aAJjB;IAKHC,YAAY,EAAEd;EALX,CAAP;AAOH;;AA7DDb;AAiEA;;;;;;;;;;;;;;AAaA,SAAsB4B,OAAtB,CACIC,EADJ,EAEItD,SAFJ,EAGIC,GAHJ,EAIIC,QAJJ,EAKIC,IALJ,EAMIC,WANJ,EAMiC;;;;;;;;UAGnBY,MAAM,GAAGjB,gBAAgB,CAACC,SAAD,EAAYC,GAAZ,EAAiBC,QAAjB,EAA2BC,IAA3B,EAAiCC,WAAjC,CAAzB;UACY;UAAA;UAAA,EAAMkD,EAAE,CAACtC,MAAD,CAAR;;;UAAZW,SAAS,GAAG4B,SAAZ;UACN;UAAA;UAAA,EAAO7B,oBAAoB,CAACC,SAAD,CAA3B;;;;UAEA;UAAA;UAAA,EAAO;YACHjB,OAAO,EAAE,CAAC,CADP;YAEHsC,YAAY,EAAE,4BAA4BQ;UAFvC,CAAP;;;;;;;;;AAKP;;AAlBD/B","names":["decoder","TextDecoder","encoder","TextEncoder","serializeAvmArgs","runParams","air","prevData","data","callResults","callResultsToPass","_i","key","callResult","ret_code","retCode","result","encoded","encode","JSON","stringify","avmArg","Array","from","init_peer_id","initPeerId","current_peer_id","currentPeerId","timestamp","ttl","exports","deserializeAvmResult","rawResult","parse","ex","error","callRequestsStr","decode","Uint8Array","call_requests","parsedCallRequests","length","e","resultCallRequests","callRequest","arguments_","tetraplets","arguments","push","serviceId","service_id","functionName","function_name","errorMessage","error_message","nextPeerPks","next_peer_pks","callRequests","callAvm","fn","_a","e_1"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/avm/src/avmHelpers.ts"],"sourcesContent":["/*\n * Copyright 2022 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { CallResultsArray, InterpreterResult, CallRequest, RunParameters } from './types';\n\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\n\n/**\n * Serializes AVM arguments in JSON string which can be passed into marine-js\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns AVM call arguments as serialized JSON string\n */\nexport function serializeAvmArgs(\n    runParams: RunParameters,\n    air: string,\n    prevData: Uint8Array,\n    data: Uint8Array,\n    callResults: CallResultsArray,\n): string {\n    const callResultsToPass: any = {};\n    for (let [key, callResult] of callResults) {\n        callResultsToPass[key] = {\n            ret_code: callResult.retCode,\n            result: callResult.result,\n        };\n    }\n\n    const encoded = encoder.encode(JSON.stringify(callResultsToPass));\n\n    const avmArg = JSON.stringify([\n        // force new line\n        air,\n        Array.from(prevData),\n        Array.from(data),\n        {\n            init_peer_id: runParams.initPeerId,\n            current_peer_id: runParams.currentPeerId,\n            timestamp: runParams.timestamp,\n            ttl: runParams.ttl,\n        },\n        Array.from(encoded),\n    ]);\n\n    return avmArg;\n}\n\n/**\n * Deserializes raw result of AVM call obtained from marine-js into structured form\n * @param rawResult - string containing raw result of AVM call\n * @returns structured InterpreterResult\n */\nexport function deserializeAvmResult(rawResult: string): InterpreterResult {\n    let result: any;\n    try {\n        result = JSON.parse(rawResult);\n    } catch (ex) {\n        throw 'call_module result parsing error: ' + ex + ', original text: ' + rawResult;\n    }\n\n    if (result.error !== '') {\n        throw 'call_module returned error: ' + result.error;\n    }\n\n    result = result.result;\n\n    const callRequestsStr = decoder.decode(new Uint8Array(result.call_requests));\n    let parsedCallRequests;\n    try {\n        if (callRequestsStr.length === 0) {\n            parsedCallRequests = {};\n        } else {\n            parsedCallRequests = JSON.parse(callRequestsStr);\n        }\n    } catch (e) {\n        throw \"Couldn't parse call requests: \" + e + '. Original string is: ' + callRequestsStr;\n    }\n\n    let resultCallRequests: Array<[key: number, callRequest: CallRequest]> = [];\n    for (const key in parsedCallRequests) {\n        const callRequest = parsedCallRequests[key];\n\n        let arguments_;\n        let tetraplets;\n        try {\n            arguments_ = JSON.parse(callRequest.arguments);\n        } catch (e) {\n            throw \"Couldn't parse arguments: \" + e + '. Original string is: ' + arguments_;\n        }\n\n        try {\n            tetraplets = JSON.parse(callRequest.tetraplets);\n        } catch (e) {\n            throw \"Couldn't parse tetraplets: \" + e + '. Original string is: ' + tetraplets;\n        }\n\n        resultCallRequests.push([\n            key as any,\n            {\n                serviceId: callRequest.service_id,\n                functionName: callRequest.function_name,\n                arguments: arguments_,\n                tetraplets: tetraplets,\n            },\n        ]);\n    }\n    return {\n        retCode: result.ret_code,\n        errorMessage: result.error_message,\n        data: result.data,\n        nextPeerPks: result.next_peer_pks,\n        callRequests: resultCallRequests,\n    };\n}\n\ntype CallToAvm = ((args: string) => Promise<string>) | ((args: string) => string);\n\n/**\n * Utility function which serializes AVM args and passed them into AVM returning interpreter result.\n * Call to AVM is delegated to a function which must be provided by user.\n * It might be either synchronous or asynchronous (returning a promise)\n * @param fn - delegated call to AVM\n * @param initPeerId - peer ID which initialized particle\n * @param currentPeerId - peer ID which is currently executing the particle\n * @param air - particle's air script as string\n * @param prevData - particle's prev data as raw byte array\n * @param data - particle's data as raw byte array\n * @param callResults - array of tuples [callResultKey, callResult]\n * @returns structured InterpreterResult\n */\nexport async function callAvm(\n    fn: CallToAvm,\n    runParams: RunParameters,\n    air: string,\n    prevData: Uint8Array,\n    data: Uint8Array,\n    callResults: CallResultsArray,\n): Promise<InterpreterResult> {\n    try {\n        const avmArg = serializeAvmArgs(runParams, air, prevData, data, callResults);\n        const rawResult = await fn(avmArg);\n        return deserializeAvmResult(rawResult);\n    } catch (e) {\n        return {\n            retCode: -1,\n            errorMessage: 'marine-js call failed, ' + e,\n        } as any;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}