{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  Key\n} = require('interface-datastore/key');\n\nconst {\n  base32\n} = require('multiformats/bases/base32');\n\nconst {\n  keys: {\n    unmarshalPublicKey,\n    marshalPublicKey\n  }\n} = require('libp2p-crypto');\n\nconst {\n  Multiaddr\n} = require('multiaddr');\n\nconst {\n  Peer: PeerPB\n} = require('./pb/peer'); // @ts-expect-error no types\n\n\nconst mortice = require('mortice');\n\nconst {\n  equals: uint8arrayEquals\n} = require('uint8arrays/equals');\n\nconst log = Object.assign(debug('libp2p:peer-store:store'), {\n  error: debug('libp2p:peer-store:store:err')\n});\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').EventName} EventName\n * @typedef {import('./types').Peer} Peer\n */\n\nconst NAMESPACE_COMMON = '/peers/';\n\nclass PersistentStore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor(datastore) {\n    this._datastore = datastore;\n    this.lock = mortice('peer-store', {\n      singleProcess: true\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {Key}\n   */\n\n\n  _peerIdToDatastoreKey(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data');\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS);\n    }\n\n    const b32key = peerId.toString();\n    return new Key(`${NAMESPACE_COMMON}${b32key}`);\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async has(peerId) {\n    return this._datastore.has(this._peerIdToDatastoreKey(peerId));\n  }\n  /**\n   * @param {PeerId} peerId\n   */\n\n\n  async delete(peerId) {\n    await this._datastore.delete(this._peerIdToDatastoreKey(peerId));\n  }\n  /**\n   * @param {PeerId} peerId\n   * @returns {Promise<import('./types').Peer>} peer\n   */\n\n\n  async load(peerId) {\n    const buf = await this._datastore.get(this._peerIdToDatastoreKey(peerId));\n    const peer = PeerPB.decode(buf);\n    const pubKey = peer.pubKey ? unmarshalPublicKey(peer.pubKey) : peerId.pubKey;\n    const metadata = new Map();\n\n    for (const meta of peer.metadata) {\n      metadata.set(meta.key, meta.value);\n    }\n\n    return { ...peer,\n      id: peerId,\n      pubKey,\n      addresses: peer.addresses.map(_ref => {\n        let {\n          multiaddr,\n          isCertified\n        } = _ref;\n        return {\n          multiaddr: new Multiaddr(multiaddr),\n          isCertified: isCertified || false\n        };\n      }),\n      metadata,\n      peerRecordEnvelope: peer.peerRecordEnvelope || undefined\n    };\n  }\n  /**\n   * @param {Peer} peer\n   */\n\n\n  async save(peer) {\n    if (peer.pubKey != null && peer.id.pubKey != null && !uint8arrayEquals(peer.pubKey.bytes, peer.id.pubKey.bytes)) {\n      log.error('peer publicKey bytes do not match peer id publicKey bytes');\n      throw errcode(new Error('publicKey bytes do not match peer id publicKey bytes'), codes.ERR_INVALID_PARAMETERS);\n    } // dedupe addresses\n\n\n    const addressSet = new Set();\n    const buf = PeerPB.encode({\n      addresses: peer.addresses.filter(address => {\n        if (addressSet.has(address.multiaddr.toString())) {\n          return false;\n        }\n\n        addressSet.add(address.multiaddr.toString());\n        return true;\n      }).sort((a, b) => {\n        return a.multiaddr.toString().localeCompare(b.multiaddr.toString());\n      }).map(_ref2 => {\n        let {\n          multiaddr,\n          isCertified\n        } = _ref2;\n        return {\n          multiaddr: multiaddr.bytes,\n          isCertified\n        };\n      }),\n      protocols: peer.protocols.sort(),\n      pubKey: peer.pubKey ? marshalPublicKey(peer.pubKey) : undefined,\n      metadata: [...peer.metadata.keys()].sort().map(key => ({\n        key,\n        value: peer.metadata.get(key)\n      })),\n      peerRecordEnvelope: peer.peerRecordEnvelope\n    }).finish();\n    await this._datastore.put(this._peerIdToDatastoreKey(peer.id), buf);\n    return this.load(peer.id);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n\n\n  async patch(peerId, data) {\n    const peer = await this.load(peerId);\n    return await this._patch(peerId, data, peer);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n\n\n  async patchOrCreate(peerId, data) {\n    /** @type {Peer} */\n    let peer;\n\n    try {\n      peer = await this.load(peerId);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n\n    return await this._patch(peerId, data, peer);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   * @param {Peer} peer\n   */\n\n\n  async _patch(peerId, data, peer) {\n    return await this.save({ ...peer,\n      ...data,\n      id: peerId\n    });\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n\n\n  async merge(peerId, data) {\n    const peer = await this.load(peerId);\n    return this._merge(peerId, data, peer);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n\n\n  async mergeOrCreate(peerId, data) {\n    /** @type {Peer} */\n    let peer;\n\n    try {\n      peer = await this.load(peerId);\n    } catch (\n    /** @type {any} */\n    err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err;\n      }\n\n      peer = {\n        id: peerId,\n        addresses: [],\n        protocols: [],\n        metadata: new Map()\n      };\n    }\n\n    return await this._merge(peerId, data, peer);\n  }\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   * @param {Peer} peer\n   */\n\n\n  async _merge(peerId, data, peer) {\n    // if the peer has certified addresses, use those in\n    // favour of the supplied versions\n\n    /** @type {Map<string, boolean>} */\n    const addresses = new Map();\n    (data.addresses || []).forEach(addr => {\n      addresses.set(addr.multiaddr.toString(), addr.isCertified);\n    });\n    peer.addresses.forEach(_ref3 => {\n      let {\n        multiaddr,\n        isCertified\n      } = _ref3;\n      const addrStr = multiaddr.toString();\n      addresses.set(addrStr, Boolean(addresses.get(addrStr) || isCertified));\n    });\n    return await this.save({\n      id: peerId,\n      addresses: Array.from(addresses.entries()).map(_ref4 => {\n        let [addrStr, isCertified] = _ref4;\n        return {\n          multiaddr: new Multiaddr(addrStr),\n          isCertified\n        };\n      }),\n      protocols: Array.from(new Set([...(peer.protocols || []), ...(data.protocols || [])])),\n      metadata: new Map([...(peer.metadata ? peer.metadata.entries() : []), ...(data.metadata ? data.metadata.entries() : [])]),\n      pubKey: data.pubKey || (peer != null ? peer.pubKey : undefined),\n      peerRecordEnvelope: data.peerRecordEnvelope || (peer != null ? peer.peerRecordEnvelope : undefined)\n    });\n  }\n\n  async *all() {\n    for await (const key of this._datastore.queryKeys({\n      prefix: NAMESPACE_COMMON\n    })) {\n      // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n      const base32Str = key.toString().split('/')[2];\n      const buf = base32.decode(base32Str);\n      yield this.load(PeerId.createFromBytes(buf));\n    }\n  }\n\n}\n\nmodule.exports = PersistentStore;","map":{"version":3,"names":["debug","require","PeerId","errcode","codes","Key","base32","keys","unmarshalPublicKey","marshalPublicKey","Multiaddr","Peer","PeerPB","mortice","equals","uint8arrayEquals","log","Object","assign","error","NAMESPACE_COMMON","PersistentStore","constructor","datastore","_datastore","lock","singleProcess","_peerIdToDatastoreKey","peerId","isPeerId","Error","ERR_INVALID_PARAMETERS","b32key","toString","has","delete","load","buf","get","peer","decode","pubKey","metadata","Map","meta","set","key","value","id","addresses","map","multiaddr","isCertified","peerRecordEnvelope","undefined","save","bytes","addressSet","Set","encode","filter","address","add","sort","a","b","localeCompare","protocols","finish","put","patch","data","_patch","patchOrCreate","err","code","ERR_NOT_FOUND","merge","_merge","mergeOrCreate","forEach","addr","addrStr","Boolean","Array","from","entries","all","queryKeys","prefix","base32Str","split","createFromBytes","module","exports"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/libp2p/src/peer-store/store.js"],"sourcesContent":["'use strict'\n\nconst debug = require('debug')\nconst PeerId = require('peer-id')\nconst errcode = require('err-code')\nconst { codes } = require('../errors')\nconst { Key } = require('interface-datastore/key')\nconst { base32 } = require('multiformats/bases/base32')\nconst { keys: { unmarshalPublicKey, marshalPublicKey } } = require('libp2p-crypto')\nconst { Multiaddr } = require('multiaddr')\nconst { Peer: PeerPB } = require('./pb/peer')\n// @ts-expect-error no types\nconst mortice = require('mortice')\nconst { equals: uint8arrayEquals } = require('uint8arrays/equals')\n\nconst log = Object.assign(debug('libp2p:peer-store:store'), {\n  error: debug('libp2p:peer-store:store:err')\n})\n\n/**\n * @typedef {import('./types').PeerStore} PeerStore\n * @typedef {import('./types').EventName} EventName\n * @typedef {import('./types').Peer} Peer\n */\n\nconst NAMESPACE_COMMON = '/peers/'\n\nclass PersistentStore {\n  /**\n   * @param {import('interface-datastore').Datastore} datastore\n   */\n  constructor (datastore) {\n    this._datastore = datastore\n    this.lock = mortice('peer-store', {\n      singleProcess: true\n    })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {Key}\n   */\n  _peerIdToDatastoreKey (peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      log.error('peerId must be an instance of peer-id to store data')\n      throw errcode(new Error('peerId must be an instance of peer-id'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    const b32key = peerId.toString()\n    return new Key(`${NAMESPACE_COMMON}${b32key}`)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async has (peerId) {\n    return this._datastore.has(this._peerIdToDatastoreKey(peerId))\n  }\n\n  /**\n   * @param {PeerId} peerId\n   */\n  async delete (peerId) {\n    await this._datastore.delete(this._peerIdToDatastoreKey(peerId))\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @returns {Promise<import('./types').Peer>} peer\n   */\n  async load (peerId) {\n    const buf = await this._datastore.get(this._peerIdToDatastoreKey(peerId))\n    const peer = PeerPB.decode(buf)\n    const pubKey = peer.pubKey ? unmarshalPublicKey(peer.pubKey) : peerId.pubKey\n    const metadata = new Map()\n\n    for (const meta of peer.metadata) {\n      metadata.set(meta.key, meta.value)\n    }\n\n    return {\n      ...peer,\n      id: peerId,\n      pubKey,\n      addresses: peer.addresses.map(({ multiaddr, isCertified }) => ({\n        multiaddr: new Multiaddr(multiaddr),\n        isCertified: isCertified || false\n      })),\n      metadata,\n      peerRecordEnvelope: peer.peerRecordEnvelope || undefined\n    }\n  }\n\n  /**\n   * @param {Peer} peer\n   */\n  async save (peer) {\n    if (peer.pubKey != null && peer.id.pubKey != null && !uint8arrayEquals(peer.pubKey.bytes, peer.id.pubKey.bytes)) {\n      log.error('peer publicKey bytes do not match peer id publicKey bytes')\n      throw errcode(new Error('publicKey bytes do not match peer id publicKey bytes'), codes.ERR_INVALID_PARAMETERS)\n    }\n\n    // dedupe addresses\n    const addressSet = new Set()\n\n    const buf = PeerPB.encode({\n      addresses: peer.addresses\n        .filter(address => {\n          if (addressSet.has(address.multiaddr.toString())) {\n            return false\n          }\n\n          addressSet.add(address.multiaddr.toString())\n          return true\n        })\n        .sort((a, b) => {\n          return a.multiaddr.toString().localeCompare(b.multiaddr.toString())\n        })\n        .map(({ multiaddr, isCertified }) => ({\n          multiaddr: multiaddr.bytes,\n          isCertified\n        })),\n      protocols: peer.protocols.sort(),\n      pubKey: peer.pubKey ? marshalPublicKey(peer.pubKey) : undefined,\n      metadata: [...peer.metadata.keys()].sort().map(key => ({ key, value: peer.metadata.get(key) })),\n      peerRecordEnvelope: peer.peerRecordEnvelope\n    }).finish()\n\n    await this._datastore.put(this._peerIdToDatastoreKey(peer.id), buf)\n\n    return this.load(peer.id)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n  async patch (peerId, data) {\n    const peer = await this.load(peerId)\n\n    return await this._patch(peerId, data, peer)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n  async patchOrCreate (peerId, data) {\n    /** @type {Peer} */\n    let peer\n\n    try {\n      peer = await this.load(peerId)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n\n      peer = { id: peerId, addresses: [], protocols: [], metadata: new Map() }\n    }\n\n    return await this._patch(peerId, data, peer)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   * @param {Peer} peer\n   */\n  async _patch (peerId, data, peer) {\n    return await this.save({\n      ...peer,\n      ...data,\n      id: peerId\n    })\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n  async merge (peerId, data) {\n    const peer = await this.load(peerId)\n\n    return this._merge(peerId, data, peer)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   */\n  async mergeOrCreate (peerId, data) {\n    /** @type {Peer} */\n    let peer\n\n    try {\n      peer = await this.load(peerId)\n    } catch (/** @type {any} */ err) {\n      if (err.code !== codes.ERR_NOT_FOUND) {\n        throw err\n      }\n\n      peer = { id: peerId, addresses: [], protocols: [], metadata: new Map() }\n    }\n\n    return await this._merge(peerId, data, peer)\n  }\n\n  /**\n   * @param {PeerId} peerId\n   * @param {Partial<Peer>} data\n   * @param {Peer} peer\n   */\n  async _merge (peerId, data, peer) {\n    // if the peer has certified addresses, use those in\n    // favour of the supplied versions\n    /** @type {Map<string, boolean>} */\n    const addresses = new Map()\n\n    ;(data.addresses || []).forEach(addr => {\n      addresses.set(addr.multiaddr.toString(), addr.isCertified)\n    })\n\n    peer.addresses.forEach(({ multiaddr, isCertified }) => {\n      const addrStr = multiaddr.toString()\n      addresses.set(addrStr, Boolean(addresses.get(addrStr) || isCertified))\n    })\n\n    return await this.save({\n      id: peerId,\n      addresses: Array.from(addresses.entries()).map(([addrStr, isCertified]) => {\n        return {\n          multiaddr: new Multiaddr(addrStr),\n          isCertified\n        }\n      }),\n      protocols: Array.from(new Set([\n        ...(peer.protocols || []),\n        ...(data.protocols || [])\n      ])),\n      metadata: new Map([\n        ...(peer.metadata ? peer.metadata.entries() : []),\n        ...(data.metadata ? data.metadata.entries() : [])\n      ]),\n      pubKey: data.pubKey || (peer != null ? peer.pubKey : undefined),\n      peerRecordEnvelope: data.peerRecordEnvelope || (peer != null ? peer.peerRecordEnvelope : undefined)\n    })\n  }\n\n  async * all () {\n    for await (const key of this._datastore.queryKeys({\n      prefix: NAMESPACE_COMMON\n    })) {\n      // /peers/${peer-id-as-libp2p-key-cid-string-in-base-32}\n      const base32Str = key.toString().split('/')[2]\n      const buf = base32.decode(base32Str)\n\n      yield this.load(PeerId.createFromBytes(buf))\n    }\n  }\n}\n\nmodule.exports = PersistentStore\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}