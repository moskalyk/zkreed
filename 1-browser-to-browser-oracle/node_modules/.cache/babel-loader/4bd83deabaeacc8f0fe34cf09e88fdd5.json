{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isMatching = exports.match = exports.instanceOf = exports.select = exports.not = exports.when = exports.__ = void 0;\n\nconst symbols = require(\"./symbols\");\n\nconst guards_1 = require(\"./guards\");\n\nObject.defineProperty(exports, \"when\", {\n  enumerable: true,\n  get: function () {\n    return guards_1.when;\n  }\n});\nObject.defineProperty(exports, \"not\", {\n  enumerable: true,\n  get: function () {\n    return guards_1.not;\n  }\n});\nObject.defineProperty(exports, \"select\", {\n  enumerable: true,\n  get: function () {\n    return guards_1.select;\n  }\n});\nObject.defineProperty(exports, \"instanceOf\", {\n  enumerable: true,\n  get: function () {\n    return guards_1.instanceOf;\n  }\n});\n\nconst wildcards_1 = require(\"./wildcards\");\n\nObject.defineProperty(exports, \"__\", {\n  enumerable: true,\n  get: function () {\n    return wildcards_1.__;\n  }\n});\n/**\n * #### match\n *\n * Entry point to create a pattern matching expression.\n *\n * It returns a `Match` builder, on which you can chain\n * several `.with(pattern, handler)` clauses.\n */\n\nconst match = value => builder(value, []);\n\nexports.match = match;\n/**\n * ### builder\n * This is the implementation of our pattern matching, using the\n * builder pattern.\n */\n\nconst builder = (value, cases) => {\n  const run = () => {\n    const entry = cases.find(_ref => {\n      let {\n        test\n      } = _ref;\n      return test(value);\n    });\n\n    if (!entry) {\n      let displayedValue;\n\n      try {\n        displayedValue = JSON.stringify(value);\n      } catch (e) {\n        displayedValue = value;\n      }\n\n      throw new Error(`Pattern matching error: no pattern matches value ${displayedValue}`);\n    }\n\n    return entry.handler(entry.select(value), value);\n  };\n\n  return {\n    with() {\n      var _ref2;\n\n      const handler = (_ref2 = arguments.length - 1, _ref2 < 0 || arguments.length <= _ref2 ? undefined : arguments[_ref2]);\n      const patterns = [];\n      const predicates = [];\n\n      for (let i = 0; i < arguments.length - 1; i++) {\n        const arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n        if (typeof arg === 'function') {\n          predicates.push(arg);\n        } else {\n          patterns.push(arg);\n        }\n      }\n\n      let selected = {};\n\n      const doesMatch = value => Boolean(patterns.some(pattern => matchPattern(pattern, value, (key, value) => {\n        selected[key] = value;\n      })) && predicates.every(predicate => predicate(value)));\n\n      return builder(value, cases.concat([{\n        test: doesMatch,\n        handler,\n        select: value => Object.keys(selected).length ? selected[guards_1.ANONYMOUS_SELECT_KEY] !== undefined ? selected[guards_1.ANONYMOUS_SELECT_KEY] : selected : value\n      }]));\n    },\n\n    when: (predicate, handler) => builder(value, cases.concat([{\n      test: predicate,\n      handler,\n      select: value => value\n    }])),\n    otherwise: handler => builder(value, cases.concat([{\n      test: () => true,\n      handler,\n      select: value => value\n    }])).run(),\n    exhaustive: () => run(),\n    run\n  };\n};\n\nconst isObject = value => Boolean(value && typeof value === 'object');\n\nconst isGuardPattern = x => {\n  const pattern = x;\n  return pattern && pattern[symbols.PatternKind] === symbols.Guard;\n};\n\nconst isNotPattern = x => {\n  const pattern = x;\n  return pattern && pattern[symbols.PatternKind] === symbols.Not;\n};\n\nconst isNamedSelectPattern = x => {\n  const pattern = x;\n  return pattern && pattern[symbols.PatternKind] === symbols.NamedSelect;\n};\n\nconst isAnonymousSelectPattern = x => {\n  const pattern = x;\n  return pattern && pattern[symbols.PatternKind] === symbols.AnonymousSelect;\n}; // tells us if the value matches a given pattern.\n\n\nconst matchPattern = (pattern, value, select) => {\n  if (isObject(pattern)) {\n    if (isGuardPattern(pattern)) return Boolean(pattern[symbols.Guard](value));\n\n    if (isNamedSelectPattern(pattern)) {\n      select(pattern[symbols.NamedSelect], value);\n      return true;\n    }\n\n    if (isAnonymousSelectPattern(pattern)) {\n      select(guards_1.ANONYMOUS_SELECT_KEY, value);\n      return true;\n    }\n\n    if (isNotPattern(pattern)) return !matchPattern(pattern[symbols.Not], value, select);\n    if (!isObject(value)) return false;\n\n    if (Array.isArray(pattern)) {\n      if (!Array.isArray(value)) return false; // List pattern\n\n      if (pattern.length === 1) {\n        const selected = {};\n\n        const listSelect = (key, value) => {\n          selected[key] = (selected[key] || []).concat([value]);\n        };\n\n        const doesMatch = value.every(v => matchPattern(pattern[0], v, listSelect));\n\n        if (doesMatch) {\n          Object.keys(selected).forEach(key => select(key, selected[key]));\n        }\n\n        return doesMatch;\n      } // Tuple pattern\n\n\n      return pattern.length === value.length ? pattern.every((subPattern, i) => matchPattern(subPattern, value[i], select)) : false;\n    }\n\n    if (pattern instanceof Map) {\n      if (!(value instanceof Map)) return false;\n      return [...pattern.keys()].every(key => matchPattern(pattern.get(key), value.get(key), select));\n    }\n\n    if (pattern instanceof Set) {\n      if (!(value instanceof Set)) return false;\n      if (pattern.size === 0) return value.size === 0;\n\n      if (pattern.size === 1) {\n        const [subPattern] = [...pattern.values()];\n        return Object.values(wildcards_1.__).includes(subPattern) ? matchPattern([subPattern], [...value.values()], select) : value.has(subPattern);\n      }\n\n      return [...pattern.values()].every(subPattern => value.has(subPattern));\n    }\n\n    return Object.keys(pattern).every(k => k in value && matchPattern( // @ts-ignore\n    pattern[k], // @ts-ignore\n    value[k], select));\n  }\n\n  return value === pattern;\n};\n\nfunction isMatching() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 1) {\n    const [pattern] = args;\n    return value => matchPattern(pattern, value, () => {});\n  }\n\n  if (args.length === 2) {\n    const [pattern, value] = args;\n    return matchPattern(pattern, value, () => {});\n  }\n\n  throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${args.length}.`);\n}\n\nexports.isMatching = isMatching;","map":{"version":3,"names":["Object","defineProperty","exports","value","isMatching","match","instanceOf","select","not","when","__","symbols","require","guards_1","enumerable","get","wildcards_1","builder","cases","run","entry","find","test","displayedValue","JSON","stringify","e","Error","handler","with","length","patterns","predicates","i","arg","push","selected","doesMatch","Boolean","some","pattern","matchPattern","key","every","predicate","concat","keys","ANONYMOUS_SELECT_KEY","undefined","otherwise","exhaustive","isObject","isGuardPattern","x","PatternKind","Guard","isNotPattern","Not","isNamedSelectPattern","NamedSelect","isAnonymousSelectPattern","AnonymousSelect","Array","isArray","listSelect","v","forEach","subPattern","Map","Set","size","values","includes","has","k","args"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/ts-pattern/lib/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isMatching = exports.match = exports.instanceOf = exports.select = exports.not = exports.when = exports.__ = void 0;\nconst symbols = require(\"./symbols\");\nconst guards_1 = require(\"./guards\");\nObject.defineProperty(exports, \"when\", { enumerable: true, get: function () { return guards_1.when; } });\nObject.defineProperty(exports, \"not\", { enumerable: true, get: function () { return guards_1.not; } });\nObject.defineProperty(exports, \"select\", { enumerable: true, get: function () { return guards_1.select; } });\nObject.defineProperty(exports, \"instanceOf\", { enumerable: true, get: function () { return guards_1.instanceOf; } });\nconst wildcards_1 = require(\"./wildcards\");\nObject.defineProperty(exports, \"__\", { enumerable: true, get: function () { return wildcards_1.__; } });\n/**\n * #### match\n *\n * Entry point to create a pattern matching expression.\n *\n * It returns a `Match` builder, on which you can chain\n * several `.with(pattern, handler)` clauses.\n */\nconst match = (value) => builder(value, []);\nexports.match = match;\n/**\n * ### builder\n * This is the implementation of our pattern matching, using the\n * builder pattern.\n */\nconst builder = (value, cases) => {\n    const run = () => {\n        const entry = cases.find(({ test }) => test(value));\n        if (!entry) {\n            let displayedValue;\n            try {\n                displayedValue = JSON.stringify(value);\n            }\n            catch (e) {\n                displayedValue = value;\n            }\n            throw new Error(`Pattern matching error: no pattern matches value ${displayedValue}`);\n        }\n        return entry.handler(entry.select(value), value);\n    };\n    return {\n        with(...args) {\n            const handler = args[args.length - 1];\n            const patterns = [];\n            const predicates = [];\n            for (let i = 0; i < args.length - 1; i++) {\n                const arg = args[i];\n                if (typeof arg === 'function') {\n                    predicates.push(arg);\n                }\n                else {\n                    patterns.push(arg);\n                }\n            }\n            let selected = {};\n            const doesMatch = (value) => Boolean(patterns.some((pattern) => matchPattern(pattern, value, (key, value) => {\n                selected[key] = value;\n            })) && predicates.every((predicate) => predicate(value)));\n            return builder(value, cases.concat([\n                {\n                    test: doesMatch,\n                    handler,\n                    select: (value) => Object.keys(selected).length\n                        ? selected[guards_1.ANONYMOUS_SELECT_KEY] !== undefined\n                            ? selected[guards_1.ANONYMOUS_SELECT_KEY]\n                            : selected\n                        : value,\n                },\n            ]));\n        },\n        when: (predicate, handler) => builder(value, cases.concat([\n            {\n                test: predicate,\n                handler,\n                select: (value) => value,\n            },\n        ])),\n        otherwise: (handler) => builder(value, cases.concat([\n            {\n                test: () => true,\n                handler,\n                select: (value) => value,\n            },\n        ])).run(),\n        exhaustive: () => run(),\n        run,\n    };\n};\nconst isObject = (value) => Boolean(value && typeof value === 'object');\nconst isGuardPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.Guard;\n};\nconst isNotPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.Not;\n};\nconst isNamedSelectPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.NamedSelect;\n};\nconst isAnonymousSelectPattern = (x) => {\n    const pattern = x;\n    return pattern && pattern[symbols.PatternKind] === symbols.AnonymousSelect;\n};\n// tells us if the value matches a given pattern.\nconst matchPattern = (pattern, value, select) => {\n    if (isObject(pattern)) {\n        if (isGuardPattern(pattern))\n            return Boolean(pattern[symbols.Guard](value));\n        if (isNamedSelectPattern(pattern)) {\n            select(pattern[symbols.NamedSelect], value);\n            return true;\n        }\n        if (isAnonymousSelectPattern(pattern)) {\n            select(guards_1.ANONYMOUS_SELECT_KEY, value);\n            return true;\n        }\n        if (isNotPattern(pattern))\n            return !matchPattern(pattern[symbols.Not], value, select);\n        if (!isObject(value))\n            return false;\n        if (Array.isArray(pattern)) {\n            if (!Array.isArray(value))\n                return false;\n            // List pattern\n            if (pattern.length === 1) {\n                const selected = {};\n                const listSelect = (key, value) => {\n                    selected[key] = (selected[key] || []).concat([value]);\n                };\n                const doesMatch = value.every((v) => matchPattern(pattern[0], v, listSelect));\n                if (doesMatch) {\n                    Object.keys(selected).forEach((key) => select(key, selected[key]));\n                }\n                return doesMatch;\n            }\n            // Tuple pattern\n            return pattern.length === value.length\n                ? pattern.every((subPattern, i) => matchPattern(subPattern, value[i], select))\n                : false;\n        }\n        if (pattern instanceof Map) {\n            if (!(value instanceof Map))\n                return false;\n            return [...pattern.keys()].every((key) => matchPattern(pattern.get(key), value.get(key), select));\n        }\n        if (pattern instanceof Set) {\n            if (!(value instanceof Set))\n                return false;\n            if (pattern.size === 0)\n                return value.size === 0;\n            if (pattern.size === 1) {\n                const [subPattern] = [...pattern.values()];\n                return Object.values(wildcards_1.__).includes(subPattern)\n                    ? matchPattern([subPattern], [...value.values()], select)\n                    : value.has(subPattern);\n            }\n            return [...pattern.values()].every((subPattern) => value.has(subPattern));\n        }\n        return Object.keys(pattern).every((k) => k in value &&\n            matchPattern(\n            // @ts-ignore\n            pattern[k], \n            // @ts-ignore\n            value[k], select));\n    }\n    return value === pattern;\n};\nfunction isMatching(...args) {\n    if (args.length === 1) {\n        const [pattern] = args;\n        return (value) => matchPattern(pattern, value, () => { });\n    }\n    if (args.length === 2) {\n        const [pattern, value] = args;\n        return matchPattern(pattern, value, () => { });\n    }\n    throw new Error(`isMatching wasn't given enough arguments: expected 1 or 2, received ${args.length}.`);\n}\nexports.isMatching = isMatching;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}