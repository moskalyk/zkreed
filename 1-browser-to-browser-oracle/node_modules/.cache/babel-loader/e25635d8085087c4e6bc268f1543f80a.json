{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Sig = exports.defaultSigGuard = exports.or = exports.and = exports.allowOnlyParticleOriginatedAt = exports.allowExactJsonPath = exports.allowServiceFn = exports.allowTetraplet = void 0;\n/**\n * Only allow calls when tetraplet for 'data' argument satisfies the predicate\n */\n\nvar allowTetraplet = function (pred) {\n  return function (params) {\n    var t = params.tetraplets.data[0];\n    return pred(t);\n  };\n};\n\nexports.allowTetraplet = allowTetraplet;\n/**\n * Only allow data which comes from the specified serviceId and fnName\n */\n\nvar allowServiceFn = function (serviceId, fnName) {\n  return (0, exports.allowTetraplet)(function (t) {\n    return t.service_id === serviceId && t.function_name === fnName;\n  });\n};\n\nexports.allowServiceFn = allowServiceFn;\n/**\n * Only allow data originated from the specified json_path\n */\n\nvar allowExactJsonPath = function (jsonPath) {\n  return (0, exports.allowTetraplet)(function (t) {\n    return t.json_path === jsonPath;\n  });\n};\n\nexports.allowExactJsonPath = allowExactJsonPath;\n/**\n * Only allow signing when particle is initiated at the specified peer\n */\n\nvar allowOnlyParticleOriginatedAt = function (peerId) {\n  return function (params) {\n    return params.initPeerId === peerId;\n  };\n};\n\nexports.allowOnlyParticleOriginatedAt = allowOnlyParticleOriginatedAt;\n/**\n * Only allow signing when all of the predicates are satisfied.\n * Useful for predicates reuse\n */\n\nvar and = function () {\n  var predicates = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    predicates[_i] = arguments[_i];\n  }\n\n  return function (params) {\n    return predicates.every(function (x) {\n      return x(params);\n    });\n  };\n};\n\nexports.and = and;\n/**\n * Only allow signing when any of the predicates are satisfied.\n * Useful for predicates reuse\n */\n\nvar or = function () {\n  var predicates = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    predicates[_i] = arguments[_i];\n  }\n\n  return function (params) {\n    return predicates.some(function (x) {\n      return x(params);\n    });\n  };\n};\n\nexports.or = or;\n\nvar defaultSigGuard = function (peerId) {\n  return (0, exports.and)((0, exports.allowOnlyParticleOriginatedAt)(peerId), (0, exports.or)((0, exports.allowServiceFn)('trust-graph', 'get_trust_bytes'), (0, exports.allowServiceFn)('trust-graph', 'get_revocation_bytes'), (0, exports.allowServiceFn)('registry', 'get_key_bytes'), (0, exports.allowServiceFn)('registry', 'get_record_bytes'), (0, exports.allowServiceFn)('registry', 'get_host_record_bytes')));\n};\n\nexports.defaultSigGuard = defaultSigGuard;\n\nvar Sig =\n/** @class */\nfunction () {\n  function Sig(keyPair) {\n    /**\n     *\n     */\n    this.securityGuard = function (params) {\n      return true;\n    };\n\n    this._keyPair = keyPair;\n  }\n  /**\n   * Gets the public key of KeyPair. Required by aqua\n   */\n\n\n  Sig.prototype.get_pub_key = function () {\n    return this._keyPair.toB58String();\n  };\n  /**\n   * Signs the data using key pair's private key. Required by aqua\n   */\n\n\n  Sig.prototype.sign = function (data, callParams) {\n    return __awaiter(this, void 0, void 0, function () {\n      var signedData;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.securityGuard(callParams)) {\n              return [2\n              /*return*/\n              , {\n                success: false,\n                error: 'Security guard validation failed',\n                signature: null\n              }];\n            }\n\n            return [4\n            /*yield*/\n            , this._keyPair.signBytes(Uint8Array.from(data))];\n\n          case 1:\n            signedData = _a.sent();\n            return [2\n            /*return*/\n            , {\n              success: true,\n              error: null,\n              signature: Array.from(signedData)\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Verifies the signature. Required by aqua\n   */\n\n\n  Sig.prototype.verify = function (signature, data) {\n    return this._keyPair.verify(Uint8Array.from(data), Uint8Array.from(signature));\n  };\n\n  return Sig;\n}();\n\nexports.Sig = Sig;","map":{"version":3,"mappings":"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","names":["allowTetraplet","pred","params","t","tetraplets","data","exports","allowServiceFn","serviceId","fnName","service_id","function_name","allowExactJsonPath","jsonPath","json_path","allowOnlyParticleOriginatedAt","peerId","initPeerId","and","predicates","every","x","or","some","defaultSigGuard","keyPair","_keyPair","Sig","toB58String","callParams","securityGuard","success","error","signature","signBytes","Uint8Array","from","signedData","_a","Array","verify"],"sources":["/Users/mgrok/Projects/fluence-projects/examples/quickstart/1-browser-to-browser/node_modules/@fluencelabs/fluence/src/internal/builtins/Sig.ts"],"sourcesContent":["import { SecurityTetraplet } from '@fluencelabs/avm';\nimport { CallParams, PeerIdB58 } from '../commonTypes';\nimport { KeyPair } from '../KeyPair';\nimport { SigDef } from '../_aqua/services';\n\n/**\n * A predicate of call params for sig service's sign method which determines whether signing operation is allowed or not\n */\nexport type SigSecurityGuard = (params: CallParams<'data'>) => boolean;\n\n/**\n * Only allow calls when tetraplet for 'data' argument satisfies the predicate\n */\nexport const allowTetraplet = (pred: (tetraplet: SecurityTetraplet) => boolean): SigSecurityGuard => {\n    return (params) => {\n        const t = params.tetraplets.data[0];\n        return pred(t);\n    };\n};\n\n/**\n * Only allow data which comes from the specified serviceId and fnName\n */\nexport const allowServiceFn = (serviceId: string, fnName: string): SigSecurityGuard => {\n    return allowTetraplet((t) => {\n        return t.service_id === serviceId && t.function_name === fnName;\n    });\n};\n\n/**\n * Only allow data originated from the specified json_path\n */\nexport const allowExactJsonPath = (jsonPath: string): SigSecurityGuard => {\n    return allowTetraplet((t) => {\n        return t.json_path === jsonPath;\n    });\n};\n\n/**\n * Only allow signing when particle is initiated at the specified peer\n */\nexport const allowOnlyParticleOriginatedAt = (peerId: PeerIdB58): SigSecurityGuard => {\n    return (params) => {\n        return params.initPeerId === peerId;\n    };\n};\n\n/**\n * Only allow signing when all of the predicates are satisfied.\n * Useful for predicates reuse\n */\nexport const and = (...predicates: SigSecurityGuard[]): SigSecurityGuard => {\n    return (params) => predicates.every((x) => x(params));\n};\n\n/**\n * Only allow signing when any of the predicates are satisfied.\n * Useful for predicates reuse\n */\nexport const or = (...predicates: SigSecurityGuard[]): SigSecurityGuard => {\n    return (params) => predicates.some((x) => x(params));\n};\n\nexport const defaultSigGuard = (peerId: PeerIdB58) => {\n    return and(\n        allowOnlyParticleOriginatedAt(peerId),\n        or(\n            allowServiceFn('trust-graph', 'get_trust_bytes'),\n            allowServiceFn('trust-graph', 'get_revocation_bytes'),\n            allowServiceFn('registry', 'get_key_bytes'),\n            allowServiceFn('registry', 'get_record_bytes'),\n            allowServiceFn('registry', 'get_host_record_bytes'),\n        ),\n    );\n};\n\nexport class Sig implements SigDef {\n    private _keyPair: KeyPair;\n\n    constructor(keyPair: KeyPair) {\n        this._keyPair = keyPair;\n    }\n\n    /**\n     *\n     */\n    securityGuard: SigSecurityGuard = (params) => {\n        return true;\n    };\n\n    /**\n     * Gets the public key of KeyPair. Required by aqua\n     */\n    get_pub_key() {\n        return this._keyPair.toB58String();\n    }\n\n    /**\n     * Signs the data using key pair's private key. Required by aqua\n     */\n    async sign(\n        data: number[],\n        callParams: CallParams<'data'>,\n    ): Promise<{ error: string | null; signature: number[] | null; success: boolean }> {\n        if (!this.securityGuard(callParams)) {\n            return {\n                success: false,\n                error: 'Security guard validation failed',\n                signature: null,\n            };\n        }\n\n        const signedData = await this._keyPair.signBytes(Uint8Array.from(data));\n\n        return {\n            success: true,\n            error: null,\n            signature: Array.from(signedData),\n        };\n    }\n\n    /**\n     * Verifies the signature. Required by aqua\n     */\n    verify(signature: number[], data: number[]): Promise<boolean> {\n        return this._keyPair.verify(Uint8Array.from(data), Uint8Array.from(signature));\n    }\n}\n"]},"metadata":{},"sourceType":"script"}