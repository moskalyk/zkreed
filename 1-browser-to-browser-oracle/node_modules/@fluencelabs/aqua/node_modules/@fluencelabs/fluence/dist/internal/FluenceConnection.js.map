{"version":3,"file":"FluenceConnection.js","sourceRoot":"","sources":["../../src/internal/FluenceConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport Websockets from 'libp2p-websockets';\nimport Mplex from 'libp2p-mplex';\nimport Lib2p2Peer from 'libp2p';\nimport { decode, encode } from 'it-length-prefixed';\nimport pipe from 'it-pipe';\nimport * as log from 'loglevel';\nimport { Particle } from './Particle';\nimport { NOISE } from '@chainsafe/libp2p-noise';\nimport PeerId from 'peer-id';\nimport { Multiaddr } from 'multiaddr';\nimport { all as allow_all } from 'libp2p-websockets/src/filters';\nimport { Connection } from 'libp2p-interfaces/src/topology';\nimport Buffer from './Buffer';\n\nexport const PROTOCOL_NAME = '/fluence/particle/2.0.0';\n\n/**\n * Options to configure fluence connection\n */\nexport interface FluenceConnectionOptions {\n    /**\n     * Peer id of the Fluence Peer\n     */\n    peerId: PeerId;\n\n    /**\n     * Multiaddress of the relay to make connection to\n     */\n    relayAddress: Multiaddr;\n\n    /**\n     * The dialing timeout in milliseconds\n     */\n    dialTimeoutMs?: number;\n\n    /**\n     * Handler for incoming particles from the connection\n     */\n    onIncomingParticle: (p: Particle) => void;\n}\n\nexport class FluenceConnection {\n    constructor() {}\n\n    static async createConnection(options: FluenceConnectionOptions): Promise<FluenceConnection> {\n        const res = new FluenceConnection();\n\n        const transportKey = Websockets.prototype[Symbol.toStringTag];\n        res._lib2p2Peer = await Lib2p2Peer.create({\n            peerId: options.peerId,\n            modules: {\n                transport: [Websockets],\n                streamMuxer: [Mplex],\n                connEncryption: [NOISE],\n            },\n            config: {\n                transport: {\n                    [transportKey]: {\n                        filter: allow_all,\n                    },\n                },\n            },\n            dialer: {\n                dialTimeout: options?.dialTimeoutMs,\n            },\n        });\n\n        res._lib2p2Peer.handle([PROTOCOL_NAME], async ({ connection, stream }) => {\n            pipe(stream.source, decode(), async (source: AsyncIterable<string>) => {\n                try {\n                    for await (const msg of source) {\n                        try {\n                            const particle = Particle.fromString(msg);\n                            options.onIncomingParticle(particle);\n                        } catch (e) {\n                            log.error('error on handling a new incoming message: ' + e);\n                        }\n                    }\n                } catch (e) {\n                    log.debug('connection closed: ' + e);\n                }\n            });\n        });\n\n        res._relayAddress = options.relayAddress;\n\n        return res;\n    }\n\n    async disconnect() {\n        await this._lib2p2Peer.stop();\n    }\n\n    public async sendParticle(particle: Particle): Promise<void> {\n        particle.logTo('debug', 'sending particle:');\n\n        /*\n        TODO:: find out why this doesn't work and a new connection has to be established each time\n        if (this._connection.streams.length !== 1) {\n            throw 'Incorrect number of streams in FluenceConnection';\n        }\n\n        const sink = this._connection.streams[0].sink;\n        */\n\n        const conn = await this._lib2p2Peer.dialProtocol(this._relayAddress, PROTOCOL_NAME);\n        const sink = conn.stream.sink;\n\n        pipe(\n            // force new line\n            [Buffer.from(particle.toString(), 'utf8')],\n            encode(),\n            sink,\n        );\n    }\n\n    public async connect() {\n        await this._lib2p2Peer.start();\n\n        log.debug(`dialing to the node with client's address: ` + this._lib2p2Peer.peerId.toB58String());\n\n        try {\n            this._connection = await this._lib2p2Peer.dial(this._relayAddress);\n        } catch (e1) {\n            const e = e1 as any;\n            if (e.name === 'AggregateError' && e._errors.length === 1) {\n                const error = e._errors[0];\n                throw `Error dialing node ${this._relayAddress}:\\n${error.code}\\n${error.message}`;\n            } else {\n                throw e;\n            }\n        }\n    }\n\n    private _lib2p2Peer: Lib2p2Peer;\n    private _connection: Connection;\n    private _relayAddress: Multiaddr;\n}\n"]}