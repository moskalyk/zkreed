{"version":3,"file":"FluenceConnection.js","sourceRoot":"","sources":["../../src/internal/FluenceConnection.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2020 Fluence Labs Limited\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// @ts-ignore\nimport Websockets from 'libp2p-websockets';\n// @ts-ignore\nimport Mplex from 'libp2p-mplex';\nimport Lib2p2Peer from 'libp2p';\nimport { decode, encode } from 'it-length-prefixed';\nimport { pipe } from 'it-pipe';\nimport * as log from 'loglevel';\nimport { Noise } from '@chainsafe/libp2p-noise';\nimport { Particle } from './Particle';\nimport PeerId from 'peer-id';\nimport { Multiaddr } from 'multiaddr';\n// @ts-ignore\nimport { all as allow_all } from 'libp2p-websockets/src/filters';\nimport { Connection } from 'libp2p-interfaces/src/topology';\nimport Buffer from './Buffer';\n\nexport const PROTOCOL_NAME = '/fluence/particle/2.0.0';\n\n/**\n * Options to configure fluence connection\n */\nexport interface FluenceConnectionOptions {\n    /**\n     * Peer id of the Fluence Peer\n     */\n    peerId: PeerId;\n\n    /**\n     * Multiaddress of the relay to make connection to\n     */\n    relayAddress: Multiaddr;\n\n    /**\n     * The dialing timeout in milliseconds\n     */\n    dialTimeoutMs?: number;\n\n    /**\n     * Handler for incoming particles from the connection\n     */\n    onIncomingParticle: (p: Particle) => void;\n}\n\nexport class FluenceConnection {\n    constructor(private _lib2p2Peer: Lib2p2Peer, private _relayAddress: Multiaddr) {}\n\n    private _connection?: Connection;\n\n    static async createConnection(options: FluenceConnectionOptions): Promise<FluenceConnection> {\n        const transportKey = Websockets.prototype[Symbol.toStringTag];\n        const lib2p2Peer = await Lib2p2Peer.create({\n            peerId: options.peerId,\n            modules: {\n                transport: [Websockets],\n                streamMuxer: [Mplex],\n                connEncryption: [new Noise()],\n            },\n            config: {\n                transport: {\n                    [transportKey]: {\n                        filter: allow_all,\n                    },\n                },\n            },\n            dialer: {\n                dialTimeout: options?.dialTimeoutMs,\n            },\n        });\n\n        lib2p2Peer.handle([PROTOCOL_NAME], async ({ connection, stream }) => {\n            pipe(\n                stream.source,\n                // @ts-ignore\n                decode(),\n                async (source: AsyncIterable<string>) => {\n                    try {\n                        for await (const msg of source) {\n                            try {\n                                const particle = Particle.fromString(msg);\n                                options.onIncomingParticle(particle);\n                            } catch (e) {\n                                log.error('error on handling a new incoming message: ' + e);\n                            }\n                        }\n                    } catch (e) {\n                        log.debug('connection closed: ' + e);\n                    }\n                },\n            );\n        });\n\n        const relayAddress = options.relayAddress;\n\n        return new FluenceConnection(lib2p2Peer, relayAddress);\n    }\n\n    async disconnect() {\n        await this._lib2p2Peer.stop();\n    }\n\n    async sendParticle(particle: Particle): Promise<void> {\n        particle.logTo('debug', 'sending particle:');\n\n        /*\n        TODO:: find out why this doesn't work and a new connection has to be established each time\n        if (this._connection.streams.length !== 1) {\n            throw new Error('Incorrect number of streams in FluenceConnection');\n        }\n\n        const sink = this._connection.streams[0].sink;\n        */\n\n        const conn = await this._lib2p2Peer.dialProtocol(this._relayAddress, PROTOCOL_NAME);\n        const sink = conn.stream.sink;\n\n        pipe(\n            // force new line\n            [Buffer.from(particle.toString(), 'utf8')],\n            encode(),\n            sink,\n        );\n    }\n\n    async connect() {\n        await this._lib2p2Peer.start();\n\n        log.debug(`dialing to the node with client's address: ` + this._lib2p2Peer.peerId.toB58String());\n\n        try {\n            this._connection = await this._lib2p2Peer.dial(this._relayAddress);\n        } catch (e: any) {\n            if (e.name === 'AggregateError' && e._errors?.length === 1) {\n                const error = e._errors[0];\n                throw new Error(`Error dialing node ${this._relayAddress}:\\n${error.code}\\n${error.message}`);\n            } else {\n                throw e;\n            }\n        }\n    }\n}\n"]}